# ========= Copyright 2023-2026 @ CAMEL-AI.org. All Rights Reserved. =========
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ========= Copyright 2023-2026 @ CAMEL-AI.org. All Rights Reserved. =========
# ruff: noqa: E501, E402
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Replay browser actions from HybridBrowserToolkit log files.

This script reads log files generated by HybridBrowserToolkit and replays
the actions by:
1. Connecting to a browser via CDP (port 9223)
2. Getting page snapshot before each action
3. Finding elements by aria-label from the original log
4. Executing the same actions with updated ref indices
5. Waiting for page stability between actions
"""

import asyncio
import json
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional
from urllib.request import urlopen

from dotenv import load_dotenv

# Add paths first
script_dir = Path(__file__).resolve().parent
project_root = script_dir.parent.parent.parent
sys.path.insert(0, str(project_root))
sys.path.insert(0, str(script_dir))

from utils import create_gpt4_model, extract_token_usage, get_timestamp_iso

from camel.agents import ChatAgent
from camel.toolkits.hybrid_browser_toolkit import HybridBrowserToolkit

load_dotenv()  # Load environment variables from .env.test file


class ActionReplayer:
    """Replays browser actions from log files."""

    def __init__(
        self,
        log_file: str,
        cdp_port: int = 9223,
        subtask_config: Optional[str] = None,
        subtask_id: Optional[str] = None,
        variables: Optional[Dict[str, str]] = None,
        use_agent_recovery: bool = True,
    ):
        """Initialize the replayer.

        Args:
            log_file (str): Path to the log file
            cdp_port (int): CDP port number (default: 9223)
            subtask_config (str, optional): Path to subtask configuration JSON file
            subtask_id (str, optional): ID of specific subtask to replay
            variables (dict, optional): Variable overrides for subtask replay
            use_agent_recovery (bool): Use ChatAgent for error recovery
        """
        self.log_file = Path(log_file)
        self.cdp_port = cdp_port
        self.toolkit: Optional[HybridBrowserToolkit] = None
        self.actions: List[Dict[str, Any]] = []
        self.current_snapshot: str = ""

        # Subtask configuration
        self.subtask_config_file = subtask_config
        self.subtask_id = subtask_id
        self.subtask_config: Optional[Dict[str, Any]] = None
        self.subtask_start_index: Optional[int] = None
        self.subtask_end_index: Optional[int] = None
        self.subtask_variables: Dict[str, Any] = {}
        self.variable_overrides = variables or {}

        # Agent recovery
        self.use_agent_recovery = use_agent_recovery
        self.recovery_agent: Optional[ChatAgent] = None
        self.action_history: List[Dict[str, str]] = []
        self.recovery_history: List[
            Dict[str, Any]
        ] = []  # Track all recovery attempts

        # Replay action logging
        self.replay_actions_log: List[
            Dict[str, Any]
        ] = []  # Track actions executed during replay

        # Mapping for config-based loading (action_step to array index)
        self._action_step_to_index: Dict[int, int] = {}

    def get_cdp_url(self) -> Optional[str]:
        """Get the CDP WebSocket URL."""
        try:
            with urlopen(
                f'http://localhost:{self.cdp_port}/json/version', timeout=5
            ) as response:
                data = json.loads(response.read().decode('utf-8'))
                return data.get('webSocketDebuggerUrl')
        except Exception as e:
            print(
                f"Error: Failed to get CDP URL from port {self.cdp_port}: {e}"
            )
            return None

    def load_subtask_config(self) -> None:
        """Load subtask configuration from JSON file."""
        if not self.subtask_config_file:
            return

        print(f"Loading subtask configuration: {self.subtask_config_file}")

        with open(self.subtask_config_file, 'r', encoding='utf-8') as f:
            self.subtask_config = json.load(f)

        # If subtask_id is specified, find its boundaries
        if self.subtask_id:
            subtasks = self.subtask_config.get('subtasks', [])
            for subtask in subtasks:
                # Support both string and integer comparison for id
                if str(subtask['id']) == str(self.subtask_id):
                    self.subtask_start_index = subtask['start_index']
                    self.subtask_end_index = subtask['end_index']
                    print(f"âœ“ Found subtask '{subtask['name']}':")
                    print(f"  Description: {subtask['description']}")
                    print(
                        f"  Actions: {self.subtask_start_index} to {self.subtask_end_index}"
                    )
                    if 'notes' in subtask:
                        print(f"  Notes: {subtask['notes']}")

                    # Check if subtask has detailed actions embedded
                    subtask_actions = subtask.get('actions', [])
                    if subtask_actions:
                        print(
                            f"  âœ“ Found {len(subtask_actions)} actions in subtask config (using embedded actions instead of log file)"
                        )

                        # Build a mapping from action_step to array index
                        action_step_to_index = {}
                        for idx, action in enumerate(subtask_actions):
                            action_step = action.get('action_step')
                            if action_step is not None:
                                action_step_to_index[action_step] = idx

                        # Convert subtask config action format to replay action format
                        # Subtask config format: {"action": "click", "args": ["e123"], ...}
                        # Replay format: {"action": "click", "inputs": {"args": ["e123"], "kwargs": {}}, ...}
                        converted_actions = []
                        for action in subtask_actions:
                            converted_action = {
                                'action': action.get('action', ''),
                                'inputs': {
                                    'args': action.get('args', []),
                                    'kwargs': {},
                                },
                                'outputs': {},  # Outputs will be generated during replay
                                'timestamp': action.get('timestamp', ''),
                                # Preserve other fields that might be useful
                                'action_step': action.get('action_step'),
                                'element_label': action.get('element_label'),
                            }
                            converted_actions.append(converted_action)

                        # Replace self.actions with the converted actions from config
                        self.actions = converted_actions
                        print(
                            f"  âœ“ Loaded {len(self.actions)} actions from subtask config"
                        )

                        # IMPORTANT: When loading from config, we need to adjust start/end indices
                        # because the actions array only contains the subtask actions (not the full log)
                        # We'll set start_index=0 and end_index=len(actions)-1 to replay all loaded actions
                        self.subtask_start_index = 0
                        self.subtask_end_index = len(converted_actions) - 1
                        print(
                            f"  âœ“ Adjusted subtask range to [0, {self.subtask_end_index}] for config-based loading"
                        )

                        # Store the mapping for later use when adjusting variable action_index
                        self._action_step_to_index = action_step_to_index

                    # Load variables
                    variables = subtask.get('variables', {})
                    if variables:
                        print("  Variables:")
                        for var_name, var_config in variables.items():
                            # Use override if provided, otherwise use default
                            if var_name in self.variable_overrides:
                                value = self.variable_overrides[var_name]
                                print(f"    {var_name}: {value} (overridden)")
                            else:
                                value = var_config['default_value']
                                print(f"    {var_name}: {value} (default)")

                            # Adjust action_index if we loaded from config
                            original_action_index = var_config['action_index']
                            adjusted_action_index = original_action_index

                            if hasattr(self, '_action_step_to_index'):
                                # Config-based loading: convert action_step to array index
                                if (
                                    original_action_index
                                    in self._action_step_to_index
                                ):
                                    adjusted_action_index = (
                                        self._action_step_to_index[
                                            original_action_index
                                        ]
                                    )
                                    print(
                                        f"    {var_name}: action_index adjusted from {original_action_index} (step) to {adjusted_action_index} (index)"
                                    )

                            # Store the variable with its configuration
                            self.subtask_variables[var_name] = {
                                'value': value,
                                'action_index': adjusted_action_index,
                                'arg_position': var_config['arg_position'],
                                'type': var_config['type'],
                            }

                    return

            print(
                f"Error: Subtask '{self.subtask_id}' not found in configuration"
            )
            print("Available subtasks:")
            for subtask in subtasks:
                print(f"  - {subtask['id']}: {subtask['name']}")
            raise ValueError(f"Subtask '{self.subtask_id}' not found")

    def load_log_file(self) -> List[Dict[str, Any]]:
        """Load and parse the log file.

        Returns:
            List of action dictionaries
        """
        actions = []
        print(f"Loading log file: {self.log_file}")

        with open(self.log_file, 'r', encoding='utf-8') as f:
            content = f.read()

        # Split JSON objects by finding balanced braces
        current_obj = ""
        brace_count = 0
        in_string = False
        escape_next = False

        for char in content:
            if escape_next:
                current_obj += char
                escape_next = False
                continue

            if char == '\\' and in_string:
                current_obj += char
                escape_next = True
                continue

            if char == '"' and not escape_next:
                in_string = not in_string

            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1

            current_obj += char

            # When we have a complete JSON object
            if brace_count == 0 and current_obj.strip():
                try:
                    action = json.loads(current_obj.strip())
                    actions.append(action)
                    current_obj = ""
                except json.JSONDecodeError as e:
                    print(f"Warning: Failed to parse JSON object: {e}")
                    print(f"Object preview: {current_obj[:100]}...")
                    current_obj = ""

        print(f"Loaded {len(actions)} actions from log file")
        return actions

    def is_failed_action(self, action: Dict[str, Any]) -> bool:
        """Check if an action failed in the original log.

        Args:
            action: Action dictionary from log

        Returns:
            True if action failed
        """
        outputs = action.get('outputs', {})

        # Check if outputs contains a failure indicator
        if isinstance(outputs, dict):
            result = outputs.get('result', '')
            if isinstance(result, str) and 'failed' in result.lower():
                return True

        return False

    def should_replay_action(self, action: Dict[str, Any]) -> bool:
        """Determine if an action should be replayed.

        Args:
            action: Action dictionary from log

        Returns:
            True if action should be replayed
        """
        action_name = action.get('action', '')

        # Actions to skip (read-only or logging actions)
        skip_actions = {
            'get_tab_info',
            'get_page_snapshot',
            'get_som_screenshot',
            'console_view',
            'get_page_links',
        }

        return action_name not in skip_actions

    def extract_aria_label_from_snapshot(
        self, snapshot: str, ref: str
    ) -> Optional[str]:
        """Extract aria-label for a given ref from snapshot.

        This method uses an improved algorithm:
        1. First tries to extract aria-label (text in quotes)
        2. If not found, looks for text value in child elements
        3. Returns the first child element's text value if available

        Args:
            snapshot: Snapshot text
            ref: Reference ID (e.g., 'e149')

        Returns:
            Aria-label text or child element text, or None if not found
        """
        lines = snapshot.split('\n')
        target_line_index = -1

        # Step 1: Find the line with the target ref
        for i, line in enumerate(lines):
            if f'[ref={ref}]' in line:
                target_line_index = i
                break

        if target_line_index == -1:
            return None

        target_line = lines[target_line_index]

        # Step 2: Try to extract aria-label (text between quotes)
        label_match = re.search(r'"([^"]+)"', target_line)
        if label_match:
            return label_match.group(1)

        # Step 3: No aria-label found, look for text in child elements
        # Get the indentation level of the target element
        target_indent = len(target_line) - len(target_line.lstrip())

        # Search subsequent lines for child elements with text values
        for i in range(target_line_index + 1, len(lines)):
            child_line = lines[i]

            # Skip empty lines
            if not child_line.strip():
                continue

            # Get child indentation
            child_indent = len(child_line) - len(child_line.lstrip())

            # If indentation is same or less, we've left the children
            if child_indent <= target_indent:
                break

            # Look for text value in child (format: "- element: text_value")
            # Match pattern: ": value" at the end of line
            text_match = re.search(r':\s*(.+)$', child_line)
            if text_match:
                text_value = text_match.group(1).strip()
                # Make sure it's not a ref or attribute marker
                if (
                    text_value
                    and not text_value.startswith('[')
                    and text_value != ':'
                ):
                    return text_value

        return None

    def find_label_in_snapshot(self, snapshot: str, ref: str) -> Optional[str]:
        """Find the aria-label for a given ref in the snapshot.

        Args:
            snapshot: Page snapshot
            ref: Element ref (e.g., 'e149')

        Returns:
            Aria-label string or None
        """
        lines = snapshot.split('\n')
        for line in lines:
            if f'[ref={ref}]' in line:
                # Extract label from the line
                label_match = re.search(r'"([^"]+)"', line)
                if label_match:
                    return label_match.group(1)
                # If no quoted label, try to get text content
                text_match = re.search(r':\s*(.+)$', line)
                if text_match:
                    text = text_match.group(1).strip()
                    if text and not text.startswith('['):
                        return text
        return None

    def extract_element_role_from_snapshot(
        self, snapshot: str, ref: str
    ) -> Optional[str]:
        """Extract element role (type) for a given ref from snapshot.

        Args:
            snapshot: Snapshot text
            ref: Reference ID (e.g., 'e149')

        Returns:
            Element role (e.g., 'button', 'gridcell', 'combobox') or None
        """
        lines = snapshot.split('\n')
        for line in lines:
            if f'[ref={ref}]' in line:
                # Extract element role from the line
                # Pattern: "- role_name" or "- role_name [ref=...]" or "- role_name "label" [ref=...]"
                role_match = re.match(r'\s*-\s+(\w+)', line)
                if role_match:
                    return role_match.group(1)
        return None

    def find_ref_by_aria_label(
        self,
        snapshot: str,
        aria_label: str,
        element_type: Optional[str] = None,
        element_role: Optional[str] = None,
    ) -> Optional[str]:
        """Find ref in current snapshot by aria-label using similarity matching.

        Uses a similarity-based algorithm with role filtering:
        1. Extract ref, label, and role separately from each line
        2. Filter by element_role if specified (must match original role)
        3. Calculate similarity percentage for each label
        4. Return the ref with highest similarity (100% for exact match)

        Similarity calculation:
        - Exact match (case-insensitive): 100%
        - Substring match: (len(aria_label) / len(label)) * 100
        - No match: 0%

        Args:
            snapshot: Current snapshot text
            aria_label: Aria-label to search for (supports regex patterns)
            element_type: Optional element type filter (e.g., 'combobox', 'button') [DEPRECATED, use element_role]
            element_role: Optional element role filter (e.g., 'button', 'gridcell', 'row') - must match original element role

        Returns:
            Ref ID (e.g., 'e149') or None if not found
        """
        # Store candidates with their similarity scores
        candidates = []  # List of (ref, similarity_score, label, role)

        aria_label_lower = aria_label.lower()

        for line in snapshot.split('\n'):
            # Step 1: Extract ref and label separately
            ref_match = re.search(r'\[ref=(e\d+)\]', line)
            label_match = re.search(r'"([^"]+)"', line)

            if not (ref_match and label_match):
                continue

            ref = ref_match.group(1)
            label = label_match.group(1)

            # Extract element role from line
            role_match = re.match(r'\s*-\s+(\w+)', line)
            current_role = role_match.group(1) if role_match else None

            # Filter by element_role (PRIORITY: role matching for consistency)
            if element_role:
                if current_role != element_role:
                    continue

            # Optional: Filter by element type (DEPRECATED, kept for backward compatibility)
            if element_type and not element_role:
                # Check if line contains the element type
                type_pattern = rf'^-\s+{element_type}\s+'
                if not re.search(type_pattern, line):
                    continue

            label_lower = label.lower()

            # Calculate similarity score
            similarity = 0.0

            # Exact match: 100% similarity
            if aria_label_lower == label_lower:
                similarity = 100.0
            # Substring match: calculate percentage based on length ratio
            elif aria_label_lower in label_lower:
                # Higher score if aria_label is a larger portion of the label
                similarity = (len(aria_label) / len(label)) * 100
            # Regex match (for backward compatibility)
            else:
                try:
                    if re.search(aria_label, label, re.IGNORECASE):
                        # Regex match but not substring - give it a lower score
                        similarity = 50.0
                except re.error:
                    # Invalid regex, no match
                    similarity = 0.0

            # Only add candidates with non-zero similarity
            if similarity > 0:
                candidates.append((ref, similarity, label, current_role))

        # Sort by similarity score (descending) and return the best match
        if candidates:
            candidates.sort(key=lambda x: x[1], reverse=True)
            best_ref, best_similarity, best_label, best_role = candidates[0]

            # Debug output to show matching details
            if best_similarity == 100.0:
                if element_role:
                    print(
                        f"  â†’ Exact match found: {best_ref} ({best_role}, 100% similarity)"
                    )
                else:
                    print(
                        f"  â†’ Exact match found: {best_ref} (100% similarity)"
                    )
            else:
                if element_role:
                    print(
                        f"  â†’ Best match: {best_ref} ({best_role}, {best_similarity:.1f}% similarity)"
                    )
                else:
                    print(
                        f"  â†’ Best match: {best_ref} ({best_similarity:.1f}% similarity)"
                    )
                print(f"     Target: '{aria_label}'")
                print(
                    f"     Found:  '{best_label[:100]}{'...' if len(best_label) > 100 else ''}'"
                )

            return best_ref
        else:
            return None

    async def get_current_snapshot(self) -> str:
        """Get current page snapshot and cache it.

        Returns:
            Snapshot text
        """
        if self.toolkit is None:
            raise RuntimeError("Toolkit not initialized")

        print("  â†’ Getting current page snapshot...")
        self.current_snapshot = await self.toolkit.browser_get_page_snapshot()
        return self.current_snapshot

    def get_latest_snapshot_before_action(self, action_index: int) -> str:
        """Get the most recent snapshot before a given action index.

        Args:
            action_index: Index of the action in self.actions (0-based)

        Returns:
            Snapshot text (empty if not found)
        """
        for i in range(action_index - 1, -1, -1):
            action = self.actions[i]
            outputs = action.get('outputs', {})

            # Check for snapshot in outputs (dict format)
            if isinstance(outputs, dict):
                snapshot = outputs.get('snapshot', '')
                if snapshot:
                    return snapshot
            # Check if outputs is directly a string (some get_page_snapshot actions)
            elif isinstance(outputs, str) and outputs:
                return outputs

        return ""

    def initialize_recovery_agent(self):
        """Initialize the ChatAgent for error recovery."""
        if not self.use_agent_recovery or self.recovery_agent is not None:
            return

        print("\n" + "=" * 80)
        print("INITIALIZING RECOVERY AGENT")
        print("=" * 80)

        # Create model
        model = create_gpt4_model()

        # Create agent with toolkit
        self.recovery_agent = ChatAgent(
            model=model, tools=self.toolkit.get_tools() if self.toolkit else []
        )

        print("âœ“ Recovery agent initialized")
        print()

    async def agent_recovery(
        self,
        failed_action: str,
        target_label: str,
        current_snapshot: str,
        error_message: str,
    ) -> Optional[str]:
        """Use ChatAgent to find the correct ref index from snapshot.

        Args:
            failed_action: The action that failed (e.g., 'click')
            target_label: The aria-label we were trying to find
            current_snapshot: Current page snapshot
            error_message: The error message

        Returns:
            The correct ref (e.g., 'e149') or None if not found
        """
        if not self.recovery_agent:
            return None

        # Build context about the subtask
        subtask_context = ""
        if self.subtask_id and self.subtask_config:
            subtasks = self.subtask_config.get('subtasks', [])
            for subtask in subtasks:
                if subtask['id'] == self.subtask_id:
                    subtask_context = f"""
Current Subtask: {subtask['name']}
Description: {subtask['description']}
"""
                    break

        # Build action history
        history_text = "\n".join(
            [
                f"{i+1}. {act['action']} on element '{act['label']}'"
                for i, act in enumerate(
                    self.action_history[-5:]
                )  # Last 5 actions
            ]
        )

        prompt = f"""
{subtask_context}

Previous Actions Performed:
{history_text if history_text else "None"}

CURRENT PROBLEM:
I was trying to perform action '{failed_action}' on an element with aria-label:
"{target_label}"

But this element was NOT found in the current page snapshot.

Error: {error_message}

CURRENT PAGE SNAPSHOT:
{current_snapshot}

TASK:
Analyze the current page snapshot and find the correct element ref that I should use for the '{failed_action}' action.

Look for:
1. An element with similar aria-label or text content
2. An element that makes sense given the subtask goal and action history
3. The element that would logically be the next step

IMPORTANT: You MUST respond with ONLY the ref index (e.g., "e149" or "e2810") of the element to use.
- If you find a suitable element, respond with just the ref like: e149
- If the action is no longer needed (task completed), respond with: SKIP
- If you cannot find any suitable element, respond with: NONE

Your response should be a single line with just the ref, SKIP, or NONE.
"""

        print("\n" + "=" * 80)
        print("ðŸ¤– CONSULTING RECOVERY AGENT")
        print("=" * 80)
        print(f"Failed action: {failed_action}")
        print(f"Target label: {target_label[:100]}...")
        print()

        # Get agent response
        response = self.recovery_agent.step(prompt)
        agent_msg = response.msgs[0].content.strip()

        # Extract token usage from recovery agent
        token_usage = {'prompt': 0, 'completion': 0, 'total': 0}
        if hasattr(response, 'info') and response.info:
            if 'usage' in response.info:
                token_usage = extract_token_usage(response.info['usage'])

        prompt_tokens = token_usage['prompt']
        completion_tokens = token_usage['completion']
        tokens_used = token_usage['total']

        print(f"Agent response: {agent_msg}")
        if tokens_used > 0:
            print(
                f"Tokens used in recovery: {tokens_used} (prompt: {prompt_tokens}, completion: {completion_tokens})"
            )
        print("=" * 80)

        # Record this recovery attempt
        recovery_record = {
            'timestamp': get_timestamp_iso(),
            'failed_action': failed_action,
            'target_label': target_label,
            'error_message': error_message,
            'prompt': prompt,  # Full prompt sent to agent
            'agent_response': agent_msg,
            'prompt_tokens': prompt_tokens,
            'completion_tokens': completion_tokens,
            'tokens_used': tokens_used,
        }

        # Parse the response
        result_ref = None
        if agent_msg == "SKIP":
            print("âœ“ Agent determined action is no longer needed")
            recovery_record['result'] = 'SKIP'
            result_ref = "SKIP"
        elif agent_msg == "NONE":
            print("âœ— Agent could not find suitable element")
            recovery_record['result'] = 'NONE'
            result_ref = None
        elif re.match(r'^e\d+$', agent_msg):
            print(f"âœ“ Agent found element: {agent_msg}")
            recovery_record['result'] = agent_msg
            result_ref = agent_msg
        else:
            # Try to extract ref from response
            ref_match = re.search(r'\b(e\d+)\b', agent_msg)
            if ref_match:
                found_ref = ref_match.group(1)
                print(f"âœ“ Extracted ref from response: {found_ref}")
                recovery_record['result'] = found_ref
                result_ref = found_ref
            else:
                print("âœ— Could not parse agent response")
                recovery_record['result'] = 'PARSE_ERROR'
                result_ref = None

        # Add to recovery history
        self.recovery_history.append(recovery_record)

        return result_ref

    async def replay_action(
        self, action: Dict[str, Any], action_index: int
    ) -> bool:
        """Replay a single action.

        Args:
            action: Action dictionary from log
            action_index: Index of the action in self.actions (0-based)

        Returns:
            True if action was successful
        """
        if self.toolkit is None:
            raise RuntimeError("Toolkit not initialized")

        action_name = action.get('action', '')
        inputs = action.get('inputs', {})
        args = inputs.get('args', [])

        print(f"\n{'='*80}")
        print(f"Replaying action: {action_name}")
        print(f"Original args: {args}")

        # Get current snapshot before action
        await self.get_current_snapshot()

        # Get original snapshot BEFORE this action (from log)
        original_snapshot = self.get_latest_snapshot_before_action(
            action_index
        )

        # Map old refs to new refs based on aria-label
        new_args = []
        element_not_found_info = None  # Track if we couldn't find an element

        for i, arg in enumerate(args):
            # Check if arg is a ref (e.g., 'e149' or 'e2214')
            # If it's a ref, we should use aria-label replacement, not direct arg replacement
            if isinstance(arg, str) and re.match(r'^e\d+$', arg):
                # Try to get aria-label from action's element_label field first (for config-based loading)
                # Note: element_label typically corresponds to the first ref (args[0]) in actions like click/type
                aria_label = None
                if (
                    i == 0
                    and 'element_label' in action
                    and action['element_label']
                ):
                    # Use element_label only for the first ref argument
                    aria_label = action['element_label']
                    print(
                        f"  â†’ Using element_label from action: '{aria_label}'"
                    )

                # If not available, extract from original snapshot (for log-based loading)
                if not aria_label:
                    aria_label = self.extract_aria_label_from_snapshot(
                        original_snapshot, arg
                    )
                    if aria_label:
                        print(
                            f"  â†’ Extracted aria-label from snapshot: '{aria_label}'"
                        )

                # Check if this aria-label should be replaced by a variable
                # For click actions, variables can modify the element label to search for
                label_replaced_by_variable = False
                for var_name, var_info in self.subtask_variables.items():
                    if (
                        var_info['action_index'] == action_index
                        and var_info['arg_position'] == i
                    ):
                        # Variable replaces the aria-label, not the ref itself
                        print(
                            f"  â†’ Variable '{var_name}' replaces aria-label: '{aria_label}' â†’ '{var_info['value']}'"
                        )
                        aria_label = var_info['value']
                        label_replaced_by_variable = True
                        break

                if aria_label:
                    if not label_replaced_by_variable:
                        print(
                            f"  â†’ Mapping ref {arg} with aria-label: '{aria_label}'"
                        )

                    # Extract original element role for consistency checking
                    original_role = self.extract_element_role_from_snapshot(
                        original_snapshot, arg
                    )
                    if original_role:
                        print(f"  â†’ Original element role: {original_role}")

                    # Find new ref in current snapshot with role filtering
                    new_ref = self.find_ref_by_aria_label(
                        self.current_snapshot,
                        aria_label,
                        element_role=original_role,
                    )

                    if new_ref:
                        print(f"  â†’ Found new ref: {new_ref}")
                        new_args.append(new_ref)
                        # Record this action for history
                        self.action_history.append(
                            {'action': action_name, 'label': aria_label}
                        )
                    else:
                        print(
                            f"  âš  Warning: Could not find element with aria-label '{aria_label}' in current snapshot"
                        )

                        # Store info for potential agent recovery
                        if self.use_agent_recovery:
                            element_not_found_info = {
                                'action': action_name,
                                'target_label': aria_label,
                                'original_ref': arg,
                            }

                        print("  â†’ Using original ref (may fail)")
                        new_args.append(arg)
                else:
                    # No aria-label found - give context-specific warning
                    if (
                        hasattr(self, '_action_step_to_index')
                        and self._action_step_to_index
                    ):
                        # Config-based loading: element_label might be missing for this action
                        print(
                            f"  âš  Warning: No element_label in action config and no snapshot available for ref {arg}"
                        )
                        print(
                            "  â†’ This typically happens for actions like 'enter' that don't target specific elements"
                        )
                    else:
                        # Log-based loading: snapshot should exist but aria-label not found
                        print(
                            f"  âš  Warning: Could not extract aria-label for ref {arg} from original snapshot"
                        )
                    print(
                        "  â†’ Using original ref (may fail if page structure changed)"
                    )
                    new_args.append(arg)
            else:
                # Not a ref - this could be text, number, etc.
                # Check if this argument should be replaced by a variable
                replaced_by_variable = False
                for var_name, var_info in self.subtask_variables.items():
                    if (
                        var_info['action_index'] == action_index
                        and var_info['arg_position'] == i
                    ):
                        print(
                            f"  â†’ Replacing argument at position {i} with variable '{var_name}': {var_info['value']}"
                        )
                        new_args.append(var_info['value'])
                        replaced_by_variable = True
                        break

                if not replaced_by_variable:
                    # Keep original value
                    new_args.append(arg)

        print(f"New args: {new_args}")

        # Execute action
        try:
            result = None

            if action_name == 'open_browser':
                # Check if toolkit is already connected via CDP
                # If toolkit has cdp_url, it means it's already connected to a browser
                if hasattr(self.toolkit, 'cdp_url') and self.toolkit.cdp_url:
                    print(
                        "  â†’ Browser already connected via CDP, skipping open_browser"
                    )
                    # If there's a URL, visit it
                    url = new_args[0] if new_args else None
                    if url:
                        result = await self.toolkit.browser_visit_page(url)
                    else:
                        # No URL, just return success since browser is already open
                        result = {
                            'result': 'Browser already connected via CDP'
                        }
                else:
                    # Normal case: toolkit not connected via CDP
                    url = new_args[0] if new_args else None
                    if url:
                        result = await self.toolkit.browser_visit_page(url)
                    else:
                        result = await self.toolkit.browser_open()

            elif action_name == 'click':
                if new_args:
                    result = await self.toolkit.browser_click(ref=new_args[0])

            elif action_name == 'type':
                # Type can have format: [ref, text] or [text, ref]
                # From the log, it seems to be [ref, text]
                if len(new_args) >= 2:
                    # Check which format it is
                    if re.match(r'^e\d+$', new_args[0]):
                        # Format: [ref, text]
                        result = await self.toolkit.browser_type(
                            ref=new_args[0], text=new_args[1]
                        )
                    else:
                        # Format: [text, ref]
                        result = await self.toolkit.browser_type(
                            ref=new_args[1], text=new_args[0]
                        )

            elif action_name == 'select':
                if len(new_args) >= 2:
                    result = await self.toolkit.browser_select(
                        ref=new_args[0], value=new_args[1]
                    )

            elif action_name == 'enter':
                result = await self.toolkit.browser_enter()

            elif action_name == 'scroll':
                direction = new_args[0] if new_args else 'down'
                amount = int(new_args[1]) if len(new_args) > 1 else 3
                result = await self.toolkit.browser_scroll(
                    direction=direction, amount=amount
                )

            elif action_name == 'back':
                result = await self.toolkit.browser_back()

            elif action_name == 'forward':
                result = await self.toolkit.browser_forward()

            elif action_name == 'visit_page':
                if new_args:
                    result = await self.toolkit.browser_visit_page(
                        url=new_args[0]
                    )

            elif action_name == 'switch_tab':
                if new_args:
                    result = await self.toolkit.browser_switch_tab(
                        tab_id=new_args[0]
                    )

            elif action_name == 'close_tab':
                if new_args:
                    result = await self.toolkit.browser_close_tab(
                        tab_id=new_args[0]
                    )

            elif action_name == 'new_tab':
                result = await self.toolkit.browser_new_tab()

            elif action_name == 'console_exec':
                if new_args:
                    code = ' '.join(str(arg) for arg in new_args)
                    result = await self.toolkit.browser_console_exec(code=code)

            elif action_name == 'console_view':
                result = await self.toolkit.browser_console_view()

            elif action_name == 'browser_sheet_input':
                # Extract cells from kwargs
                kwargs = inputs.get('kwargs', {})
                cells = kwargs.get('cells', [])
                if cells:
                    result = await self.toolkit.browser_sheet_input(
                        cells=cells
                    )

            elif action_name == 'browser_sheet_read':
                result = await self.toolkit.browser_sheet_read()

            elif action_name == 'mouse_control':
                if len(new_args) >= 3:
                    control = new_args[0]
                    x = float(new_args[1])
                    y = float(new_args[2])
                    result = await self.toolkit.browser_mouse_control(
                        control=control, x=x, y=y
                    )

            elif action_name == 'mouse_drag':
                if len(new_args) >= 2:
                    result = await self.toolkit.browser_mouse_drag(
                        from_ref=new_args[0], to_ref=new_args[1]
                    )

            elif action_name == 'press_key':
                if new_args:
                    result = await self.toolkit.browser_press_key(
                        keys=new_args
                    )

            elif action_name == 'get_page_links':
                if new_args:
                    result = await self.toolkit.browser_get_page_links(
                        ref=new_args
                    )

            else:
                print(f"  âš  Warning: Unknown action '{action_name}', skipping")
                return False

            print("  âœ“ Action executed successfully")

            # Log this replay action for later filtering
            self.replay_actions_log.append(
                {
                    'timestamp': get_timestamp_iso(),
                    'action': action_name,
                    'inputs': {
                        'args': new_args,
                        'kwargs': inputs.get('kwargs', {}),
                    },
                    'result': result
                    if isinstance(
                        result, (dict, str, list, int, float, bool, type(None))
                    )
                    else str(result),
                }
            )

            # Check if action failed
            action_failed = False
            error_message = ""

            if result:
                # Print first 200 chars of result
                result_str = str(result)
                if len(result_str) > 200:
                    print(f"  Result preview: {result_str[:200]}...")
                else:
                    print(f"  Result: {result_str}")

                # Check if result indicates any error
                if isinstance(result, dict):
                    result_message = result.get('result', '')

                    # Check for various failure patterns
                    if (
                        (
                            'Element with ref' in result_message
                            and 'not found' in result_message
                        )
                        or ('failed' in result_message.lower())
                        or ('error' in result_message.lower())
                        or ('not found' in result_message.lower())
                    ):
                        action_failed = True
                        error_message = result_message

            # If action failed and we have recovery enabled, try to recover
            if action_failed and self.use_agent_recovery:
                # Try to get context for recovery
                target_label = None
                if element_not_found_info:
                    target_label = element_not_found_info.get(
                        'target_label', ''
                    )
                elif new_args and len(new_args) > 0:
                    # Try to extract label from the current snapshot for the ref
                    ref_arg = new_args[0]
                    if isinstance(ref_arg, str) and re.match(
                        r'^e\d+$', ref_arg
                    ):
                        target_label = self.find_label_in_snapshot(
                            self.current_snapshot, ref_arg
                        )

                if not target_label:
                    target_label = f"Element for {action_name} action"

                # Trigger recovery for any failure
                print("\n" + "!" * 80)
                print("ACTION FAILED - TRIGGERING AGENT RECOVERY")
                print("!" * 80)
                print(f"Failed action: {action_name}")
                print(f"Error: {error_message}")

                # Consult recovery agent
                agent_ref = await self.agent_recovery(
                    failed_action=action_name,
                    target_label=target_label,
                    current_snapshot=self.current_snapshot,
                    error_message=error_message,
                )

                if agent_ref == "SKIP":
                    print("\nâœ“ Action skipped as suggested by agent")
                    return True  # Consider it successful
                elif agent_ref and agent_ref != "NONE":
                    print(
                        f"\nðŸ”„ Retrying action with agent-suggested ref: {agent_ref}"
                    )

                    # Retry the action with the new ref
                    retry_args = new_args.copy()
                    # Replace the first ref argument with agent's suggestion
                    for i, arg in enumerate(retry_args):
                        if isinstance(arg, str) and re.match(r'^e\d+$', arg):
                            retry_args[i] = agent_ref
                            break

                    print(f"  â†’ Retry args: {retry_args}")

                    # Re-execute the action
                    retry_result = None
                    if action_name == 'click':
                        if retry_args:
                            retry_result = await self.toolkit.browser_click(
                                ref=retry_args[0]
                            )
                    elif action_name == 'type':
                        if len(retry_args) >= 2:
                            retry_result = await self.toolkit.browser_type(
                                ref=retry_args[0], text=retry_args[1]
                            )
                    elif action_name == 'hover':
                        if retry_args:
                            retry_result = await self.toolkit.browser_hover(
                                ref=retry_args[0]
                            )
                    elif action_name == 'select':
                        if len(retry_args) >= 2:
                            retry_result = await self.toolkit.browser_select(
                                ref=retry_args[0], option=retry_args[1]
                            )

                    if retry_result:
                        retry_result_str = str(retry_result)
                        # Check if retry also failed
                        if (
                            (
                                'Element with ref' in retry_result_str
                                and 'not found' in retry_result_str
                            )
                            or ('failed' in retry_result_str.lower())
                            or ('error' in retry_result_str.lower())
                        ):
                            print("  âœ— Retry also failed")
                            return False
                        else:
                            print("  âœ“ Retry successful!")
                            # Record successful action
                            self.action_history.append(
                                {'action': action_name, 'label': target_label}
                            )

                            # Log this recovery retry action for later filtering
                            self.replay_actions_log.append(
                                {
                                    'timestamp': get_timestamp_iso(),
                                    'action': action_name,
                                    'inputs': {
                                        'args': retry_args,
                                        'kwargs': {},
                                    },
                                    'result': retry_result
                                    if isinstance(
                                        retry_result,
                                        (
                                            dict,
                                            str,
                                            list,
                                            int,
                                            float,
                                            bool,
                                            type(None),
                                        ),
                                    )
                                    else str(retry_result),
                                    'recovery_retry': True,  # Mark as recovery retry
                                }
                            )

                            return True
                else:
                    print("\nâœ— Agent could not find suitable element")
                    return False

            # Wait for page stability
            print("  â†’ Waiting for page stability...")
            await asyncio.sleep(1.5)

            return True

        except Exception as e:
            print(f"  âœ— Error executing action: {e}")
            import traceback

            traceback.print_exc()

            # Try agent recovery for exceptions too
            if self.use_agent_recovery:
                # Try to get context for recovery
                target_label = None
                if element_not_found_info:
                    target_label = element_not_found_info.get(
                        'target_label', ''
                    )
                elif new_args and len(new_args) > 0:
                    # Try to extract label from the current snapshot for the ref
                    ref_arg = new_args[0]
                    if isinstance(ref_arg, str) and re.match(
                        r'^e\d+$', ref_arg
                    ):
                        target_label = self.find_label_in_snapshot(
                            self.current_snapshot, ref_arg
                        )

                if not target_label:
                    target_label = f"Element for {action_name} action"

                print("\n" + "!" * 80)
                print("EXCEPTION DURING ACTION - TRIGGERING AGENT RECOVERY")
                print("!" * 80)
                print(f"Failed action: {action_name}")
                print(f"Exception: {e!s}")

                # Consult recovery agent
                agent_ref = await self.agent_recovery(
                    failed_action=action_name,
                    target_label=target_label,
                    current_snapshot=self.current_snapshot,
                    error_message=f"Exception: {e!s}",
                )

                if agent_ref == "SKIP":
                    print("\nâœ“ Action skipped as suggested by agent")
                    return True  # Consider it successful
                elif agent_ref and agent_ref != "NONE":
                    print(
                        f"\nðŸ”„ Retrying action with agent-suggested ref: {agent_ref}"
                    )

                    # Retry the action with the new ref
                    retry_args = new_args.copy()
                    # Replace the first ref argument with agent's suggestion
                    for i, arg in enumerate(retry_args):
                        if isinstance(arg, str) and re.match(r'^e\d+$', arg):
                            retry_args[i] = agent_ref
                            break

                    print(f"  â†’ Retry args: {retry_args}")

                    # Re-execute the action
                    try:
                        retry_result = None
                        if action_name == 'click':
                            if retry_args:
                                retry_result = (
                                    await self.toolkit.browser_click(
                                        ref=retry_args[0]
                                    )
                                )
                        elif action_name == 'type':
                            if len(retry_args) >= 2:
                                retry_result = await self.toolkit.browser_type(
                                    ref=retry_args[0], text=retry_args[1]
                                )
                        elif action_name == 'hover':
                            if retry_args:
                                retry_result = (
                                    await self.toolkit.browser_hover(
                                        ref=retry_args[0]
                                    )
                                )
                        elif action_name == 'select':
                            if len(retry_args) >= 2:
                                retry_result = (
                                    await self.toolkit.browser_select(
                                        ref=retry_args[0], option=retry_args[1]
                                    )
                                )

                        if retry_result:
                            print("  âœ“ Retry successful!")
                            # Record successful action
                            self.action_history.append(
                                {'action': action_name, 'label': target_label}
                            )

                            # Log this recovery retry action for later filtering
                            self.replay_actions_log.append(
                                {
                                    'timestamp': get_timestamp_iso(),
                                    'action': action_name,
                                    'inputs': {
                                        'args': retry_args,
                                        'kwargs': {},
                                    },
                                    'result': retry_result
                                    if isinstance(
                                        retry_result,
                                        (
                                            dict,
                                            str,
                                            list,
                                            int,
                                            float,
                                            bool,
                                            type(None),
                                        ),
                                    )
                                    else str(retry_result),
                                    'recovery_retry': True,  # Mark as recovery retry
                                }
                            )

                            return True
                    except Exception as retry_e:
                        print(f"  âœ— Retry also failed: {retry_e}")
                        return False

            return False

    def should_replay_in_subtask_mode(self, action_index: int) -> bool:
        """Check if an action should be replayed in subtask mode.

        Args:
            action_index: Index of the action (0-based)

        Returns:
            True if action should be replayed
        """
        # If no subtask is specified, replay all actions
        if self.subtask_start_index is None or self.subtask_end_index is None:
            return True

        # Only replay actions within subtask range
        return (
            self.subtask_start_index <= action_index <= self.subtask_end_index
        )

    async def replay_subtask(self) -> Dict[str, Any]:
        """Replay a single subtask and return detailed results.

        This method is designed to be called from SubtaskAgent.
        It assumes toolkit is already initialized.

        Returns:
            Dict with status, message, successful_actions, failed_actions
        """
        if not self.toolkit:
            raise RuntimeError("Toolkit not initialized")

        if not self.subtask_id:
            raise RuntimeError("No subtask ID specified")

        # Load subtask config if not loaded
        if self.subtask_start_index is None:
            self.load_subtask_config()

        print(f"\nðŸ”§ Replaying subtask: {self.subtask_id}")
        print(
            f"   Actions: {self.subtask_start_index} to {self.subtask_end_index}"
        )

        # Initialize recovery agent if needed
        if self.use_agent_recovery and not self.recovery_agent:
            self.initialize_recovery_agent()

        # Replay actions
        successful_actions = []
        failed_actions = []
        skipped_actions = []

        for i, action in enumerate(self.actions):
            action_index = i
            action_name = action.get('action', '')

            # Skip actions outside of subtask range
            if not self.should_replay_in_subtask_mode(action_index):
                continue

            # Skip read-only actions
            if not self.should_replay_action(action):
                skipped_actions.append(
                    {
                        'index': action_index,
                        'action': action_name,
                        'reason': 'read-only action',
                    }
                )
                continue

            # Skip actions that failed in original log
            if self.is_failed_action(action):
                skipped_actions.append(
                    {
                        'index': action_index,
                        'action': action_name,
                        'reason': 'failed in original log',
                    }
                )
                continue

            # Replay action
            print(f"\n[{action_index}] Replaying {action_name}...")
            success = await self.replay_action(action, action_index)

            if success:
                successful_actions.append(
                    {'index': action_index, 'action': action_name}
                )
            else:
                failed_actions.append(
                    {'index': action_index, 'action': action_name}
                )

        # Build result
        all_successful = len(failed_actions) == 0
        total_actions = (
            len(successful_actions)
            + len(failed_actions)
            + len(skipped_actions)
        )

        result = {
            'status': 'success'
            if all_successful
            else 'partial_success'
            if successful_actions
            else 'failed',
            'message': f"Subtask completed: {len(successful_actions)}/{len(successful_actions) + len(failed_actions)} actions successful",
            'total_actions': total_actions,
            'successful_actions': successful_actions,
            'failed_actions': failed_actions,
            'skipped_actions': skipped_actions,
            'all_successful': all_successful,
        }

        print("\n" + "=" * 80)
        print("SUBTASK EXECUTION SUMMARY")
        print("=" * 80)
        print(f"Status: {result['status']}")
        print(f"Successful: {len(successful_actions)}")
        print(f"Failed: {len(failed_actions)}")
        print(f"Skipped: {len(skipped_actions)}")
        print("=" * 80)

        return result

    async def replay_all(self):
        """Replay all actions from the log file (or specified subtask)."""
        # Load subtask configuration if provided
        if self.subtask_config_file:
            self.load_subtask_config()

        # Load log file only if actions weren't loaded from config
        if not self.actions:
            self.actions = self.load_log_file()
        else:
            print(
                f"âœ“ Using {len(self.actions)} actions from subtask config (skipping log file load)"
            )

        # Display mode
        if self.subtask_id:
            print("\n" + "=" * 80)
            print("SUBTASK REPLAY MODE")
            print("=" * 80)
            print(
                f"Will replay actions {self.subtask_start_index} to {self.subtask_end_index}"
            )
            print(
                f"(All {len(self.actions)} actions loaded for snapshot access)"
            )
            print()
        else:
            print("\n" + "=" * 80)
            print("FULL LOG REPLAY MODE")
            print("=" * 80)
            print()

        # Connect to browser
        cdp_url = self.get_cdp_url()
        if not cdp_url:
            print("Error: Could not connect to browser")
            print("Please ensure Chrome is running with:")
            print(
                "  /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --remote-debugging-port=9223"
            )
            return

        print(f"Connected to browser via CDP: {cdp_url}")

        # Initialize toolkit
        self.toolkit = HybridBrowserToolkit(
            mode="typescript",
            headless=False,
            stealth=True,
            browser_log_to_file=False,
            viewport_limit=False,
            cdp_url=cdp_url,
            default_start_url=None,
            cdp_keep_current_page=True,
        )

        try:
            # Check if we need to open browser first
            needs_browser_open = True
            if self.subtask_start_index is not None:
                first_action_index = self.subtask_start_index
            else:
                first_action_index = 0

            # Check if first action in range is already open_browser or visit_page
            for i in range(first_action_index, len(self.actions)):
                if self.should_replay_in_subtask_mode(
                    i
                ) and self.should_replay_action(self.actions[i]):
                    first_action_name = self.actions[i].get('action', '')
                    if first_action_name in ['open_browser', 'visit_page']:
                        needs_browser_open = False
                    break

            # Execute browser_open if needed
            if needs_browser_open:
                print("\n" + "=" * 80)
                print("INITIALIZATION")
                print("=" * 80)
                print(
                    "First action is not open_browser/visit_page, opening browser..."
                )
                await self.toolkit.browser_open()
                print("âœ“ Browser opened and ready")
                print()

            # Initialize recovery agent if needed
            if self.use_agent_recovery:
                self.initialize_recovery_agent()

            # Replay actions
            total_actions = len(self.actions)
            replayed_count = 0
            success_count = 0
            skipped_failed_count = 0

            for i, action in enumerate(self.actions):
                action_index = i  # 0-based index
                display_index = i + 1  # 1-based for display
                action_name = action.get('action', '')

                # Skip actions outside of subtask range
                if not self.should_replay_in_subtask_mode(action_index):
                    continue

                # Skip read-only actions
                if not self.should_replay_action(action):
                    print(
                        f"\n[{display_index}/{total_actions}] Skipping action: {action_name}"
                    )
                    continue

                # Skip actions that failed in the original log
                if self.is_failed_action(action):
                    skipped_failed_count += 1
                    outputs = action.get('outputs', {})
                    result = (
                        outputs.get('result', '')
                        if isinstance(outputs, dict)
                        else ''
                    )
                    print(
                        f"\n[{display_index}/{total_actions}] â­ï¸  Skipping failed action: {action_name}"
                    )
                    print(f"  Original error: {result}")
                    continue

                replayed_count += 1
                print(
                    f"\n[{display_index}/{total_actions}] ({replayed_count} replayed so far)"
                )

                # Replay action (pass action_index for snapshot lookup)
                success = await self.replay_action(action, action_index)
                if success:
                    success_count += 1
                    continue

                user_input = input(
                    "\nPress Enter to continue, 's' to skip to end, 'q' to quit: "
                )
                if user_input.lower() == 'q':
                    print("Replay stopped by user")
                    break
                elif user_input.lower() == 's':
                    print("Skipping to end...")
                    break

            # Summary
            print("\n" + "=" * 80)
            print("REPLAY SUMMARY")
            print("=" * 80)
            print(f"Total actions in log: {total_actions}")
            print(f"Actions replayed: {replayed_count}")
            print(f"Successful: {success_count}")
            print(f"Failed: {replayed_count - success_count}")
            print(f"Skipped (failed in original log): {skipped_failed_count}")

        finally:
            # Cleanup
            print("\nCleaning up...")
            # await self.toolkit.browser_close()
            print("Done!")


async def main():
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Replay browser actions from log file",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Replay entire log
  python replay_from_log.py my_log.log

  # Replay specific subtask
  python replay_from_log.py my_log.log --subtask-config my_log_subtasks.json --subtask-id 02_enter_departure_location

  # Replay subtask with variable overrides
  python replay_from_log.py my_log.log --subtask-config my_log_subtasks.json --subtask-id 02_enter_departure_location --var departure_city="London"

  # Multiple variables
  python replay_from_log.py my_log.log --subtask-config my_log_subtasks.json --subtask-id 04_set_travel_dates --var departure_date="2026-01-15" --var return_date="2026-01-20"

  # List available subtasks
  python replay_from_log.py my_log.log --subtask-config my_log_subtasks.json --list-subtasks
        """,
    )
    parser.add_argument('log_file', help='Path to the log file to replay')
    parser.add_argument(
        '--port',
        type=int,
        default=9223,
        help='CDP port number (default: 9223)',
    )
    parser.add_argument(
        '--subtask-config',
        help='Path to subtask configuration JSON file',
    )
    parser.add_argument(
        '--subtask-id',
        help='ID of specific subtask to replay',
    )
    parser.add_argument(
        '--var',
        action='append',
        help='Variable override in format key=value (can be used multiple times)',
    )
    parser.add_argument(
        '--list-subtasks',
        action='store_true',
        help='List available subtasks and exit',
    )
    parser.add_argument(
        '--use-agent-recovery',
        action='store_true',
        help='Use ChatAgent for intelligent error recovery when elements are not found',
    )

    args = parser.parse_args()

    # Check if log file exists
    if not Path(args.log_file).exists():
        print(f"Error: Log file not found: {args.log_file}")
        sys.exit(1)

    # List subtasks if requested
    if args.list_subtasks:
        if not args.subtask_config:
            print("Error: --subtask-config required with --list-subtasks")
            sys.exit(1)

        with open(args.subtask_config, 'r') as f:
            config = json.load(f)

        print("=" * 80)
        print("AVAILABLE SUBTASKS")
        print("=" * 80)
        print(f"Log file: {config.get('log_file', 'N/A')}")
        print(f"Task: {config.get('task_description', 'N/A')}")
        print()

        subtasks = config.get('subtasks', [])
        for i, subtask in enumerate(subtasks, 1):
            print(f"{i}. {subtask['id']}")
            print(f"   Name: {subtask['name']}")
            print(f"   Description: {subtask['description']}")
            print(
                f"   Actions: {subtask['start_index']}-{subtask['end_index']} ({subtask['end_index'] - subtask['start_index'] + 1} total)"
            )
            if 'notes' in subtask:
                print(f"   Notes: {subtask['notes']}")

            # Show variables if any
            if 'variables' in subtask:
                print("   Variables:")
                for var_name, var_config in subtask['variables'].items():
                    print(
                        f"     {var_name}: {var_config['description']} (default: {var_config['default_value']})"
                    )
            print()

        sys.exit(0)

    # Parse variable overrides
    variables = {}
    if args.var:
        for var_str in args.var:
            if '=' not in var_str:
                print(
                    f"Error: Invalid variable format '{var_str}'. Expected format: key=value"
                )
                sys.exit(1)
            key, value = var_str.split('=', 1)
            # Remove quotes if present
            value = value.strip('"').strip("'")
            variables[key.strip()] = value

    # Create replayer and run
    replayer = ActionReplayer(
        log_file=args.log_file,
        cdp_port=args.port,
        subtask_config=args.subtask_config,
        subtask_id=args.subtask_id,
        variables=variables,
        use_agent_recovery=args.use_agent_recovery,
    )
    await replayer.replay_all()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nReplay interrupted by user")
    except Exception as e:
        print(f"Replay failed: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)
