#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Replay browser actions from HybridBrowserToolkit log files.

This script reads log files generated by HybridBrowserToolkit and replays
the actions by:
1. Connecting to a browser via CDP (port 9223)
2. Getting page snapshot before each action
3. Finding elements by aria-label from the original log
4. Executing the same actions with updated ref indices
5. Waiting for page stability between actions
"""

import asyncio
import json
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional
from urllib.request import urlopen

from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env.test file

# Add project root to path
script_dir = Path(__file__).resolve().parent
project_root = script_dir.parent.parent.parent
sys.path.insert(0, str(project_root))

from camel.agents import ChatAgent
from camel.models import ModelFactory
from camel.toolkits.hybrid_browser_toolkit import HybridBrowserToolkit
from camel.types import ModelPlatformType, ModelType


class ActionReplayer:
    """Replays browser actions from log files."""

    def __init__(
        self,
        log_file: str,
        cdp_port: int = 9223,
        subtask_config: Optional[str] = None,
        subtask_id: Optional[str] = None,
        variables: Optional[Dict[str, str]] = None,
        use_agent_recovery: bool = True,
    ):
        """Initialize the replayer.

        Args:
            log_file (str): Path to the log file
            cdp_port (int): CDP port number (default: 9223)
            subtask_config (str, optional): Path to subtask configuration JSON file
            subtask_id (str, optional): ID of specific subtask to replay
            variables (dict, optional): Variable overrides for subtask replay
            use_agent_recovery (bool): Use ChatAgent for error recovery
        """
        self.log_file = Path(log_file)
        self.cdp_port = cdp_port
        self.toolkit: Optional[HybridBrowserToolkit] = None
        self.actions: List[Dict[str, Any]] = []
        self.current_snapshot: str = ""

        # Subtask configuration
        self.subtask_config_file = subtask_config
        self.subtask_id = subtask_id
        self.subtask_config: Optional[Dict[str, Any]] = None
        self.subtask_start_index: Optional[int] = None
        self.subtask_end_index: Optional[int] = None
        self.subtask_variables: Dict[str, Any] = {}
        self.variable_overrides = variables or {}

        # Agent recovery
        self.use_agent_recovery = use_agent_recovery
        self.recovery_agent: Optional[ChatAgent] = None
        self.action_history: List[Dict[str, str]] = []
        self.recovery_history: List[
            Dict[str, Any]
        ] = []  # Track all recovery attempts

    def get_cdp_url(self) -> Optional[str]:
        """Get the CDP WebSocket URL."""
        try:
            with urlopen(
                f'http://localhost:{self.cdp_port}/json/version', timeout=5
            ) as response:
                data = json.loads(response.read().decode('utf-8'))
                return data.get('webSocketDebuggerUrl')
        except Exception as e:
            print(
                f"Error: Failed to get CDP URL from port {self.cdp_port}: {e}"
            )
            return None

    def load_subtask_config(self) -> None:
        """Load subtask configuration from JSON file."""
        if not self.subtask_config_file:
            return

        print(f"Loading subtask configuration: {self.subtask_config_file}")

        with open(self.subtask_config_file, 'r', encoding='utf-8') as f:
            self.subtask_config = json.load(f)

        # If subtask_id is specified, find its boundaries
        if self.subtask_id:
            subtasks = self.subtask_config.get('subtasks', [])
            for subtask in subtasks:
                if subtask['id'] == self.subtask_id:
                    self.subtask_start_index = subtask['start_index']
                    self.subtask_end_index = subtask['end_index']
                    print(f"âœ“ Found subtask '{subtask['name']}':")
                    print(f"  Description: {subtask['description']}")
                    print(
                        f"  Actions: {self.subtask_start_index} to {self.subtask_end_index}"
                    )
                    if 'notes' in subtask:
                        print(f"  Notes: {subtask['notes']}")

                    # Load variables
                    variables = subtask.get('variables', {})
                    if variables:
                        print("  Variables:")
                        for var_name, var_config in variables.items():
                            # Use override if provided, otherwise use default
                            if var_name in self.variable_overrides:
                                value = self.variable_overrides[var_name]
                                print(f"    {var_name}: {value} (overridden)")
                            else:
                                value = var_config['default_value']
                                print(f"    {var_name}: {value} (default)")

                            # Store the variable with its configuration
                            self.subtask_variables[var_name] = {
                                'value': value,
                                'action_index': var_config['action_index'],
                                'arg_position': var_config['arg_position'],
                                'type': var_config['type'],
                            }

                    return

            print(
                f"Error: Subtask '{self.subtask_id}' not found in configuration"
            )
            print("Available subtasks:")
            for subtask in subtasks:
                print(f"  - {subtask['id']}: {subtask['name']}")
            raise ValueError(f"Subtask '{self.subtask_id}' not found")

    def load_log_file(self) -> List[Dict[str, Any]]:
        """Load and parse the log file.

        Returns:
            List of action dictionaries
        """
        actions = []
        print(f"Loading log file: {self.log_file}")

        with open(self.log_file, 'r', encoding='utf-8') as f:
            content = f.read()

        # Split JSON objects by finding balanced braces
        current_obj = ""
        brace_count = 0
        in_string = False
        escape_next = False

        for char in content:
            if escape_next:
                current_obj += char
                escape_next = False
                continue

            if char == '\\' and in_string:
                current_obj += char
                escape_next = True
                continue

            if char == '"' and not escape_next:
                in_string = not in_string

            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1

            current_obj += char

            # When we have a complete JSON object
            if brace_count == 0 and current_obj.strip():
                try:
                    action = json.loads(current_obj.strip())
                    actions.append(action)
                    current_obj = ""
                except json.JSONDecodeError as e:
                    print(f"Warning: Failed to parse JSON object: {e}")
                    print(f"Object preview: {current_obj[:100]}...")
                    current_obj = ""

        print(f"Loaded {len(actions)} actions from log file")
        return actions

    def is_failed_action(self, action: Dict[str, Any]) -> bool:
        """Check if an action failed in the original log.

        Args:
            action: Action dictionary from log

        Returns:
            True if action failed
        """
        outputs = action.get('outputs', {})

        # Check if outputs contains a failure indicator
        if isinstance(outputs, dict):
            result = outputs.get('result', '')
            if isinstance(result, str) and 'failed' in result.lower():
                return True

        return False

    def should_replay_action(self, action: Dict[str, Any]) -> bool:
        """Determine if an action should be replayed.

        Args:
            action: Action dictionary from log

        Returns:
            True if action should be replayed
        """
        action_name = action.get('action', '')

        # Actions to skip (read-only or logging actions)
        skip_actions = {
            'get_tab_info',
            'get_page_snapshot',
            'get_som_screenshot',
            'browser_get_som_screenshot',
            'console_view',
            'get_page_links',
        }

        return action_name not in skip_actions

    def extract_aria_label_from_snapshot(
        self, snapshot: str, ref: str
    ) -> Optional[str]:
        """Extract aria-label for a given ref from snapshot.

        This method uses an improved algorithm:
        1. First tries to extract aria-label (text in quotes)
        2. If not found, looks for text value in child elements
        3. Returns the first child element's text value if available

        Args:
            snapshot: Snapshot text
            ref: Reference ID (e.g., 'e149')

        Returns:
            Aria-label text or child element text, or None if not found
        """
        lines = snapshot.split('\n')
        target_line_index = -1

        # Step 1: Find the line with the target ref
        for i, line in enumerate(lines):
            if f'[ref={ref}]' in line:
                target_line_index = i
                break

        if target_line_index == -1:
            return None

        target_line = lines[target_line_index]

        # Step 2: Try to extract aria-label (text between quotes)
        label_match = re.search(r'"([^"]+)"', target_line)
        if label_match:
            return label_match.group(1)

        # Step 3: No aria-label found, look for text in child elements
        # Get the indentation level of the target element
        target_indent = len(target_line) - len(target_line.lstrip())

        # Search subsequent lines for child elements with text values
        for i in range(target_line_index + 1, len(lines)):
            child_line = lines[i]

            # Skip empty lines
            if not child_line.strip():
                continue

            # Get child indentation
            child_indent = len(child_line) - len(child_line.lstrip())

            # If indentation is same or less, we've left the children
            if child_indent <= target_indent:
                break

            # Look for text value in child (format: "- element: text_value")
            # Match pattern: ": value" at the end of line
            text_match = re.search(r':\s*(.+)$', child_line)
            if text_match:
                text_value = text_match.group(1).strip()
                # Make sure it's not a ref or attribute marker
                if (
                    text_value
                    and not text_value.startswith('[')
                    and text_value != ':'
                ):
                    return text_value

        return None

    def find_label_in_snapshot(self, snapshot: str, ref: str) -> Optional[str]:
        """Find the aria-label for a given ref in the snapshot.

        Args:
            snapshot: Page snapshot
            ref: Element ref (e.g., 'e149')

        Returns:
            Aria-label string or None
        """
        lines = snapshot.split('\n')
        for line in lines:
            if f'[ref={ref}]' in line:
                # Extract label from the line
                label_match = re.search(r'"([^"]+)"', line)
                if label_match:
                    return label_match.group(1)
                # If no quoted label, try to get text content
                text_match = re.search(r':\s*(.+)$', line)
                if text_match:
                    text = text_match.group(1).strip()
                    if text and not text.startswith('['):
                        return text
        return None

    def find_ref_by_aria_label(
        self,
        snapshot: str,
        aria_label: str,
        element_type: Optional[str] = None,
    ) -> Optional[str]:
        """Find ref in current snapshot by aria-label.

        Uses a two-step extraction algorithm similar to LogReplayModifierToolkit:
        1. Extract ref and label separately from each line
        2. Match the label against the search pattern

        Args:
            snapshot: Current snapshot text
            aria_label: Aria-label to search for (supports regex patterns)
            element_type: Optional element type filter (e.g., 'combobox', 'button')

        Returns:
            Ref ID (e.g., 'e149') or None if not found
        """
        # Find all matching elements using two-step extraction
        matching_refs = []

        for line in snapshot.split('\n'):
            # Step 1: Extract ref and label separately
            ref_match = re.search(r'\[ref=(e\d+)\]', line)
            label_match = re.search(r'"([^"]+)"', line)

            if not (ref_match and label_match):
                continue

            ref = ref_match.group(1)
            label = label_match.group(1)

            # Optional: Filter by element type
            if element_type:
                # Check if line contains the element type
                type_pattern = rf'^-\s+{element_type}\s+'
                if not re.search(type_pattern, line):
                    continue

            # Step 2: Match label against aria_label pattern
            try:
                # Try regex pattern matching (case-insensitive)
                if re.search(aria_label, label, re.IGNORECASE):
                    matching_refs.append(ref)
            except re.error:
                # If regex is invalid, fall back to exact substring match
                if aria_label.lower() in label.lower():
                    matching_refs.append(ref)

        # Return first match if any found
        return matching_refs[0] if matching_refs else None

    async def get_current_snapshot(self) -> str:
        """Get current page snapshot and cache it.

        Returns:
            Snapshot text
        """
        if self.toolkit is None:
            raise RuntimeError("Toolkit not initialized")

        print("  â†’ Getting current page snapshot...")
        self.current_snapshot = await self.toolkit.browser_get_page_snapshot()
        return self.current_snapshot

    def get_latest_snapshot_before_action(self, action_index: int) -> str:
        """Get the most recent snapshot before a given action index.

        Args:
            action_index: Index of the action in self.actions (0-based)

        Returns:
            Snapshot text (empty if not found)
        """
        for i in range(action_index - 1, -1, -1):
            action = self.actions[i]
            outputs = action.get('outputs', {})

            # Check for snapshot in outputs (dict format)
            if isinstance(outputs, dict):
                snapshot = outputs.get('snapshot', '')
                if snapshot:
                    return snapshot
            # Check if outputs is directly a string (some get_page_snapshot actions)
            elif isinstance(outputs, str) and outputs:
                return outputs

        return ""

    def initialize_recovery_agent(self):
        """Initialize the ChatAgent for error recovery."""
        if not self.use_agent_recovery or self.recovery_agent is not None:
            return

        print("\n" + "=" * 80)
        print("INITIALIZING RECOVERY AGENT")
        print("=" * 80)

        # Create model
        model = ModelFactory.create(
            model_platform=ModelPlatformType.AZURE,
            model_type=ModelType.GPT_4_1,
        )

        # Create agent with toolkit
        self.recovery_agent = ChatAgent(
            model=model, tools=self.toolkit.get_tools() if self.toolkit else []
        )

        print("âœ“ Recovery agent initialized")
        print()

    async def agent_recovery(
        self,
        failed_action: str,
        target_label: str,
        current_snapshot: str,
        error_message: str,
    ) -> Optional[str]:
        """Use ChatAgent to find the correct ref index from snapshot.

        Args:
            failed_action: The action that failed (e.g., 'click')
            target_label: The aria-label we were trying to find
            current_snapshot: Current page snapshot
            error_message: The error message

        Returns:
            The correct ref (e.g., 'e149') or None if not found
        """
        if not self.recovery_agent:
            return None

        # Build context about the subtask
        subtask_context = ""
        if self.subtask_id and self.subtask_config:
            subtasks = self.subtask_config.get('subtasks', [])
            for subtask in subtasks:
                if subtask['id'] == self.subtask_id:
                    subtask_context = f"""
Current Subtask: {subtask['name']}
Description: {subtask['description']}
"""
                    break

        # Build action history
        history_text = "\n".join(
            [
                f"{i+1}. {act['action']} on element '{act['label']}'"
                for i, act in enumerate(
                    self.action_history[-5:]
                )  # Last 5 actions
            ]
        )

        prompt = f"""
{subtask_context}

Previous Actions Performed:
{history_text if history_text else "None"}

CURRENT PROBLEM:
I was trying to perform action '{failed_action}' on an element with aria-label:
"{target_label}"

But this element was NOT found in the current page snapshot.

Error: {error_message}

CURRENT PAGE SNAPSHOT:
{current_snapshot}

TASK:
Analyze the current page snapshot and find the correct element ref that I should use for the '{failed_action}' action.

Look for:
1. An element with similar aria-label or text content
2. An element that makes sense given the subtask goal and action history
3. The element that would logically be the next step

IMPORTANT: You MUST respond with ONLY the ref index (e.g., "e149" or "e2810") of the element to use.
- If you find a suitable element, respond with just the ref like: e149
- If the action is no longer needed (task completed), respond with: SKIP
- If you cannot find any suitable element, respond with: NONE

Your response should be a single line with just the ref, SKIP, or NONE.
"""

        print("\n" + "=" * 80)
        print("ðŸ¤– CONSULTING RECOVERY AGENT")
        print("=" * 80)
        print(f"Failed action: {failed_action}")
        print(f"Target label: {target_label[:100]}...")
        print()

        # Get agent response
        response = self.recovery_agent.step(prompt)
        agent_msg = response.msgs[0].content.strip()

        # Extract token usage from recovery agent
        tokens_used = 0
        if hasattr(response, 'info') and response.info:
            if 'usage' in response.info:
                usage = response.info['usage']
                if hasattr(usage, 'prompt_tokens') and hasattr(
                    usage, 'completion_tokens'
                ):
                    tokens_used = usage.prompt_tokens + usage.completion_tokens
                elif isinstance(usage, dict):
                    tokens_used = usage.get('prompt_tokens', 0) + usage.get(
                        'completion_tokens', 0
                    )

        print(f"Agent response: {agent_msg}")
        if tokens_used > 0:
            print(f"Tokens used in recovery: {tokens_used}")
        print("=" * 80)

        # Record this recovery attempt
        recovery_record = {
            'failed_action': failed_action,
            'target_label': target_label,
            'error_message': error_message,
            'agent_response': agent_msg,
            'tokens_used': tokens_used,
        }

        # Parse the response
        result_ref = None
        if agent_msg == "SKIP":
            print("âœ“ Agent determined action is no longer needed")
            recovery_record['result'] = 'SKIP'
            result_ref = "SKIP"
        elif agent_msg == "NONE":
            print("âœ— Agent could not find suitable element")
            recovery_record['result'] = 'NONE'
            result_ref = None
        elif re.match(r'^e\d+$', agent_msg):
            print(f"âœ“ Agent found element: {agent_msg}")
            recovery_record['result'] = agent_msg
            result_ref = agent_msg
        else:
            # Try to extract ref from response
            ref_match = re.search(r'\b(e\d+)\b', agent_msg)
            if ref_match:
                found_ref = ref_match.group(1)
                print(f"âœ“ Extracted ref from response: {found_ref}")
                recovery_record['result'] = found_ref
                result_ref = found_ref
            else:
                print("âœ— Could not parse agent response")
                recovery_record['result'] = 'PARSE_ERROR'
                result_ref = None

        # Add to recovery history
        self.recovery_history.append(recovery_record)

        return result_ref

    async def replay_action(
        self, action: Dict[str, Any], action_index: int
    ) -> bool:
        """Replay a single action.

        Args:
            action: Action dictionary from log
            action_index: Index of the action in self.actions (0-based)

        Returns:
            True if action was successful
        """
        if self.toolkit is None:
            raise RuntimeError("Toolkit not initialized")

        action_name = action.get('action', '')
        inputs = action.get('inputs', {})
        args = inputs.get('args', [])

        print(f"\n{'='*80}")
        print(f"Replaying action: {action_name}")
        print(f"Original args: {args}")

        # Get current snapshot before action
        await self.get_current_snapshot()

        # Get original snapshot BEFORE this action (from log)
        original_snapshot = self.get_latest_snapshot_before_action(
            action_index
        )

        # Map old refs to new refs based on aria-label
        new_args = []
        element_not_found_info = None  # Track if we couldn't find an element

        for i, arg in enumerate(args):
            # Check if this argument should be replaced by a variable
            replaced_by_variable = False
            for var_name, var_info in self.subtask_variables.items():
                if (
                    var_info['action_index'] == action_index
                    and var_info['arg_position'] == i
                ):
                    print(
                        f"  â†’ Replacing argument at position {i} with variable '{var_name}': {var_info['value']}"
                    )
                    new_args.append(var_info['value'])
                    replaced_by_variable = True
                    break

            if replaced_by_variable:
                continue

            # Check if arg is a ref (e.g., 'e149' or 'e2214')
            if isinstance(arg, str) and re.match(r'^e\d+$', arg):
                # Extract aria-label from original snapshot
                aria_label = self.extract_aria_label_from_snapshot(
                    original_snapshot, arg
                )

                if aria_label:
                    print(
                        f"  â†’ Mapping ref {arg} with aria-label: '{aria_label}'"
                    )

                    # Find new ref in current snapshot
                    new_ref = self.find_ref_by_aria_label(
                        self.current_snapshot, aria_label
                    )

                    if new_ref:
                        print(f"  â†’ Found new ref: {new_ref}")
                        new_args.append(new_ref)
                        # Record this action for history
                        self.action_history.append(
                            {'action': action_name, 'label': aria_label}
                        )
                    else:
                        print(
                            f"  âš  Warning: Could not find element with aria-label '{aria_label}' in current snapshot"
                        )

                        # Store info for potential agent recovery
                        if self.use_agent_recovery:
                            element_not_found_info = {
                                'action': action_name,
                                'target_label': aria_label,
                                'original_ref': arg,
                            }

                        print("  â†’ Using original ref (may fail)")
                        new_args.append(arg)
                else:
                    print(
                        f"  âš  Warning: Could not extract aria-label for ref {arg} from original snapshot"
                    )
                    print("  â†’ Using original ref (may fail)")
                    new_args.append(arg)
            else:
                # Not a ref, keep as is
                new_args.append(arg)

        print(f"New args: {new_args}")

        # Execute action
        try:
            result = None

            if action_name == 'open_browser':
                # Check if toolkit is already connected via CDP
                # If toolkit has cdp_url, it means it's already connected to a browser
                if hasattr(self.toolkit, 'cdp_url') and self.toolkit.cdp_url:
                    print(
                        "  â†’ Browser already connected via CDP, skipping open_browser"
                    )
                    # If there's a URL, visit it
                    url = new_args[0] if new_args else None
                    if url:
                        result = await self.toolkit.browser_visit_page(url)
                    else:
                        # No URL, just return success since browser is already open
                        result = {
                            'result': 'Browser already connected via CDP'
                        }
                else:
                    # Normal case: toolkit not connected via CDP
                    url = new_args[0] if new_args else None
                    if url:
                        result = await self.toolkit.browser_visit_page(url)
                    else:
                        result = await self.toolkit.browser_open()

            elif action_name == 'click':
                if new_args:
                    result = await self.toolkit.browser_click(ref=new_args[0])

            elif action_name == 'type':
                # Type can have format: [ref, text] or [text, ref]
                # From the log, it seems to be [ref, text]
                if len(new_args) >= 2:
                    # Check which format it is
                    if re.match(r'^e\d+$', new_args[0]):
                        # Format: [ref, text]
                        result = await self.toolkit.browser_type(
                            ref=new_args[0], text=new_args[1]
                        )
                    else:
                        # Format: [text, ref]
                        result = await self.toolkit.browser_type(
                            ref=new_args[1], text=new_args[0]
                        )

            elif action_name == 'select':
                if len(new_args) >= 2:
                    result = await self.toolkit.browser_select(
                        ref=new_args[0], value=new_args[1]
                    )

            elif action_name == 'enter':
                result = await self.toolkit.browser_enter()

            elif action_name == 'scroll':
                direction = new_args[0] if new_args else 'down'
                amount = int(new_args[1]) if len(new_args) > 1 else 3
                result = await self.toolkit.browser_scroll(
                    direction=direction, amount=amount
                )

            elif action_name == 'back':
                result = await self.toolkit.browser_back()

            elif action_name == 'forward':
                result = await self.toolkit.browser_forward()

            elif action_name == 'visit_page':
                if new_args:
                    result = await self.toolkit.browser_visit_page(
                        url=new_args[0]
                    )

            elif action_name == 'switch_tab':
                if new_args:
                    result = await self.toolkit.browser_switch_tab(
                        tab_id=new_args[0]
                    )

            elif action_name == 'close_tab':
                if new_args:
                    result = await self.toolkit.browser_close_tab(
                        tab_id=new_args[0]
                    )

            elif action_name == 'new_tab':
                result = await self.toolkit.browser_new_tab()

            elif action_name == 'console_exec':
                if new_args:
                    code = ' '.join(str(arg) for arg in new_args)
                    result = await self.toolkit.browser_console_exec(code=code)

            elif action_name == 'console_view':
                result = await self.toolkit.browser_console_view()

            elif action_name == 'browser_sheet_input':
                # Extract cells from kwargs
                kwargs = inputs.get('kwargs', {})
                cells = kwargs.get('cells', [])
                if cells:
                    result = await self.toolkit.browser_sheet_input(
                        cells=cells
                    )

            elif action_name == 'browser_sheet_read':
                result = await self.toolkit.browser_sheet_read()

            elif action_name == 'mouse_control':
                if len(new_args) >= 3:
                    control = new_args[0]
                    x = float(new_args[1])
                    y = float(new_args[2])
                    result = await self.toolkit.browser_mouse_control(
                        control=control, x=x, y=y
                    )

            elif action_name == 'mouse_drag':
                if len(new_args) >= 2:
                    result = await self.toolkit.browser_mouse_drag(
                        from_ref=new_args[0], to_ref=new_args[1]
                    )

            elif action_name == 'press_key':
                if new_args:
                    result = await self.toolkit.browser_press_key(
                        keys=new_args
                    )

            elif action_name == 'get_page_links':
                if new_args:
                    result = await self.toolkit.browser_get_page_links(
                        ref=new_args
                    )

            else:
                print(f"  âš  Warning: Unknown action '{action_name}', skipping")
                return False

            print("  âœ“ Action executed successfully")

            # Check if action failed
            action_failed = False
            error_message = ""

            if result:
                # Print first 200 chars of result
                result_str = str(result)
                if len(result_str) > 200:
                    print(f"  Result preview: {result_str[:200]}...")
                else:
                    print(f"  Result: {result_str}")

                # Check if result indicates any error
                if isinstance(result, dict):
                    result_message = result.get('result', '')

                    # Check for various failure patterns
                    if (
                        (
                            'Element with ref' in result_message
                            and 'not found' in result_message
                        )
                        or ('failed' in result_message.lower())
                        or ('error' in result_message.lower())
                        or ('not found' in result_message.lower())
                    ):
                        action_failed = True
                        error_message = result_message

            # If action failed and we have recovery enabled, try to recover
            if action_failed and self.use_agent_recovery:
                # Try to get context for recovery
                target_label = None
                if element_not_found_info:
                    target_label = element_not_found_info.get(
                        'target_label', ''
                    )
                elif new_args and len(new_args) > 0:
                    # Try to extract label from the current snapshot for the ref
                    ref_arg = new_args[0]
                    if isinstance(ref_arg, str) and re.match(
                        r'^e\d+$', ref_arg
                    ):
                        target_label = self.find_label_in_snapshot(
                            self.current_snapshot, ref_arg
                        )

                if not target_label:
                    target_label = f"Element for {action_name} action"

                # Trigger recovery for any failure
                print("\n" + "!" * 80)
                print("ACTION FAILED - TRIGGERING AGENT RECOVERY")
                print("!" * 80)
                print(f"Failed action: {action_name}")
                print(f"Error: {error_message}")

                # Consult recovery agent
                agent_ref = await self.agent_recovery(
                    failed_action=action_name,
                    target_label=target_label,
                    current_snapshot=self.current_snapshot,
                    error_message=error_message,
                )

                if agent_ref == "SKIP":
                    print("\nâœ“ Action skipped as suggested by agent")
                    return True  # Consider it successful
                elif agent_ref and agent_ref != "NONE":
                    print(
                        f"\nðŸ”„ Retrying action with agent-suggested ref: {agent_ref}"
                    )

                    # Retry the action with the new ref
                    retry_args = new_args.copy()
                    # Replace the first ref argument with agent's suggestion
                    for i, arg in enumerate(retry_args):
                        if isinstance(arg, str) and re.match(r'^e\d+$', arg):
                            retry_args[i] = agent_ref
                            break

                    print(f"  â†’ Retry args: {retry_args}")

                    # Re-execute the action
                    retry_result = None
                    if action_name == 'click':
                        if retry_args:
                            retry_result = await self.toolkit.browser_click(
                                ref=retry_args[0]
                            )
                    elif action_name == 'type':
                        if len(retry_args) >= 2:
                            retry_result = await self.toolkit.browser_type(
                                ref=retry_args[0], text=retry_args[1]
                            )
                    elif action_name == 'hover':
                        if retry_args:
                            retry_result = await self.toolkit.browser_hover(
                                ref=retry_args[0]
                            )
                    elif action_name == 'select':
                        if len(retry_args) >= 2:
                            retry_result = await self.toolkit.browser_select(
                                ref=retry_args[0], option=retry_args[1]
                            )

                    if retry_result:
                        retry_result_str = str(retry_result)
                        # Check if retry also failed
                        if (
                            (
                                'Element with ref' in retry_result_str
                                and 'not found' in retry_result_str
                            )
                            or ('failed' in retry_result_str.lower())
                            or ('error' in retry_result_str.lower())
                        ):
                            print("  âœ— Retry also failed")
                            return False
                        else:
                            print("  âœ“ Retry successful!")
                            # Record successful action
                            self.action_history.append(
                                {'action': action_name, 'label': target_label}
                            )
                            return True
                else:
                    print("\nâœ— Agent could not find suitable element")
                    return False

            # Wait for page stability
            print("  â†’ Waiting for page stability...")
            await asyncio.sleep(1.5)

            return True

        except Exception as e:
            print(f"  âœ— Error executing action: {e}")
            import traceback

            traceback.print_exc()

            # Try agent recovery for exceptions too
            if self.use_agent_recovery:
                # Try to get context for recovery
                target_label = None
                if element_not_found_info:
                    target_label = element_not_found_info.get(
                        'target_label', ''
                    )
                elif new_args and len(new_args) > 0:
                    # Try to extract label from the current snapshot for the ref
                    ref_arg = new_args[0]
                    if isinstance(ref_arg, str) and re.match(
                        r'^e\d+$', ref_arg
                    ):
                        target_label = self.find_label_in_snapshot(
                            self.current_snapshot, ref_arg
                        )

                if not target_label:
                    target_label = f"Element for {action_name} action"

                print("\n" + "!" * 80)
                print("EXCEPTION DURING ACTION - TRIGGERING AGENT RECOVERY")
                print("!" * 80)
                print(f"Failed action: {action_name}")
                print(f"Exception: {e!s}")

                # Consult recovery agent
                agent_ref = await self.agent_recovery(
                    failed_action=action_name,
                    target_label=target_label,
                    current_snapshot=self.current_snapshot,
                    error_message=f"Exception: {e!s}",
                )

                if agent_ref == "SKIP":
                    print("\nâœ“ Action skipped as suggested by agent")
                    return True  # Consider it successful
                elif agent_ref and agent_ref != "NONE":
                    print(
                        f"\nðŸ”„ Retrying action with agent-suggested ref: {agent_ref}"
                    )

                    # Retry the action with the new ref
                    retry_args = new_args.copy()
                    # Replace the first ref argument with agent's suggestion
                    for i, arg in enumerate(retry_args):
                        if isinstance(arg, str) and re.match(r'^e\d+$', arg):
                            retry_args[i] = agent_ref
                            break

                    print(f"  â†’ Retry args: {retry_args}")

                    # Re-execute the action
                    try:
                        retry_result = None
                        if action_name == 'click':
                            if retry_args:
                                retry_result = (
                                    await self.toolkit.browser_click(
                                        ref=retry_args[0]
                                    )
                                )
                        elif action_name == 'type':
                            if len(retry_args) >= 2:
                                retry_result = await self.toolkit.browser_type(
                                    ref=retry_args[0], text=retry_args[1]
                                )
                        elif action_name == 'hover':
                            if retry_args:
                                retry_result = (
                                    await self.toolkit.browser_hover(
                                        ref=retry_args[0]
                                    )
                                )
                        elif action_name == 'select':
                            if len(retry_args) >= 2:
                                retry_result = (
                                    await self.toolkit.browser_select(
                                        ref=retry_args[0], option=retry_args[1]
                                    )
                                )

                        if retry_result:
                            print("  âœ“ Retry successful!")
                            # Record successful action
                            self.action_history.append(
                                {'action': action_name, 'label': target_label}
                            )
                            return True
                    except Exception as retry_e:
                        print(f"  âœ— Retry also failed: {retry_e}")
                        return False

            return False

    def should_replay_in_subtask_mode(self, action_index: int) -> bool:
        """Check if an action should be replayed in subtask mode.

        Args:
            action_index: Index of the action (0-based)

        Returns:
            True if action should be replayed
        """
        # If no subtask is specified, replay all actions
        if self.subtask_start_index is None or self.subtask_end_index is None:
            return True

        # Only replay actions within subtask range
        return (
            self.subtask_start_index <= action_index <= self.subtask_end_index
        )

    async def replay_subtask(self) -> Dict[str, Any]:
        """Replay a single subtask and return detailed results.

        This method is designed to be called from SubtaskAgent.
        It assumes toolkit is already initialized.

        Returns:
            Dict with status, message, successful_actions, failed_actions
        """
        if not self.toolkit:
            raise RuntimeError("Toolkit not initialized")

        if not self.subtask_id:
            raise RuntimeError("No subtask ID specified")

        # Load subtask config if not loaded
        if self.subtask_start_index is None:
            self.load_subtask_config()

        print(f"\nðŸ”§ Replaying subtask: {self.subtask_id}")
        print(
            f"   Actions: {self.subtask_start_index} to {self.subtask_end_index}"
        )

        # Initialize recovery agent if needed
        if self.use_agent_recovery and not self.recovery_agent:
            self.initialize_recovery_agent()

        # Replay actions
        successful_actions = []
        failed_actions = []
        skipped_actions = []

        for i, action in enumerate(self.actions):
            action_index = i
            action_name = action.get('action', '')

            # Skip actions outside of subtask range
            if not self.should_replay_in_subtask_mode(action_index):
                continue

            # Skip read-only actions
            if not self.should_replay_action(action):
                skipped_actions.append(
                    {
                        'index': action_index,
                        'action': action_name,
                        'reason': 'read-only action',
                    }
                )
                continue

            # Skip actions that failed in original log
            if self.is_failed_action(action):
                skipped_actions.append(
                    {
                        'index': action_index,
                        'action': action_name,
                        'reason': 'failed in original log',
                    }
                )
                continue

            # Replay action
            print(f"\n[{action_index}] Replaying {action_name}...")
            success = await self.replay_action(action, action_index)

            if success:
                successful_actions.append(
                    {'index': action_index, 'action': action_name}
                )
            else:
                failed_actions.append(
                    {'index': action_index, 'action': action_name}
                )

        # Build result
        all_successful = len(failed_actions) == 0
        total_actions = (
            len(successful_actions)
            + len(failed_actions)
            + len(skipped_actions)
        )

        result = {
            'status': 'success'
            if all_successful
            else 'partial_success'
            if successful_actions
            else 'failed',
            'message': f"Subtask completed: {len(successful_actions)}/{len(successful_actions) + len(failed_actions)} actions successful",
            'total_actions': total_actions,
            'successful_actions': successful_actions,
            'failed_actions': failed_actions,
            'skipped_actions': skipped_actions,
            'all_successful': all_successful,
        }

        print("\n" + "=" * 80)
        print("SUBTASK EXECUTION SUMMARY")
        print("=" * 80)
        print(f"Status: {result['status']}")
        print(f"Successful: {len(successful_actions)}")
        print(f"Failed: {len(failed_actions)}")
        print(f"Skipped: {len(skipped_actions)}")
        print("=" * 80)

        return result

    async def replay_all(self):
        """Replay all actions from the log file (or specified subtask)."""
        # Load subtask configuration if provided
        if self.subtask_config_file:
            self.load_subtask_config()

        # Load log file
        self.actions = self.load_log_file()

        # Display mode
        if self.subtask_id:
            print("\n" + "=" * 80)
            print("SUBTASK REPLAY MODE")
            print("=" * 80)
            print(
                f"Will replay actions {self.subtask_start_index} to {self.subtask_end_index}"
            )
            print(
                f"(All {len(self.actions)} actions loaded for snapshot access)"
            )
            print()
        else:
            print("\n" + "=" * 80)
            print("FULL LOG REPLAY MODE")
            print("=" * 80)
            print()

        # Connect to browser
        cdp_url = self.get_cdp_url()
        if not cdp_url:
            print("Error: Could not connect to browser")
            print("Please ensure Chrome is running with:")
            print(
                "  /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --remote-debugging-port=9223"
            )
            return

        print(f"Connected to browser via CDP: {cdp_url}")

        # Initialize toolkit
        self.toolkit = HybridBrowserToolkit(
            mode="typescript",
            headless=False,
            stealth=True,
            browser_log_to_file=False,
            viewport_limit=False,
            cdp_url=cdp_url,
            default_start_url=None,
            cdp_keep_current_page=True,
        )

        try:
            # Check if we need to open browser first
            needs_browser_open = True
            if self.subtask_start_index is not None:
                first_action_index = self.subtask_start_index
            else:
                first_action_index = 0

            # Check if first action in range is already open_browser or visit_page
            for i in range(first_action_index, len(self.actions)):
                if self.should_replay_in_subtask_mode(
                    i
                ) and self.should_replay_action(self.actions[i]):
                    first_action_name = self.actions[i].get('action', '')
                    if first_action_name in ['open_browser', 'visit_page']:
                        needs_browser_open = False
                    break

            # Execute browser_open if needed
            if needs_browser_open:
                print("\n" + "=" * 80)
                print("INITIALIZATION")
                print("=" * 80)
                print(
                    "First action is not open_browser/visit_page, opening browser..."
                )
                await self.toolkit.browser_open()
                print("âœ“ Browser opened and ready")
                print()

            # Initialize recovery agent if needed
            if self.use_agent_recovery:
                self.initialize_recovery_agent()

            # Replay actions
            total_actions = len(self.actions)
            replayed_count = 0
            success_count = 0
            skipped_failed_count = 0

            for i, action in enumerate(self.actions):
                action_index = i  # 0-based index
                display_index = i + 1  # 1-based for display
                action_name = action.get('action', '')

                # Skip actions outside of subtask range
                if not self.should_replay_in_subtask_mode(action_index):
                    continue

                # Skip read-only actions
                if not self.should_replay_action(action):
                    print(
                        f"\n[{display_index}/{total_actions}] Skipping action: {action_name}"
                    )
                    continue

                # Skip actions that failed in the original log
                if self.is_failed_action(action):
                    skipped_failed_count += 1
                    outputs = action.get('outputs', {})
                    result = (
                        outputs.get('result', '')
                        if isinstance(outputs, dict)
                        else ''
                    )
                    print(
                        f"\n[{display_index}/{total_actions}] â­ï¸  Skipping failed action: {action_name}"
                    )
                    print(f"  Original error: {result}")
                    continue

                replayed_count += 1
                print(
                    f"\n[{display_index}/{total_actions}] ({replayed_count} replayed so far)"
                )

                # Replay action (pass action_index for snapshot lookup)
                success = await self.replay_action(action, action_index)
                if success:
                    success_count += 1
                    continue

                user_input = input(
                    "\nPress Enter to continue, 's' to skip to end, 'q' to quit: "
                )
                if user_input.lower() == 'q':
                    print("Replay stopped by user")
                    break
                elif user_input.lower() == 's':
                    print("Skipping to end...")
                    break

            # Summary
            print("\n" + "=" * 80)
            print("REPLAY SUMMARY")
            print("=" * 80)
            print(f"Total actions in log: {total_actions}")
            print(f"Actions replayed: {replayed_count}")
            print(f"Successful: {success_count}")
            print(f"Failed: {replayed_count - success_count}")
            print(f"Skipped (failed in original log): {skipped_failed_count}")

        finally:
            # Cleanup
            print("\nCleaning up...")
            # await self.toolkit.browser_close()
            print("Done!")


async def main():
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Replay browser actions from log file",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Replay entire log
  python replay_from_log.py my_log.log

  # Replay specific subtask
  python replay_from_log.py my_log.log --subtask-config my_log_subtasks.json --subtask-id 02_enter_departure_location

  # Replay subtask with variable overrides
  python replay_from_log.py my_log.log --subtask-config my_log_subtasks.json --subtask-id 02_enter_departure_location --var departure_city="London"

  # Multiple variables
  python replay_from_log.py my_log.log --subtask-config my_log_subtasks.json --subtask-id 04_set_travel_dates --var departure_date="2026-01-15" --var return_date="2026-01-20"

  # List available subtasks
  python replay_from_log.py my_log.log --subtask-config my_log_subtasks.json --list-subtasks
        """,
    )
    parser.add_argument('log_file', help='Path to the log file to replay')
    parser.add_argument(
        '--port',
        type=int,
        default=9223,
        help='CDP port number (default: 9223)',
    )
    parser.add_argument(
        '--subtask-config',
        help='Path to subtask configuration JSON file',
    )
    parser.add_argument(
        '--subtask-id',
        help='ID of specific subtask to replay',
    )
    parser.add_argument(
        '--var',
        action='append',
        help='Variable override in format key=value (can be used multiple times)',
    )
    parser.add_argument(
        '--list-subtasks',
        action='store_true',
        help='List available subtasks and exit',
    )
    parser.add_argument(
        '--use-agent-recovery',
        action='store_true',
        help='Use ChatAgent for intelligent error recovery when elements are not found',
    )

    args = parser.parse_args()

    # Check if log file exists
    if not Path(args.log_file).exists():
        print(f"Error: Log file not found: {args.log_file}")
        sys.exit(1)

    # List subtasks if requested
    if args.list_subtasks:
        if not args.subtask_config:
            print("Error: --subtask-config required with --list-subtasks")
            sys.exit(1)

        with open(args.subtask_config, 'r') as f:
            config = json.load(f)

        print("=" * 80)
        print("AVAILABLE SUBTASKS")
        print("=" * 80)
        print(f"Log file: {config.get('log_file', 'N/A')}")
        print(f"Task: {config.get('task_description', 'N/A')}")
        print()

        subtasks = config.get('subtasks', [])
        for i, subtask in enumerate(subtasks, 1):
            print(f"{i}. {subtask['id']}")
            print(f"   Name: {subtask['name']}")
            print(f"   Description: {subtask['description']}")
            print(
                f"   Actions: {subtask['start_index']}-{subtask['end_index']} ({subtask['end_index'] - subtask['start_index'] + 1} total)"
            )
            if 'notes' in subtask:
                print(f"   Notes: {subtask['notes']}")

            # Show variables if any
            if 'variables' in subtask:
                print("   Variables:")
                for var_name, var_config in subtask['variables'].items():
                    print(
                        f"     {var_name}: {var_config['description']} (default: {var_config['default_value']})"
                    )
            print()

        sys.exit(0)

    # Parse variable overrides
    variables = {}
    if args.var:
        for var_str in args.var:
            if '=' not in var_str:
                print(
                    f"Error: Invalid variable format '{var_str}'. Expected format: key=value"
                )
                sys.exit(1)
            key, value = var_str.split('=', 1)
            # Remove quotes if present
            value = value.strip('"').strip("'")
            variables[key.strip()] = value

    # Create replayer and run
    replayer = ActionReplayer(
        log_file=args.log_file,
        cdp_port=args.port,
        subtask_config=args.subtask_config,
        subtask_id=args.subtask_id,
        variables=variables,
        use_agent_recovery=args.use_agent_recovery,
    )
    await replayer.replay_all()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nReplay interrupted by user")
    except Exception as e:
        print(f"Replay failed: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)
