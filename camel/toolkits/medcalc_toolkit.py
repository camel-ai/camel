# ========= Copyright 2023-2024 @ CAMEL-AI.org. All Rights Reserved. =========
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ========= Copyright 2023-2024 @ CAMEL-AI.org. All Rights Reserved. =========

import json
from typing import List, Optional

from camel.logger import get_logger
from camel.toolkits import FunctionTool
from camel.toolkits.base import BaseToolkit

logger = get_logger(__name__)


class MedCalcToolkit(BaseToolkit):
    def __init__(
        self,
        default_variable: str = "x",
        timeout: Optional[float] = None,
    ):
        r"""Initializes the toolkit with a default variable and optional
        timeout.

        Args:
            default_variable (str): The default variable used in symbolic
                computations (default: :obj:`x`).
            timeout (Optional[float]): The maximum time allowed for each
                computation (in seconds). If `None`, no timeout is enforced.
        """
        super().__init__(timeout=timeout)
        self.default_variable = default_variable
        logger.info(f"Default variable set to: {self.default_variable}")

    def adjusted_body_weight(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 89)
        weight_unit: str,  # Unit of the weight (e.g., "kg")
        height_value: float,  # Numeric part of the height (e.g., 163)
        height_unit: str,  # Unit of the height (e.g., "cm")
        sex: str,  # Gender ("male"/"female")
        age: int,  # Age
    ) -> str:
        r"""Calculate the patient's Adjusted Body Weight (ABW) and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of the
                following:
                - "lbs" for pounds.
                - "g" for grams.
                - "kg" for kilograms.
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of the
                following:
                - "cm" for centimeters.
                - "in" for inches.
            sex (str): The patient's gender, one of the following:
                - "Male" for male.
                - "Female" for female.
            age (int): The patient's age (integer). Currently unused but may
                be used for future extensions.

        Returns:
            str: A JSON string containing the calculation process and result,
                ormatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Adjusted body weight in kilograms (string
                        format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `abw_explanation` function is used to calculate the adjusted
                body weight.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
            - If the input gender is not "male" or "female", the function will
                not calculate IBW and ABW.
        """
        # Construct the input variables dictionary
        input_variables = {
            "weight": (
                float(weight_value),
                str(weight_unit),
            ),  # Weight: (value, unit)
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
            "sex": str(sex),  # Gender
            "age": int(age),  # Age
        }

        from medcalc.adjusted_body_weight import (
            abw_explanation,
        )

        try:
            # Call the ABW calculation function
            result = abw_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("abw_explanation", e)

    def anion_gap(
        self,
        sodium_value: float,  # Numeric part of the sodium level (e.g., 140.0)
        sodium_unit: str,  # Unit of the sodium level (e.g., "mEq/L")
        # Numeric part of the chloride level (e.g., 106.0)
        chloride_value: float,
        chloride_unit: str,  # Unit of the chloride level (e.g., "mEq/L")
        # Numeric part of the bicarbonate level (e.g., 20.0)
        bicarbonate_value: float,
        bicarbonate_unit: str,  # Unit of the bicarbonate level (e.g., "mEq/L")
    ) -> str:
        r"""Calculate the patient's Anion Gap and generate a detailed
        explanatory text.

        Args:
            sodium_value (float): The numeric value of the patient's sodium
                level.
            sodium_unit (str): The unit of the patient's sodium level, one of
                the following:
                - "mmol/L" for millimoles per liter.
                - "mEq/L" for milliequivalents per liter.
            chloride_value (float): The numeric value of the patient's
                chloride level.
            chloride_unit (str): The unit of the patient's chloride level, one
                of the following:
                - "mmol/L" for millimoles per liter.
                - "mEq/L" for milliequivalents per liter.
            bicarbonate_value (float): The numeric value of the patient's
                bicarbonate level.
            bicarbonate_unit (str): The unit of the patient's bicarbonate
                level, one of the following:
                - "mmol/L" for millimoles per liter.
                - "mEq/L" for milliequivalents per liter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Anion gap in mEq/L (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_anion_gap_explanation` function is used to
                calculate the anion gap.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (
                float(sodium_value),
                str(sodium_unit),
            ),  # Sodium: (value, unit)
            "chloride": (
                float(chloride_value),
                str(chloride_unit),
            ),  # Chloride: (value, unit)
            "bicarbonate": (
                float(bicarbonate_value),
                str(bicarbonate_unit),
            ),  # Bicarbonate: (value, unit)
        }

        from medcalc.anion_gap import (
            compute_anion_gap_explanation,
        )

        try:
            # Call the Anion Gap calculation function
            result = compute_anion_gap_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_anion_gap_explanation", e)

    def bmi_calculator(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 150)
        weight_unit: str,  # Unit of the weight (e.g., "lbs")
        height_value: float,  # Numeric part of the height (e.g., 170)
        height_unit: str,  # Unit of the height (e.g., "cm")
    ) -> str:
        r"""Calculate the patient's Body Mass Index (BMI) and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of the
                following:
                - "lbs" for pounds.
                - "g" for grams.
                - "kg" for kilograms.
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of the
                following:
                - "cm" for centimeters.
                - "in" for inches.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "BMI value (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `bmi_calculator_explanation` function is used to calculate
                the BMI.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "weight": (
                float(weight_value),
                str(weight_unit),
            ),  # Weight: (value, unit)
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
        }

        from medcalc.bmi_calculator import (
            bmi_calculator_explanation,
        )

        try:
            # Call the BMI calculation function
            result = bmi_calculator_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("bmi_calculator_explanation", e)

    def bsa_calculator(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 58.0)
        weight_unit: str,  # Unit of the weight (e.g., "kg")
        height_value: float,  # Numeric part of the height (e.g., 179.0)
        height_unit: str,  # Unit of the height (e.g., "cm")
    ) -> str:
        r"""Calculate the patient's Body Surface Area (BSA) and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of the
                following:
                - "lbs" for pounds.
                - "g" for grams.
                - "kg" for kilograms.
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of the
                following:
                - "cm" for centimeters.
                - "in" for inches.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Body Surface Area in square meters
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `bsa_calculator_explaination` function is used to calculate
                the body surface area.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "weight": (
                float(weight_value),
                str(weight_unit),
            ),  # Weight: (value, unit)
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
        }

        from medcalc.bsa_calculator import (
            bsa_calculator_explaination,
        )

        try:
            # Call the BSA calculation function
            result = bsa_calculator_explaination(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("bsa_calculator_explaination", e)

    def calcium_correction(
        self,
        # Numeric part of the albumin concentration (e.g., 4.0)
        albumin_value: float,
        albumin_unit: str,  # Unit of the albumin concentration (e.g., "g/dL")
        # Numeric part of the calcium concentration (e.g., 40)
        calcium_value: float,
        calcium_unit: str,  # Unit of the calcium concentration (e.g., "mg/L")
    ) -> str:
        r"""Calculate the patient's corrected calcium
            concentration and generate a detailed explanatory text.

        Args:
            albumin_value (float): The numeric value of the patient's
                albumin concentration.
            albumin_unit (str): The unit of the patient's albumin
                concentration, one of the following:
                - "g/L" for grams per liter.
                - "mg/dL" for milligrams per deciliter.
                - "g/mL" for grams per milliliter.
            calcium_value (float): The numeric value of the patient's
                calcium concentration.
            calcium_unit (str): The unit of the patient's calcium
                concentration, one of the following:
                - "g/L" for grams per liter.
                - "mg/dL" for milligrams per deciliter.
                - "g/mL" for grams per milliliter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Corrected calcium concentration in mg/dL
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `calculate_corrected_calcium_explanation` function is used
                to calculate the corrected calcium concentration.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "albumin": (
                float(albumin_value),
                str(albumin_unit),
            ),  # Albumin: (value, unit)
            "calcium": (
                float(calcium_value),
                str(calcium_unit),
            ),  # Calcium: (value, unit)
        }

        from medcalc.calcium_correction import (
            calculate_corrected_calcium_explanation,
        )

        try:
            # Call the corrected calcium calculation function
            result = calculate_corrected_calcium_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "calculate_corrected_calcium_explanation", e
            )

    def feverpain(
        self,
        symptom_onset: Optional[
            bool
        ],  # Whether the patient has a symptom onset ≤3 days
        purulent_tonsils: Optional[bool],  # Presence of pus on the tonsils
        fever_24_hours: Optional[
            bool
        ],  # Whether the patient has had a fever in the past 24 hours
        severe_tonsil_inflammation: Optional[
            bool
        ],  # Presence of severe tonsil inflammation
        cough_coryza_absent: Optional[bool],  # Absence of cough or coryza
    ) -> str:
        r"""Calculate the patient's FeverPAIN score and generate a detailed
        explanatory text.

        Args:
            symptom_onset (Optional[bool]): Whether the patient has a symptom
                onset ≤3 days.
            purulent_tonsils (Optional[bool]): Presence of pus on the tonsils.
            fever_24_hours (Optional[bool]): Whether the patient has had a
                fever in the past 24 hours.
            severe_tonsil_inflammation (Optional[bool]): Presence of
                severe tonsil inflammation.
            cough_coryza_absent (Optional[bool]): Absence of cough or coryza.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "FeverPAIN score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_fever_pain_explanation` function is used to
                calculate the FeverPAIN score.
            - The `json.dumps` function is used to serialize the
                result into a JSON string.
            - If any of the input parameters are not provided,
                the function assumes the condition is absent.
        """
        # Construct the input variables dictionary
        input_variables = {
            "symptom_onset": symptom_onset,
            "purulent_tonsils": purulent_tonsils,
            "fever_24_hours": fever_24_hours,
            "severe_tonsil_inflammation": severe_tonsil_inflammation,
            "cough_coryza_absent": cough_coryza_absent,
        }

        try:
            # Call the FeverPAIN score calculation function
            from medcalc.feverpain import (
                compute_fever_pain_explanation,
            )

            result = compute_fever_pain_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_fever_pain_explanation", e)

    def heart_score(
        self,
        age_value: float,  # Numeric part of the age (e.g., 60)
        age_unit: str,  # Unit of the age (e.g., "years")
        hypertension: bool,  # History of hypertension (True/False)
        history: str,  # History of chest pain: "Slightly suspicious",
        # "Moderately suspicious", or "Highly suspicious"
        diabetes_mellitus: bool,  # Diabetes status (True/False)
        smoking: bool,  # Smoking history (True/False)
        # Family history of cardiovascular disease (True/False)
        family_with_cvd: bool,
        # History of atherosclerotic disease (True/False)
        atherosclerotic_disease: bool,
        initial_troponin: str,  # Initial troponin level:
        # "less than or equal to normal limit",
        # "between the normal limit or up to three times the normal limit", or
        # "greater than three times normal limit"
        # Electrocardiogram status: "Normal", "Non-specific repolarization
        # disturbance", or "Significant ST deviation"
        electrocardiogram: str,
        hypercholesterolemia: bool,  # Hypercholesterolemia status (True/False)
        obesity: bool,  # Obesity status (BMI > 30 kg/m²) (True/False)
    ) -> str:
        r"""Calculate the patient's HEART Score and generate a detailed
        explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age,
                one of the following:
                - "years" for years.
                - "months" for months.
            hypertension (bool): The patient's history of hypertension
                (True/False).
            history (str): The patient's history of chest pain,
                one of the following:
                - "Slightly suspicious".
                - "Moderately suspicious".
                - "Highly suspicious".
            diabetes_mellitus (bool): The patient's diabetes status
                (True/False).
            smoking (bool): The patient's smoking history (True/False).
            family_with_cvd (bool): The patient's family history of
                cardiovascular disease (True/False).
            atherosclerotic_disease (bool): The patient's history of
                atherosclerotic disease (True/False).
            initial_troponin (str): The patient's initial troponin level,
                one of the following:
                - "less than or equal to normal limit".
                - "between the normal limit or up to three times
                    the normal limit".
                - "greater than three times normal limit".
            electrocardiogram (str): The patient's electrocardiogram status,
                one of the following:
                - "Normal".
                - "Non-specific repolarization disturbance".
                - "Significant ST deviation".
            hypercholesterolemia (bool): The patient's hypercholesterolemia
                status (True/False).
            obesity (bool): The patient's obesity status (BMI > 30 kg/m²)
                (True/False).

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "HEART Score (integer)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_heart_score_explanation` function is used to
                calculate the HEART Score.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "age": [float(age_value), str(age_unit)],  # Age: [value, unit]
            "hypertension": bool(hypertension),  # Hypertension status
            "history": str(history),  # History of chest pain
            "diabetes_mellitus": bool(diabetes_mellitus),  # Diabetes status
            "smoking": bool(smoking),  # Smoking history
            "family_with_cvd": bool(
                family_with_cvd
            ),  # Family history of cardiovascular disease
            "atherosclerotic_disease": bool(
                atherosclerotic_disease
            ),  # Atherosclerotic disease status
            # Initial troponin level
            "initial_troponin": str(initial_troponin),
            # Electrocardiogram status
            "electrocardiogram": str(electrocardiogram),
            "hypercholesterolemia": bool(
                hypercholesterolemia
            ),  # Hypercholesterolemia status
            "obesity": bool(obesity),  # Obesity status
            "risk_factors": {},  # Risk factors dictionary
        }

        try:
            # Call the HEART Score calculation function
            from medcalc.heart_score import (
                compute_heart_score_explanation,
            )

            result = compute_heart_score_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    # Final answer (HEART Score)
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_heart_score_explanation", e)

    def homa_ir(
        self,
        # Numeric part of the insulin level (e.g., 756.0)
        insulin_value: float,
        insulin_unit: str,  # Unit of the insulin level (e.g., "pmol/L")
        glucose_value: float,  # Numeric part of the glucose level (e.g., 97.3)
        glucose_unit: str,  # Unit of the glucose level (e.g., "mg/dL")
    ) -> str:
        r"""Calculate the patient's Homeostatic Model Assessment for Insulin
        Resistance (HOMA-IR) and generate a detailed explanatory text.

        Args:
            insulin_value (float): The numeric value of the patient's
                insulin level.
            insulin_unit (str): The unit of the patient's insulin level,
                one of the following:
                - "µIU/mL" for micro-international units per milliliter.
                - "pmol/L" for picomoles per liter.
                - "ng/mL" for nanograms per milliliter.
            glucose_value (float): The numeric value of the patient's
                glucose level.
            glucose_unit (str): The unit of the patient's glucose level, one
                of the following:
                - "mmol/L" for millimoles per liter.
                - "mg/dL" for milligrams per deciliter.
                - "mEq/L" for milliequivalents per liter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "HOMA-IR score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_homa_ir_explanation` function is used to calculate
                the HOMA-IR score.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
            - If the input units are not supported, the function will not
                calculate HOMA-IR.
        """
        # Construct the input variables dictionary
        input_variables = {
            "insulin": (
                float(insulin_value),
                str(insulin_unit),
            ),  # Insulin: (value, unit)
            "glucose": (
                float(glucose_value),
                str(glucose_unit),
            ),  # Glucose: (value, unit)
        }

        try:
            # Call the HOMA-IR calculation function
            from medcalc.homa_ir import (
                compute_homa_ir_explanation,
            )

            result = compute_homa_ir_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_homa_ir_explanation", e)

    def ideal_body_weight(
        self,
        height_value: float,  # Numeric part of the height (e.g., 170)
        height_unit: str,  # Unit of the height (e.g., "cm")
        sex: str,  # Gender ("male"/"female")
        # Age (currently unused but may be used for future extensions)
        age: int,
    ) -> str:
        r"""Calculate the patient's Ideal Body Weight (IBW) and generate a
        detailed explanatory text.

        Args:
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of
                the following:
                - "cm" for centimeters.
                - "in" for inches.
            sex (str): The patient's gender, one of the following:
                - "Male" for male.
                - "Female" for female.
            age (int): The patient's age (integer). Currently unused but may
                be used for future extensions.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Ideal body weight in kilograms
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `ibw_explanation` function is used to calculate
                the ideal body weight.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
            - If the input gender is not "male" or "female", the function
                will not calculate IBW.
        """
        # Construct the input variables dictionary
        input_variables = {
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
            "sex": str(sex),  # Gender
            "age": int(age),  # Age
        }

        from medcalc.ideal_body_weight import (
            ibw_explanation,
        )

        try:
            # Call the IBW calculation function
            result = ibw_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("ibw_explanation", e)

    def mean_arterial_pressure(
        self,
        # Numeric part of the systolic blood pressure (e.g., 120.0)
        sys_bp_value: float,
        # Unit of the systolic blood pressure (e.g., "mm hg")
        sys_bp_unit: str,
        # Numeric part of the diastolic blood pressure (e.g., 80.0)
        dia_bp_value: float,
        # Unit of the diastolic blood pressure (e.g., "mm hg")
        dia_bp_unit: str,
    ) -> str:
        r"""Calculate the patient's Mean Arterial Pressure (MAP) and generate a
        detailed explanatory text.

        Args:
            sys_bp_value (float): The numeric value of the patient's systolic
                blood pressure.
            sys_bp_unit (str): The unit of the patient's systolic blood
                pressure, one of the following:
                - "mm hg" for millimeters of mercury.
            dia_bp_value (float): The numeric value of the patient's
                diastolic blood pressure.
            dia_bp_unit (str): The unit of the patient's diastolic blood
                pressure, one of the following:
                - "mm hg" for millimeters of mercury.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Mean arterial pressure in millimeters of
                        mercury (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `mean_arterial_pressure_explanation` function is used to
                calculate the mean arterial pressure.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
            - If the input units are not "mm hg", the function will not
                calculate MAP.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sys_bp": (
                float(sys_bp_value),
                str(sys_bp_unit),
            ),  # Systolic Blood Pressure: (value, unit)
            "dia_bp": (
                float(dia_bp_value),
                str(dia_bp_unit),
            ),  # Diastolic Blood Pressure: (value, unit)
        }

        from medcalc.mean_arterial_pressure import (
            mean_arterial_pressure_explanation,
        )

        try:
            # Call the MAP calculation function
            result = mean_arterial_pressure_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "mean_arterial_pressure_explanation", e
            )

    def sOsm(
        self,
        # Numeric part of the blood urea nitrogen level (e.g., 20.0)
        bun_value: float,
        bun_unit: str,  # Unit of the blood urea nitrogen level (e.g., "mg/dL")
        # Numeric part of the blood glucose level (e.g., 599.0)
        glucose_value: float,
        glucose_unit: str,  # Unit of the blood glucose level (e.g., "mg/dL")
        sodium_value: float,  # Numeric part of the sodium level (e.g., 139.0)
        sodium_unit: str,  # Unit of the sodium level (e.g., "mEq/L")
    ) -> str:
        r"""Calculate the patient's Serum Osmolality and generate a detailed
        explanatory text.

        Args:
            bun_value (float): The numeric value of the patient's blood urea
                nitrogen level.
            bun_unit (str): The unit of the patient's blood urea nitrogen
                level, one of the following:
                - "mg/dL" for milligrams per deciliter.
                - "mmol/L" for millimoles per liter.
            glucose_value (float): The numeric value of the patient's
                blood glucose level.
            glucose_unit (str): The unit of the patient's blood glucose level,
                one of the following:
                - "mg/dL" for milligrams per deciliter.
                - "mmol/L" for millimoles per liter.
            sodium_value (float): The numeric value of the patient's
                sodium level.
            sodium_unit (str): The unit of the patient's sodium level, one of
                the following:
                - "mEq/L" for milliequivalents per liter.
                - "mmol/L" for millimoles per liter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Serum osmolality in mmol/L
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_serum_osmolality_explanation` function is used to
                calculate the serum osmolality.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "bun": (float(bun_value), str(bun_unit)),  # BUN: (value, unit)
            "glucose": (
                float(glucose_value),
                str(glucose_unit),
            ),  # Glucose: (value, unit)
            "sodium": (
                float(sodium_value),
                str(sodium_unit),
            ),  # Sodium: (value, unit)
        }

        try:
            from medcalc.sOsm import (
                compute_serum_osmolality_explanation,
            )

            # Call the serum osmolality calculation function
            result = compute_serum_osmolality_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_serum_osmolality_explanation", e
            )

    def delta_gap(
        self,
        sodium_value: float,  # Numeric part of the sodium level (e.g., 135.0)
        sodium_unit: str,  # Unit of the sodium level (e.g., "mEq/L")
        # Numeric part of the chloride level (e.g., 100.0)
        chloride_value: float,
        chloride_unit: str,  # Unit of the chloride level (e.g., "mEq/L")
        # Numeric part of the bicarbonate level (e.g., 19.0)
        bicarbonate_value: float,
        bicarbonate_unit: str,  # Unit of the bicarbonate level (e.g., "mEq/L")
    ) -> str:
        r"""Calculate the patient's Delta Gap and generate a detailed
        explanatory text.

        Args:
            sodium_value (float): The numeric value of the
                patient's sodium level.
            sodium_unit (str): The unit of the patient's sodium level,
                one of the following:
                - "mEq/L" for milliequivalents per liter.
                - "mmol/L" for millimoles per liter.
            chloride_value (float): The numeric value of the patient's
                chloride level.
            chloride_unit (str): The unit of the patient's chloride level,
                one of the following:
                - "mEq/L" for milliequivalents per liter.
                - "mmol/L" for millimoles per liter.
            bicarbonate_value (float): The numeric value of the patient's
                bicarbonate level.
            bicarbonate_unit (str): The unit of the patient's bicarbonate
                level, one of the following:
                - "mEq/L" for milliequivalents per liter.
                - "mmol/L" for millimoles per liter.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Delta gap in mEq/L (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_delta_gap_explanation` function is used to
                calculate the delta gap.
            - The `json.dumps` function is used to serialize the
                result into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (
                float(sodium_value),
                str(sodium_unit),
            ),  # Sodium: (value, unit)
            "chloride": (
                float(chloride_value),
                str(chloride_unit),
            ),  # Chloride: (value, unit)
            "bicarbonate": (
                float(bicarbonate_value),
                str(bicarbonate_unit),
            ),  # Bicarbonate: (value, unit)
        }

        from medcalc.delta_gap import (
            compute_delta_gap_explanation,
        )

        try:
            # Call the Delta Gap calculation function
            result = compute_delta_gap_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_delta_gap_explanation", e)

    def conception_date(
        self,
        # Length of the patient's menstrual cycle (e.g., 28)
        cycle_length: int,
        # Date of the patient's last menstrual period (e.g., "01/21/2004")
        menstrual_date: str,
    ) -> str:
        r"""Calculate the patient's estimated conception date and generate a
        detailed explanatory text.

        Args:
            cycle_length (int): The length of the patient's menstrual
                cycle in days.
            menstrual_date (str): The date of the patient's last menstrual
                period in the format "%m/%d/%Y".

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Estimated conception date in the format
                        '%m/%d/%Y' (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `add_2_weeks_explanation` function is used to calculate the
                estimated conception date.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "cycle_length": int(cycle_length),  # Cycle length in days
            "menstrual_date": str(
                menstrual_date
            ),  # Last menstrual date in the format "%m/%d/%Y"
        }

        try:
            from medcalc.conception_date import (
                add_2_weeks_explanation,
            )

            # Call the conception date calculation function
            result = add_2_weeks_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("add_2_weeks_explanation", e)

    def gestational_age(
        self,
        # Current date in the format "%m/%d/%Y" (e.g., "04/29/2022")
        current_date: str,
        # Patient's last menstrual date in the format "%m/%d/%Y" (e.g.,
        # "01/06/2022")
        menstrual_date: str,
    ) -> str:
        r"""Calculate the patient's gestational age and generate a detailed
        explanatory text.

        Args:
            current_date (str): The current date in the format "%m/%d/%Y".
            menstrual_date (str): The patient's last menstrual date in
                the format "%m/%d/%Y".

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Gestational age in weeks and days
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_gestational_age_explanation` function is used to
                calculate the gestational age.
            - The `json.dumps` function is used to serialize the result into
                a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "current_date": str(current_date),  # Current date
            "menstrual_date": str(menstrual_date),  # Last menstrual date
        }

        try:
            from medcalc.gestational_age import (
                compute_gestational_age_explanation,
            )

            # Call the gestational age calculation function
            result = compute_gestational_age_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": (
                        f"{result['Answer'][0]} and " f"{result['Answer'][1]}"
                    ),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_gestational_age_explanation", e
            )

    def mdrd_gfr(
        self,
        age_value: float,  # Numeric part of the age (e.g., 49)
        age_unit: str,  # Unit of the age (e.g., "years")
        # Numeric part of the creatinine level (e.g., 10.6)
        creatinine_value: float,
        creatinine_unit: str,  # Unit of the creatinine level (e.g., "mg/dL")
        sex: str,  # Gender ("male"/"female")
        race: Optional[str] = None,  # Race (optional, e.g., "Black")
    ) -> str:
        r"""Calculate the patient's Glomerular Filtration Rate (GFR) using the
        MDRD equation and generate a detailed explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of
                the following:
                - "years" for years.
            creatinine_value (float): The numeric value of the patient's blood
                creatinine level.
            creatinine_unit (str): The unit of the patient's blood creatinine
                level, one of the following:
                - "mg/dL" for milligrams per deciliter.
                - "µmol/L" for micromoles per liter.
            sex (str): The patient's gender, one of the following:
                - "Male" for male.
                - "Female" for female.
            race (str, optional): The patient's race, one of the following:
                - "Black" for Black.
                - Other races or unspecified will default to a coefficient
                    of 1.0.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Glomerular Filtration Rate (GFR) in
                        mL/min/1.73m² (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `mrdr_gfr_explanation` function is used to calculate the GFR.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
            - If the input gender is not "male" or "female", the function
                will not calculate GFR.
        """
        # Construct the input variables dictionary
        input_variables = {
            "age": (float(age_value), str(age_unit)),  # Age: (value, unit)
            "creatinine": (
                float(creatinine_value),
                str(creatinine_unit),
            ),  # Creatinine: (value, unit)
            "sex": str(sex),  # Gender
            "race": str(race) if race else None,  # Race (optional)
        }

        from medcalc.mdrd_gfr import mrdr_gfr_explanation

        try:
            # Call the GFR calculation function
            result = mrdr_gfr_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("mrdr_gfr_explanation", e)

    def target_weight(
        self,
        bmi_value: float,  # Numeric part of the BMI (e.g., 20.1)
        bmi_unit: str,  # Unit of the BMI (e.g., "kg/m^2")
        height_value: float,  # Numeric part of the height (e.g., 72)
        height_unit: str,  # Unit of the height (e.g., "in")
    ) -> str:
        r"""Calculate the patient's Target Weight (TW) and generate a detailed
        explanatory text.

        Args:
            bmi_value (float): The numeric value of the patient's BMI.
            bmi_unit (str): The unit of the patient's BMI, one of
                the following:
                - "kg/m^2" for kilograms per square meter.
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of
                the following:
                - "cm" for centimeters.
                - "in" for inches.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Target weight in kilograms
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `targetweight_explanation` function is used to calculate
                the target weight.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "body_mass_index": (
                float(bmi_value),
                str(bmi_unit),
            ),  # BMI: (value, unit)
            "height": (
                float(height_value),
                str(height_unit),
            ),  # Height: (value, unit)
        }

        from medcalc.target_weight import (
            targetweight_explanation,
        )

        try:
            # Call the Target Weight calculation function
            result = targetweight_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("targetweight_explanation", e)

    def creatinine_clearance(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 55.0)
        weight_unit: str,  # Unit of the weight ("lbs", "g", or "kg")
        height_value: float,  # Numeric part of the height (e.g., 162.8)
        height_unit: str,  # Unit of the height ("cm" or "in")
        sex: str,  # Gender ("Male" or "Female")
        creatinine_value: float,  # Numeric part of creatinine (e.g., 0.57)
        creatinine_unit: str,  # Unit of creatinine (e.g., "mg/dL")
        age_value: float,  # Numeric part of age (e.g., 16)
        age_unit: str,  # Unit of age ("years" or "months")
    ) -> str:
        r"""Calculate the patient's Creatinine Clearance using Cockcroft-Gault
        formula and generate a detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of:
                - "lbs" for pounds
                - "g" for grams
                - "kg" for kilograms
            height_value (float): The numeric value of the patient's height.
            height_unit (str): The unit of the patient's height, one of:
                - "cm" for centimeters
                - "in" for inches
            sex (str): The patient's gender, one of:
                - "Male" for male
                - "Female" for female
            creatinine_value (float): The numeric value of serum creatinine.
            creatinine_unit (str): The unit of serum creatinine
                (e.g., "mg/dL").
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of:
                - "years"
                - "months"

        Returns:
            str: A JSON string containing the calculation process
                and result, formatted as:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Creatinine clearance in mL/min
                        (string format)"
                }
                If an exception occurs, return an error message generated
                    by the `handle_exception` method.

        Notes:
            - The `generate_cockcroft_gault_explanation` function
                is used for calculation.
            - The `json.dumps` function is used to serialize the
                result into a JSON string.
            - If the input gender is not "Male" or "Female", the
                function will not calculate.
        """
        # Construct the input variables dictionary
        input_variables = {
            "weight": (float(weight_value), str(weight_unit)),
            "height": (float(height_value), str(height_unit)),
            "sex": str(sex),
            "creatinine": (float(creatinine_value), str(creatinine_unit)),
            "age": (float(age_value), str(age_unit)),
        }

        try:
            from medcalc.creatinine_clearance import (
                generate_cockcroft_gault_explanation,
            )

            # Call the Cockcroft-Gault calculation function
            result = generate_cockcroft_gault_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "generate_cockcroft_gault_explanation", e
            )

    def wells_criteria_pe(
        self,
        clinical_dvt: bool,
        previous_pe: bool,
        previous_dvt: bool,
        heart_rate_value: float,
        heart_rate_unit: str,
        immobilization_for_3days: bool,
        hemoptysis: bool,
        surgery_in_past4weeks: bool,
        malignancy_with_treatment: bool,
        pe_number_one: bool,
    ) -> str:
        r"""
        Calculate the patient's Wells' Criteria for Pulmonary Embolism score
            and generate a detailed explanatory text.

        Parameters:
            clinical_dvt (bool): Clinical signs and symptoms of DVT.
            previous_pe (bool): Previous, objectively diagnosed PE.
            previous_dvt (bool): Previous, objectively diagnosed DVT.
            heart_rate_value (float): The numeric value of the
                patient's heart rate.
            heart_rate_unit (str): The unit of heart rate ("beats per minute").
            immobilization_for_3days (bool): Immobilization ≥3 days
                or surgery in previous 4 weeks.
            hemoptysis (bool): Presence of hemoptysis.
            surgery_in_past4weeks (bool): Surgery in past 4 weeks.
            malignancy_with_treatment (bool): Malignancy with treatment
                within 6 months or palliative.
            pe_number_one (bool): PE is #1 diagnosis or equally likely.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Wells' score for pulmonary embolism
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `calculate_pe_wells_explanation` function is used to
                calculate the Wells' score.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "clinical_dvt": bool(clinical_dvt),
            "previous_pe": bool(previous_pe),
            "previous_dvt": bool(previous_dvt),
            "heart_rate": (float(heart_rate_value), str(heart_rate_unit)),
            "immobilization_for_3days": bool(immobilization_for_3days),
            "hemoptysis": bool(hemoptysis),
            "surgery_in_past4weeks": bool(surgery_in_past4weeks),
            "malignancy_with_treatment": bool(malignancy_with_treatment),
            "pe_number_one": bool(pe_number_one),
        }
        try:
            from medcalc.wells_criteria_pe import (
                calculate_pe_wells_explanation,
            )

            # Call the Wells' score calculation function
            result = calculate_pe_wells_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result['Explanation'],
                    "final_answer": str(result['Answer']),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("calculate_pe_wells_explanation", e)

    def ldl_calculated(
        self,
        hdl_value: float,  # Numeric part of HDL cholesterol (e.g., 37.0)
        hdl_unit: str,  # Unit of HDL cholesterol (e.g., "mg/dL")
        triglycerides_value: float,  # Numeric part of triglycerides
        # (e.g., 205.0)
        triglycerides_unit: str,  # Unit of triglycerides (e.g., "mg/dL")
        total_value: float,  # Numeric part of total cholesterol (e.g., 210.0)
        total_unit: str,  # Unit of total cholesterol (e.g., "mg/dL")
    ) -> str:
        """
        Calculate the patient's LDL cholesterol concentration and generate
            a detailed explanatory text.

        Parameters:
            hdl_value (float): The numeric value of the patient's
                HDL cholesterol.
            hdl_unit (str): The unit of the patient's HDL cholesterol, one
                of the following:
                - "mg/dL" for milligrams per deciliter
                - "mmol/L" for millimoles per liter
                - Other supported cholesterol concentration units
            triglycerides_value (float): The numeric value of
                the patient's triglycerides.
            triglycerides_unit (str): The unit of the patient's triglycerides,
                one of the following:
                - "mg/dL" for milligrams per deciliter
                - "mmol/L" for millimoles per liter
                - Other supported triglyceride concentration units
            total_value (float): The numeric value of the patient's
                total cholesterol.
            total_unit (str): The unit of the patient's total cholesterol,
                one of the following:
                - "mg/dL" for milligrams per deciliter
                - "mmol/L" for millimoles per liter
                - Other supported cholesterol concentration units

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "LDL cholesterol concentration in mg/dL
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `compute_ldl_explanation` function is used to calculate
                the LDL cholesterol.
            - The `json.dumps` function is used to serialize the result
                into a JSON string.
            - The calculation uses the formula: LDL = total cholesterol - HDL
                - (triglycerides / 5)
            - All values are converted to mg/dL for the calculation.
        """
        # Construct the input variables dictionary
        input_variables = {
            "hdl_cholestrol": (float(hdl_value), str(hdl_unit)),
            "triglycerides": (
                float(triglycerides_value),
                str(triglycerides_unit),
            ),
            "total_cholestrol": (float(total_value), str(total_unit)),
        }

        from medcalc.ldl_calculated import (
            compute_ldl_explanation,
        )

        try:
            # Call the LDL calculation function
            result = compute_ldl_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result['Explanation'],  # Detailed explanation
                    "final_answer": str(
                        result['Answer']
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_ldl_explanation", e)

    def albumin_corrected_anion(
        self,
        sodium_value: float,  # Numeric part of sodium level (e.g., 134.0)
        sodium_unit: str,  # Unit of sodium level (e.g., "mmol/L")
        chloride_value: float,  # Numeric part of chloride level (e.g., 100.0)
        chloride_unit: str,  # Unit of chloride level (e.g., "mmol/L")
        bicarbonate_value: float,  # Numeric part of bicarbonate (e.g., 19.0)
        bicarbonate_unit: str,  # Unit of bicarbonate (e.g., "mmol/L")
        albumin_value: float,  # Numeric part of albumin (e.g., 4.4)
        albumin_unit: str,  # Unit of albumin (e.g., "g/dL")
    ) -> str:
        r"""Calculate the patient's Albumin Corrected Anion Gap (ACAG)
        and generate a detailed explanatory text.

        Args:
            sodium_value (float): The numeric value of sodium level.
            sodium_unit (str): The unit of sodium level, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
            chloride_value (float): The numeric value of chloride level.
            chloride_unit (str): The unit of chloride level, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
            bicarbonate_value (float): The numeric value of bicarbonate level.
            bicarbonate_unit (str): The unit of bicarbonate level, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
            albumin_value (float): The numeric value of albumin concentration.
            albumin_unit (str): The unit of albumin concentration, one of:
                - "g/dL" for grams per deciliter
                - "g/L" for grams per liter
                - "mg/dL" for milligrams per deciliter

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process
                        and explanatory text",
                    "final_answer": "Albumin corrected anion gap
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_albumin_corrected_anion_explanation`
                function is used for calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "chloride": (float(chloride_value), str(chloride_unit)),
            "bicarbonate": (float(bicarbonate_value), str(bicarbonate_unit)),
            "albumin": (float(albumin_value), str(albumin_unit)),
        }

        from medcalc.albumin_corrected_anion import (
            compute_albumin_corrected_anion_explanation,
        )

        try:
            # Call the ACAG calculation function
            result = compute_albumin_corrected_anion_explanation(
                input_variables
            )

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(result["Answer"]),  # Final answer
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_albumin_corrected_anion_explanation", e
            )

    def albumin_corrected_delta_gap(
        self,
        sodium_value: float,  # Numeric part of sodium level (e.g., 141.0)
        sodium_unit: str,  # Unit of sodium level (e.g., "mEq/L")
        chloride_value: float,  # Numeric part of chloride level (e.g., 104.0)
        chloride_unit: str,  # Unit of chloride level (e.g., "mEq/L")
        bicarbonate_value: float,  # Numeric part of bicarbonate (e.g., 29.0)
        bicarbonate_unit: str,  # Unit of bicarbonate level (e.g., "mEq/L")
        albumin_value: float,  # Numeric part of albumin (e.g., 43.0)
        albumin_unit: str,  # Unit of albumin level (e.g., "g/L")
    ) -> str:
        r"""Calculate the patient's Albumin Corrected Delta Gap and generate a
        detailed explanatory text.

        Args:
            sodium_value (float): The numeric value of sodium level.
            sodium_unit (str): The unit of sodium level, one of:
                - "mEq/L" for milliequivalents per liter
                - "mmol/L" for millimoles per liter
            chloride_value (float): The numeric value of chloride level.
            chloride_unit (str): The unit of chloride level, one of:
                - "mEq/L" for milliequivalents per liter
                - "mmol/L" for millimoles per liter
            bicarbonate_value (float): The numeric value of bicarbonate level.
            bicarbonate_unit (str): The unit of bicarbonate level, one of:
                - "mEq/L" for milliequivalents per liter
                - "mmol/L" for millimoles per liter
            albumin_value (float): The numeric value of albumin level.
            albumin_unit (str): The unit of albumin level, one of:
                - "g/L" for grams per liter
                - "g/dL" for grams per deciliter
                - "mg/dL" for milligrams per deciliter

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Albumin corrected delta gap
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_albumin_corrected_delta_gap_explanation` function is
                used for calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "chloride": (float(chloride_value), str(chloride_unit)),
            "bicarbonate": (float(bicarbonate_value), str(bicarbonate_unit)),
            "albumin": (float(albumin_value), str(albumin_unit)),
        }

        from medcalc.albumin_corrected_delta_gap import (
            compute_albumin_corrected_delta_gap_explanation,
        )

        try:
            # Call the calculation function
            result = compute_albumin_corrected_delta_gap_explanation(
                input_variables
            )

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(  # Final answer (string format)
                        result["Answer"]
                    ),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_albumin_corrected_delta_gap_explanation", e
            )

    def albumin_delta_ratio(
        self,
        sodium_value: float,  # Numeric part of sodium level (e.g., 140.0)
        sodium_unit: str,  # Unit of sodium level (e.g., "mEq/L")
        chloride_value: float,  # Numeric part of chloride level (e.g., 105.0)
        chloride_unit: str,  # Unit of chloride level (e.g., "mEq/L")
        bicarbonate_value: float,  # Numeric part of bicarbonate (e.g., 28.0)
        bicarbonate_unit: str,  # Unit of bicarbonate (e.g., "mEq/L")
        albumin_value: float,  # Numeric part of albumin (e.g., 3.9)
        albumin_unit: str,  # Unit of albumin (e.g., "g/dL")
    ) -> str:
        r"""Calculate the patient's albumin delta ratio and generate a detailed
        explanatory text.

        Args:
            sodium_value (float): The numeric value of sodium level.
            sodium_unit (str): The unit of sodium level, one of:
                - "mmol/L"
                - "mEq/L"
            chloride_value (float): The numeric value of chloride level.
            chloride_unit (str): The unit of chloride level, one of:
                - "mmol/L"
                - "mEq/L"
            bicarbonate_value (float): The numeric value of bicarbonate level.
            bicarbonate_unit (str): The unit of bicarbonate level, one of:
                - "mmol/L"
                - "mEq/L"
            albumin_value (float): The numeric value of albumin concentration.
            albumin_unit (str): The unit of albumin concentration, one of:
                - "g/dL"
                - "g/L"
                - "mg/dL"
                - "g/mL"

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Albumin delta ratio (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_albumin_delta_ratio_explanation` function
                is used for the calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "chloride": (float(chloride_value), str(chloride_unit)),
            "bicarbonate": (float(bicarbonate_value), str(bicarbonate_unit)),
            "albumin": (float(albumin_value), str(albumin_unit)),
        }

        from medcalc.albumin_delta_ratio import (
            compute_albumin_delta_ratio_explanation,
        )

        try:
            # Call the calculation function
            result = compute_albumin_delta_ratio_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(  # Final answer (string format)
                        result["Answer"]
                    ),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("albumin_delta_ratio", e)

    def estimated_due_date(
        self,
        cycle_length: int,  # Patient's menstrual cycle length in days
        menstrual_date: str,  # Last menstrual date in format "%m/%d/%Y"
    ) -> str:
        r"""Calculate the patient's estimated due date and generate a detailed
        explanatory text using Naegele's Rule.

        Args:
            cycle_length (int): The length of the patient's menstrual cycle in
                days (e.g., 28).
            menstrual_date (str): The patient's last menstrual date in the
                format "MM/DD/YYYY" (e.g., "09/17/2011").

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Estimated due date in MM/DD/YYYY format"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - Uses Naegele's Rule: adds 40 weeks to menstrual date and adjusts
                based on cycle length difference from 28 days.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "cycle_length": int(cycle_length),
            "menstrual_date": str(menstrual_date),
        }

        try:
            from medcalc.estimated_due_date import (
                add_40_weeks_explanation,
            )

            # Call the due date calculation function
            result = add_40_weeks_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(result["Answer"]),  # Final answer
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("estimated_due_date", e)

    def free_water_deficit(
        self,
        weight_value: float,  # Numeric part of weight (e.g., 33.0)
        weight_unit: str,  # Unit of weight ("lbs", "g", "kg")
        height_value: float,  # Numeric part of height (unused in calculation)
        height_unit: str,  # Unit of height (unused in calculation)
        sex: str,  # Gender ("male"/"female")
        age_value: float,  # Numeric part of age (e.g., 32)
        age_unit: str,  # Unit of age ("years"/"months")
        sodium_value: float,  # Numeric sodium level (e.g., 134.0)
        sodium_unit: str,  # Sodium unit ("mmol/L", "mEq/L")
    ) -> str:
        r"""Calculate the patient's Free Water Deficit (FWD) and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of:
                - "lbs" for pounds
                - "g" for grams
                - "kg" for kilograms
            height_value (float): The numeric value of height (unused).
            height_unit (str): The unit of height (unused).
            sex (str): The patient's gender, one of:
                - "Male" for male
                - "Female" for female
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of:
                - "months"
                - "years"
            sodium_value (float): The numeric value of sodium level.
            sodium_unit (str): The unit of sodium level, one of:
                - "mmol/L"
                - "mEq/L"

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process text",
                    "final_answer": "Free water deficit in liters (string)"
                }
                If an exception occurs, returns an error message generated by
                the `handle_exception` method.

        Notes:
            - The `free_water_deficit_explanation` function is
                used for calculation.
            - The `json.dumps` function serializes the result into JSON string.
            - If input gender is not "male" or "female", function
                won't calculate.
        """
        # Construct input variables dictionary
        input_variables = {
            "weight": (float(weight_value), str(weight_unit)),
            "height": (float(height_value), str(height_unit)),
            "sex": str(sex),
            "age": (float(age_value), str(age_unit)),
            "sodium": (float(sodium_value), str(sodium_unit)),
        }

        from medcalc.free_water_deficit import (
            free_water_deficit_explanation,
        )

        try:
            # Call the FWD calculation function
            result = free_water_deficit_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("free_water_deficit_explanation", e)

    def glasgow_coma_score(
        self,
        best_eye_response: str,  # Patient's best eye response
        best_verbal_response: str,  # Patient's best verbal response
        best_motor_response: str,  # Patient's best motor response
    ) -> str:
        r"""Calculate the patient's Glasgow Coma Score (GCS) and generate a
        detailed explanatory text.

        Args:
            best_eye_response (str): The patient's best eye response, one of:
                - "eyes open spontaneously"
                - "eye opening to verbal command"
                - "eye opening to pain"
                - "no eye opening"
                - "not testable"
            best_verbal_response (str): The patient's best verbal
                response, one of:
                - "oriented"
                - "confused"
                - "inappropriate words"
                - "incomprehensible sounds"
                - "no verbal response"
                - "not testable"
            best_motor_response (str): The patient's best motor response,
                one of:
                - "obeys commands"
                - "localizes pain"
                - "withdrawal from pain"
                - "flexion to pain"
                - "extension to pain"
                - "no motor response"

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Glasgow Coma Score (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `compute_glasgow_coma_score_explanation` function is used to
                calculate the score.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "best_eye_response": str(best_eye_response),
            "best_verbal_response": str(best_verbal_response),
            "best_motor_response": str(best_motor_response),
        }

        try:
            from medcalc.glasgow_coma_score import (
                compute_glasgow_coma_score_explanation,
            )

            # Call the GCS calculation function
            result = compute_glasgow_coma_score_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(  # Final answer (string format)
                        result["Answer"]
                    ),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_glasgow_coma_score", e)

    def qt_calculator_bazett(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 176)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_interval_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_interval_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate the patient's corrected QT interval using
            Bazett Formula and generate a detailed explanatory text.

        Args:
            heart_rate_value (float): The numeric value of heart rate.
            heart_rate_unit (str): The unit of heart rate, must be:
                - "beats per minute"
            qt_interval_value (float): The numeric value of QT interval.
            qt_interval_unit (str): The unit of QT interval, must be:
                - "msec" for milliseconds

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Corrected QT interval in
                        msec (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `bazett_calculator_explanation` function is
                used for calculation.
            - The `json.dumps` function serializes
                the result into a JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # Heart rate: (value, unit)
            "qt_interval": (
                float(qt_interval_value),
                str(qt_interval_unit),
            ),  # QT interval: (value, unit)
        }

        from medcalc.qt_calculator_bazett import (
            bazett_calculator_explanation,
        )

        try:
            # Call the Bazett calculation function
            result = bazett_calculator_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("bazett_calculator_explanation", e)

    def qt_calculator_framingham(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 81)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_interval_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_interval_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate patient's corrected QT interval using Framingham
        Formula and generate detailed explanatory text.

        Args:
            heart_rate_value (float): Numeric value of patient's heart rate.
            heart_rate_unit (str): Unit of heart rate, must be:
                - "beats per minute"
            qt_interval_value (float): Numeric value of QT interval.
            qt_interval_unit (str): Unit of QT interval, must be:
                - "msec" for milliseconds.

        Returns:
            str: JSON string containing calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process text",
                    "final_answer": "Corrected QT interval (string format)"
                }
                If exception occurs, returns error message
                    from handle_exception.

        Notes:
            - Uses framingham_calculator_explanation for calculation.
            - Uses json.dumps to serialize result into JSON string.
        """
        # Construct input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # Heart rate: (value, unit)
            "qt_interval": (
                float(qt_interval_value),
                str(qt_interval_unit),
            ),  # QT interval: (value, unit)
        }

        from medcalc.qt_calculator_framingham import (
            framingham_calculator_explanation,
        )

        try:
            # Call the Framingham calculation function
            result = framingham_calculator_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("qt_calculator_framingham", e)

    def qt_calculator_fredericia(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 70)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate the patient's corrected QT interval using
        Fridericia Formula and generate a detailed explanatory text.

        Args:
            heart_rate_value (float): The numeric value of heart rate.
            heart_rate_unit (str): The unit of heart rate, should be:
                - "beats per minute"
            qt_value (float): The numeric value of QT interval.
            qt_unit (str): The unit of QT interval, should be:
                - "msec" for milliseconds.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Corrected QT interval
                        in msec (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `fredericia_calculator_explanation` function is used for the
                calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # Heart rate: (value, unit)
            "qt_interval": (
                float(qt_value),
                str(qt_unit),
            ),  # QT interval: (value, unit)
        }

        from medcalc.qt_calculator_fredericia import (
            fredericia_calculator_explanation,
        )

        try:
            # Call the QT correction calculation function
            result = fredericia_calculator_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("qt_calculator_fredericia", e)

    def qt_calculator_hodges(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 52)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_interval_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_interval_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate the patient's corrected QT interval (QTc) using
        Hodges formula and generate a detailed explanatory text.

        Args:
            heart_rate_value (float): The numeric value of patient's
                heart rate.
            heart_rate_unit (str): The unit of heart rate, must be:
                - "beats per minute"
            qt_interval_value (float): The numeric value of QT interval.
            qt_interval_unit (str): The unit of QT interval, must be:
                - "msec" for milliseconds.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Corrected QT interval in msec
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `hodges_calculator_explanation` function is used
                to calculate the corrected QT interval.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # Heart rate: (value, unit)
            "qt_interval": (
                float(qt_interval_value),
                str(qt_interval_unit),
            ),  # QT interval: (value, unit)
        }

        from medcalc.qt_calculator_hodges import (
            hodges_calculator_explanation,
        )

        try:
            # Call the QTc calculation function
            result = hodges_calculator_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("hodges_calculator_explanation", e)

    def qt_calculator_rautaharju(
        self,
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 110)
        heart_rate_unit: str,  # Unit of heart rate ("beats per minute")
        qt_interval_value: float,  # Numeric part of QT interval (e.g., 330)
        qt_interval_unit: str,  # Unit of QT interval ("msec")
    ) -> str:
        r"""Calculate patient's corrected QT interval
            using Rautaharju formula and generate detailed explanatory text.

        Args:
            heart_rate_value (float): Numeric value of patient's heart rate.
            heart_rate_unit (str): Unit of heart rate, must be:
                - "beats per minute"
            qt_interval_value (float): Numeric value of QT interval.
            qt_interval_unit (str): Unit of QT interval, must be:
                - "msec"

        Returns:
            str: JSON string containing calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Corrected QT interval in msec (string)"
                }
                If exception occurs, returns error message
                    from handle_exception.

        Notes:
            - Uses Rautaharju formula: QTc = QT * (120 + HR) / 180
            - The `json.dumps` function serializes result into JSON string.
            - Units must match expected values or calculation will fail.
        """
        # Construct input variables dictionary
        input_variables = {
            "heart_rate": (
                float(heart_rate_value),
                str(heart_rate_unit),
            ),  # (value, unit)
            "qt_interval": (
                float(qt_interval_value),
                str(qt_interval_unit),
            ),  # (value, unit)
        }

        from medcalc.qt_calculator_rautaharju import (
            rautaharju_calculator_explanation,
        )

        try:
            # Call QT calculation function
            result = rautaharju_calculator_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception(
                "rautaharju_calculator_explanation", e
            )

    def steroid_conversion(
        self,
        input_steroid: str,  # Input steroid with route
        # (e.g., "Hydrocortisone PO")
        input_value: float,  # Numeric value of input steroid (e.g., 190.936)
        input_unit: str,  # Unit of input steroid (e.g., "mg")
        target_steroid: str,  # Target steroid with route
        # (e.g., "MethylPrednisoLONE IV")
    ) -> str:
        r"""Calculate equivalent dosage of target steroid and
        generate explanatory text.

        Args:
            input_steroid (str): Input steroid name with route, one of:
                - "Betamethasone IV"
                - "Cortisone PO"
                - "Dexamethasone IV"
                - "Dexamethasone PO"
                - "Hydrocortisone IV"
                - "Hydrocortisone PO"
                - "MethylPrednisoLONE IV"
                - "MethylPrednisoLONE PO"
                - "PrednisoLONE PO"
                - "PredniSONE PO"
                - "Triamcinolone IV"
            input_value (float): Numeric value of input steroid dose.
            input_unit (str): Unit of input steroid dose (e.g., "mg").
            target_steroid (str): Target steroid name with route, one of:
                - "Betamethasone IV"
                - "Cortisone PO"
                - "Dexamethasone IV"
                - "Dexamethasone PO"
                - "Hydrocortisone IV"
                - "Hydrocortisone PO"
                - "MethylPrednisoLONE IV"
                - "MethylPrednisoLONE PO"
                - "PrednisoLONE PO"
                - "PredniSONE PO"
                - "Triamcinolone IV"

        Returns:
            str: A JSON string containing calculation process and result,
                formatted:
                {
                    "rationale": "Detailed calculation process
                        and explanation",
                    "final_answer": "Equivalent dosage in mg (string format)"
                }
                If an exception occurs, returns error message from
                `handle_exception` method.

        Notes:
            - Uses `compute_steroid_conversion_explanation` for calculation.
            - Uses `json.dumps` to serialize result into JSON string.
            - Both input and target steroids must include route (IV/PO).
        """
        input_variables = {
            "input steroid": [
                str(input_steroid),
                float(input_value),
                str(input_unit),
            ],
            "target steroid": str(target_steroid),
        }

        from medcalc.steroid_conversion import (
            compute_steroid_conversion_explanation,
        )

        try:
            result = compute_steroid_conversion_explanation(input_variables)
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )
        except Exception as e:
            return self.handle_exception("steroid_conversion", e)

    def wells_criteria_dvt(
        self,
        active_cancer: bool,  # Active cancer treatment within 6 months
        bedridden_for_atleast_3_days: bool,  # Bedridden >3 days recently
        major_surgery_in_last_12_weeks: bool,  # Major surgery within 12 weeks
        calf_swelling_3cm: bool,  # Calf swelling >3 cm vs other leg
        collateral_superficial_veins: bool,  # Collateral superficial veins
        leg_swollen: bool,  # Entire leg swollen
        localized_tenderness_on_deep_venuous_system: bool,  # Tenderness
        pitting_edema_on_symptomatic_leg: bool,
        # Pitting edema in symptomatic leg
        paralysis_paresis_immobilization_in_lower_extreme: bool,
        # Immobilization
        previous_dvt: bool,  # Previously documented DVT
        alternative_to_dvt_diagnosis: bool,
        # Alternative diagnosis more likely
    ) -> str:
        r"""Calculate the patient's Wells' Criteria for DVT score and
        generate a detailed explanatory text.

        Args:
            active_cancer (bool): Active cancer treatment within 6 months.
            bedridden_for_atleast_3_days (bool): Bedridden >3 days recently.
            major_surgery_in_last_12_weeks (bool):
            Major surgery within 12 weeks.
            calf_swelling_3cm (bool): Calf swelling >3 cm vs other leg.
            collateral_superficial_veins (bool): Collateral superficial veins.
            leg_swollen (bool): Entire leg swollen.
            localized_tenderness_on_deep_venuous_system (bool): Tenderness.
            pitting_edema_on_symptomatic_leg (bool): Pitting edema
            in symptomatic leg.
            paralysis_paresis_immobilization_in_lower_extreme (bool):
            Immobilization.
            previous_dvt (bool): Previously documented DVT.
            alternative_to_dvt_diagnosis (bool): Alternative diagnosis
            more likely.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Wells' Criteria for DVT score
                        (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `compute_wells_criteria_dvt_explanation` function is used for
            the actual calculation.
            - The `json.dumps` function is used to serialize
                the result into JSON.
        """
        # Construct the input variables dictionary
        input_variables = {
            "active_cancer": bool(active_cancer),
            "bedridden_for_atleast_3_days": bool(bedridden_for_atleast_3_days),
            "major_surgery_in_last_12_weeks": bool(
                major_surgery_in_last_12_weeks
            ),
            "calf_swelling_3cm": bool(calf_swelling_3cm),
            "collateral_superficial_veins": bool(collateral_superficial_veins),
            "leg_swollen": bool(leg_swollen),
            "localized_tenderness_on_deep_venuous_system": bool(
                localized_tenderness_on_deep_venuous_system
            ),
            "pitting_edema_on_symptomatic_leg": bool(
                pitting_edema_on_symptomatic_leg
            ),
            "paralysis_paresis_immobilization_in_lower_extreme": bool(
                paralysis_paresis_immobilization_in_lower_extreme
            ),
            "previous_dvt": bool(previous_dvt),
            "alternative_to_dvt_diagnosis": bool(alternative_to_dvt_diagnosis),
        }

        from medcalc.wells_criteria_dvt import (
            compute_wells_criteria_dvt_explanation,
        )

        try:
            # Call the Wells' Criteria calculation function
            result = compute_wells_criteria_dvt_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_wells_criteria_dvt_explanation", e
            )

    def cci(
        self,
        age_value: float,  # Numeric part of age (e.g., 45)
        age_unit: str,  # Unit of age (e.g., "years")
        mi: bool,  # Myocardial infarction history
        chf: bool,  # Congestive heart failure
        peripheral_vascular_disease: bool,  # Peripheral vascular disease
        cva: bool,  # Cerebrovascular accident
        tia: bool,  # Transient ischemic attack
        connective_tissue_disease: bool,  # Connective tissue disease
        dementia: bool,  # Dementia
        copd: bool,  # Chronic obstructive pulmonary disease
        hemiplegia: bool,  # Hemiplegia
        peptic_ucler_disease: bool,  # Peptic ulcer disease
        diabetes_mellitus: str,  # Diabetes status
        moderate_to_severe_ckd: bool,  # Moderate/severe kidney disease
        solid_tumor: str,  # Solid tumor status
        leukemia: bool,  # Leukemia
        lymphoma: bool,  # Lymphoma
        aids: bool,  # AIDS status
        liver_disease: str,  # Liver disease severity
    ) -> str:
        r"""Calculate the patient's Charlson Comorbidity Index (CCI)
        and generate a detailed explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age ("years").
            mi (bool): Myocardial infarction history (True/False).
            chf (bool): Congestive heart failure (True/False).
            peripheral_vascular_disease (bool): Peripheral vascular disease.
            cva (bool): Cerebrovascular accident (True/False).
            tia (bool): Transient ischemic attack (True/False).
            connective_tissue_disease (bool): Connective tissue disease.
            dementia (bool): Dementia status (True/False).
            copd (bool): Chronic obstructive pulmonary disease.
            hemiplegia (bool): Hemiplegia status (True/False).
            peptic_ucler_disease (bool): Peptic ulcer disease.
            diabetes_mellitus (str): Diabetes status, one of:
                - "none or diet-controlled"
                - "uncomplicated"
                - "end-organ damage"
            moderate_to_severe_ckd (bool): Moderate/severe kidney disease.
            solid_tumor (str): Solid tumor status, one of:
                - "none"
                - "localized"
                - "metastatic"
            leukemia (bool): Leukemia status (True/False).
            lymphoma (bool): Lymphoma status (True/False).
            aids (bool): AIDS status (True/False).
            liver_disease (str): Liver disease severity, one of:
                - "none"
                - "mild"
                - "moderate to severe"

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process
                        and explanatory text",
                    "final_answer": "CCI score (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `compute_cci_explanation` function is used to calculate CCI.
            - The `json.dumps` function is used to serialize
                the result into JSON.
        """
        # Construct the input variables dictionary
        input_variables = {
            "age": (float(age_value), str(age_unit)),
            "mi": bool(mi),
            "chf": bool(chf),
            "peripheral_vascular_disease": bool(peripheral_vascular_disease),
            "cva": bool(cva),
            "tia": bool(tia),
            "connective_tissue_disease": bool(connective_tissue_disease),
            "dementia": bool(dementia),
            "copd": bool(copd),
            "hemiplegia": bool(hemiplegia),
            "peptic_ucler_disease": bool(peptic_ucler_disease),
            "diabetes_mellitus": str(diabetes_mellitus),
            "moderate_to_severe_ckd": bool(moderate_to_severe_ckd),
            "solid_tumor": str(solid_tumor),
            "leukemia": bool(leukemia),
            "lymphoma": bool(lymphoma),
            "aids": bool(aids),
            "liver_disease": str(liver_disease),
        }

        from medcalc.cci import (
            compute_cci_explanation,
        )

        try:
            # Call the CCI calculation function
            result = compute_cci_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(result["Answer"]),  # Final answer
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_cci_explanation", e)

    def cha2ds2_vasc_score(
        self,
        age_value: float,  # Numeric part of age (e.g., 65)
        age_unit: str,  # Unit of age (e.g., "years")
        sex: str,  # Gender ("male"/"female")
        chf: bool = False,  # Congestive heart failure history
        hypertension: bool = False,  # Hypertension history
        stroke: bool = False,  # Stroke history
        tia: bool = False,  # Transient ischemic attack history
        thromboembolism: bool = False,  # Thromboembolism history
        vascular_disease: bool = False,  # Vascular disease history
        diabetes: bool = False,  # Diabetes history
    ) -> str:
        r"""Calculate the patient's CHA2DS2-VASc score and generate a detailed
        explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of:
                - "years" for years.
            sex (str): The patient's gender, one of:
                - "male" for male.
                - "female" for female.
            chf (bool, optional): Congestive heart failure history.
                Defaults to False.
            hypertension (bool, optional): Hypertension history.
                Defaults to False.
            stroke (bool, optional): Stroke history. Defaults to False.
            tia (bool, optional): Transient ischemic attack history.
                Defaults to False.
            thromboembolism (bool, optional): Thromboembolism history.
                Defaults to False.
            vascular_disease (bool, optional): Vascular disease history.
                Defaults to False.
            diabetes (bool, optional): Diabetes history. Defaults to False.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "CHA2DS2-VASc score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `generate_cha2ds2_vasc_explanation` function is used for the
                calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
            - If the input gender is not "male" or "female", the function will
                still calculate but with default sex points.
        """
        # Construct the input variables dictionary
        input_variables = {
            "age": (float(age_value), str(age_unit)),  # Age: (value, unit)
            "sex": str(sex),  # Gender
            "chf": bool(chf),  # Congestive heart failure
            "hypertension": bool(hypertension),  # Hypertension
            "stroke": bool(stroke),  # Stroke
            "tia": bool(tia),  # Transient ischemic attack
            "thromboembolism": bool(thromboembolism),  # Thromboembolism
            "vascular_disease": bool(vascular_disease),  # Vascular disease
            "diabetes": bool(diabetes),  # Diabetes
        }

        from medcalc.cha2ds2_vasc_score import (
            generate_cha2ds2_vasc_explanation,
        )

        try:
            # Call the CHA2DS2-VASc calculation function
            result = generate_cha2ds2_vasc_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(result["Answer"]),  # Final answer
                }
            )
        except Exception as e:
            return self.handle_exception(
                "generate_cha2ds2_vasc_explanation",
                e,
            )

    def child_pugh_score(
        self,
        inr: float,  # International Normalised Ratio (float)
        albumin_value: float,  # Numeric part of albumin (e.g., 2.1)
        albumin_unit: str,  # Unit of albumin (e.g., "g/dL")
        bilirubin_value: float,  # Numeric part of bilirubin (e.g., 2.8)
        bilirubin_unit: str,  # Unit of bilirubin (e.g., "mg/dL")
        ascites: str,  # Ascites level ("Absent"/"Slight"/"Moderate")
        encephalopathy: str,  # Encephalopathy state
    ) -> str:
        r"""Calculate the patient's Child-Pugh Score and generate a detailed
        explanatory text.

        Args:
            inr (float): The patient's international normalised ratio.
            albumin_value (float): The numeric value of albumin concentration.
            albumin_unit (str): The unit of albumin concentration, one of:
                - "g/L" for grams per liter
                - "mg/dL" for milligrams per deciliter
                - "g/dL" for grams per deciliter
                - "g/mL" for grams per milliliter
            bilirubin_value (float): The numeric value of bilirubin level.
            bilirubin_unit (str): The unit of bilirubin level, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
                - "mg/dL" for milligrams per deciliter
            ascites (str): The patient's ascites level, one of:
                - "Absent" for absent
                - "Slight" for slight
                - "Moderate" for moderate
            encephalopathy (str): The patient's encephalopathy state, one of:
                - "No Encephalopathy" for none
                - "Grade 1-2" for grade 1-2
                - "Grade 3-4" for grade 3-4

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Child-Pugh Score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_child_pugh_score_explanation` function is used for
                the calculation.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
            - If input values are invalid, the function will return an error.
        """
        # Construct the input variables dictionary
        input_variables = {
            "inr": float(inr),
            "albumin": (float(albumin_value), str(albumin_unit)),
            "bilirubin": (float(bilirubin_value), str(bilirubin_unit)),
            "ascites": str(ascites),
            "encephalopathy": str(encephalopathy),
        }

        from medcalc.child_pugh_score import (
            compute_child_pugh_score_explanation,
        )

        try:
            # Call the Child-Pugh Score calculation function
            result = compute_child_pugh_score_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_child_pugh_score_explanation", e
            )

    def ckd_epi_2021_creatinine(
        self,
        creatinine_value: float,  # Numeric part of creatinine (e.g., 3.7)
        creatinine_unit: str,  # Unit of creatinine (e.g., "mg/dL")
        age_value: float,  # Numeric part of age (e.g., 17)
        age_unit: str,  # Unit of age (e.g., "years")
        sex: str,  # Gender ("male"/"female")
    ) -> str:
        r"""Calculate the patient's Glomerular Filtration Rate (GFR)
        and generate a detailed explanatory text using CKD-EPI 2021 formula.

        Args:
            creatinine_value (float): The numeric value of serum creatinine.
            creatinine_unit (str): The unit of creatinine, one of:
                - "mg/dL" for milligrams per deciliter
                - "μmol/L" for micromoles per liter
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of age, one of:
                - "years" for years
                - "months" for months
            sex (str): The patient's gender, one of:
                - "Male" for male
                - "Female" for female

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "GFR in ml/min/1.73 m² (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `ckd_epi_2021_explanation` function is used for calculation.
            - The `json.dumps` function serializes the result into JSON string.
            - Gender must be "Male" or "Female" for calculation to proceed.
        """
        # Construct input variables dictionary
        input_variables = {
            "creatinine": (
                float(creatinine_value),
                str(creatinine_unit),
            ),  # Creatinine: (value, unit)
            "age": (
                float(age_value),
                str(age_unit),
            ),  # Age: (value, unit)
            "sex": str(sex),  # Gender
        }

        from medcalc.ckd_epi_2021_creatinine import (
            ckd_epi_2021_explanation,
        )

        try:
            # Call the GFR calculation function
            result = ckd_epi_2021_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("ckd_epi_2021_creatinine", e)

    def sofa(
        self,
        partial_pressure_oxygen_value: float,
        partial_pressure_oxygen_unit: str,
        fio2_value: float,
        fio2_unit: str,
        platelet_count_value: float,
        platelet_count_unit: str,
        gcs_value: int,
        dopamine_value: float,
        dopamine_unit: str,
        dobutamine_value: float,
        dobutamine_unit: str,
        epinephrine_value: float,
        epinephrine_unit: str,
        norepinephrine_value: float,
        norepinephrine_unit: str,
        cpap: bool,
        sys_bp_value: float,
        sys_bp_unit: str,
        dia_bp_value: float,
        dia_bp_unit: str,
        bilirubin_value: float,
        bilirubin_unit: str,
        creatinine_value: float,
        creatinine_unit: str,
        mechanical_ventilation: bool = False,
        urine_output_value: Optional[float] = None,
        urine_output_unit: Optional[str] = None,
    ) -> str:
        r"""Calculate the patient's SOFA Score and generate
        detailed explanatory text.

        Args:
            partial_pressure_oxygen_value (float): Numeric value of PaO₂
                (e.g., 80).
            partial_pressure_oxygen_unit (str): Unit of PaO₂ (e.g., "mm").
            fio2_value (float): Numeric value of FiO₂ (e.g., 0.2).
            fio2_unit (str): Unit of FiO₂ (e.g., "Hg").
            platelet_count_value (float): Numeric platelet count
                (e.g., 150000).
            platelet_count_unit (str): Unit of platelet count (e.g., "µL").
            gcs_value (int): Glasgow Coma Scale value 3-15 (e.g., 15).
            dopamine_value (float): Numeric dopamine value (e.g., 97.2).
            dopamine_unit (str): Unit of dopamine (e.g., "pg/mL").
            dobutamine_value (float): Numeric dobutamine value (e.g., 15).
            dobutamine_unit (str): Unit of dobutamine (e.g., "µg/kg/min").
            epinephrine_value (float): Numeric epinephrine value (e.g., 19).
            epinephrine_unit (str): Unit of epinephrine (e.g., "pg/mL").
            norepinephrine_value (float): Numeric norepinephrine value
                (e.g., 200).
            norepinephrine_unit (str): Unit of norepinephrine (e.g., "pg/mL").
            cpap (bool): CPAP status (True/False).
            sys_bp_value (float): Numeric systolic BP value (e.g., 70).
            sys_bp_unit (str): Unit of systolic BP (e.g., "mm").
            dia_bp_value (float): Numeric diastolic BP value (e.g., 12).
            dia_bp_unit (str): Unit of diastolic BP (e.g., "Hg").
            bilirubin_value (float): Numeric bilirubin value (e.g., 2.8).
            bilirubin_unit (str): Unit of bilirubin (e.g., "mg/dL").
            creatinine_value (float): Numeric creatinine value (e.g., 3.7).
            creatinine_unit (str): Unit of creatinine (e.g., "mg/dL").
            mechanical_ventilation (bool): Mechanical ventilation status.
            urine_output_value (float): Numeric urine output (e.g., 500).
            urine_output_unit (str): Unit of urine output (e.g., "mL/day").

        Returns:
            str: A JSON string containing calculation process and result:
                {
                    "rationale": "Detailed calculation explanation",
                    "final_answer": "SOFA Score (string format)"
                }
                If exception occurs, returns error message
                from handle_exception.

        Notes:
            - The `compute_sofa_explanation` function is used for
                core calculations.
            - The `json.dumps` function serializes the result into JSON string.
            - Missing optional parameters will use default values:
                - mechanical_ventilation defaults to False
                - urine_output defaults to None (not considered in calculation)
        """
        # Construct input variables dictionary
        input_variables = {
            "partial_pressure_oxygen": (
                float(partial_pressure_oxygen_value),
                str(partial_pressure_oxygen_unit),
            ),
            "fio2": (float(fio2_value), str(fio2_unit)),
            "platelet_count": (
                float(platelet_count_value),
                str(platelet_count_unit),
            ),
            "gcs": int(gcs_value),
            "dopamine": (float(dopamine_value), str(dopamine_unit)),
            "dobutamine": (float(dobutamine_value), str(dobutamine_unit)),
            "epinephrine": (float(epinephrine_value), str(epinephrine_unit)),
            "norepinephrine": (
                float(norepinephrine_value),
                str(norepinephrine_unit),
            ),
            "cpap": bool(cpap),
            "sys_bp": (float(sys_bp_value), str(sys_bp_unit)),
            "dia_bp": (float(dia_bp_value), str(dia_bp_unit)),
            "bilirubin": (float(bilirubin_value), str(bilirubin_unit)),
            "creatinine": (float(creatinine_value), str(creatinine_unit)),
            "mechanical_ventilation": bool(mechanical_ventilation),
        }

        if urine_output_value is not None and urine_output_unit is not None:
            input_variables["urine_output"] = (
                float(urine_output_value),
                str(urine_output_unit),
            )

        from medcalc.sofa import compute_sofa_explanation

        try:
            result = compute_sofa_explanation(input_variables)
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            return self.handle_exception("compute_sofa_explanation", e)

    def centor_score(
        self,
        age_value: float,  # Numeric part of age (e.g., 48)
        age_unit: str,  # Unit of age ("years"/"months")
        temp_value: float,  # Numeric part of temperature (e.g., 99.0)
        temp_unit: str,  # Unit of temp ("fahrenheit"/"celsius")
        exudate: bool,  # Exudate/swelling on tonsils
        lymph_nodes: bool,  # Tender/swollen lymph nodes
        cough_absent: bool,  # Whether cough is absent
    ) -> str:
        r"""Calculate patient's Centor Score and generate
        detailed explanatory text.

        Args:
            age_value (float): Numeric value of patient's age.
            age_unit (str): Unit of age, one of:
                - "years" for years
                - "months" for months
            temp_value (float): Numeric value of temperature.
            temp_unit (str): Unit of temperature, one of:
                - "fahrenheit" for Fahrenheit
                - "celsius" for Celsius
            exudate (bool): Presence of exudate/swelling on tonsils.
            lymph_nodes (bool): Presence of tender/swollen lymph nodes.
            cough_absent (bool): Whether cough is absent.

        Returns:
            str: JSON string containing calculation process and result:
                {
                    "rationale": "Detailed calculation explanation",
                    "final_answer": "Centor Score (string format)"
                }
                If exception occurs, returns error message
                from handle_exception.

        Notes:
            - Uses compute_centor_score_explanation for calculation.
            - json.dumps used to serialize result to JSON string.
        """
        input_variables = {
            "age": (float(age_value), str(age_unit)),
            "temperature": (float(temp_value), str(temp_unit)),
            "exudate_swelling_tonsils": bool(exudate),
            "tender_lymph_nodes": bool(lymph_nodes),
            "cough_absent": bool(cough_absent),
        }

        try:
            from medcalc.centor_score import (
                compute_centor_score_explanation,
            )

            result = compute_centor_score_explanation(input_variables)

            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            return self.handle_exception("compute_centor_score_explanation", e)

    def curb_65(
        self,
        age_value: float,  # Numeric part of age (e.g., 37)
        age_unit: str,  # Unit of age (e.g., "years")
        sys_bp_value: float,  # Numeric part of systolic BP (e.g., 90.0)
        sys_bp_unit: str,  # Unit of systolic BP (e.g., "mm hg")
        dia_bp_value: float,  # Numeric part of diastolic BP (e.g., 50.0)
        dia_bp_unit: str,  # Unit of diastolic BP (e.g., "mm hg")
        respiratory_rate_value: float,  # Numeric RR (e.g., 30.0)
        respiratory_rate_unit: str,  # Unit of RR (e.g., "breaths per minute")
        bun_value: float,  # Numeric BUN value (e.g., 3.5)
        bun_unit: str,  # Unit of BUN (e.g., "mmol/L")
        confusion: Optional[bool] = None,
        # Whether patient has confusion (optional)
    ) -> str:
        r"""Calculate the patient's CURB-65 score and generate a detailed
        explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of age, one of:
                - "months"
                - "years"
            sys_bp_value (float): The numeric value of systolic blood pressure.
            sys_bp_unit (str): The unit of systolic BP, currently only "mm hg".
            dia_bp_value (float): The numeric value of diastolic
                blood pressure.
            dia_bp_unit (str): The unit of diastolic BP,
                currently only "mm hg".
            respiratory_rate_value (float): The numeric
                value of respiratory rate.
            respiratory_rate_unit (str): The unit of respiratory rate, e.g.
                "breaths per minute".
            bun_value (float): The numeric value of Blood Urea Nitrogen (BUN).
            bun_unit (str): The unit of BUN, e.g. "mmol/L".
            confusion (bool, optional): Whether patient
                has confusion. Defaults to None if not reported.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "CURB-65 score (string format)"
                }
                If an exception occurs, returns an error message generated by
                the `handle_exception` method.

        Notes:
            - The `curb_65_explanation` function is used for core calculations.
            - The `json.dumps` function serializes the result into JSON string.
            - Missing confusion status defaults to False in scoring.
        """
        input_variables = {
            "age": (float(age_value), str(age_unit)),
            "sys_bp": (float(sys_bp_value), str(sys_bp_unit)),
            "dia_bp": (float(dia_bp_value), str(dia_bp_unit)),
            "respiratory_rate": (
                float(respiratory_rate_value),
                str(respiratory_rate_unit),
            ),
            "bun": (float(bun_value), str(bun_unit)),
        }
        from medcalc.curb_65 import curb_65_explanation

        if confusion is not None:
            input_variables["confusion"] = (float(confusion), "boolean")

        try:
            result = curb_65_explanation(input_variables)
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )
        except Exception as e:
            return self.handle_exception("curb_65_explanation", e)

    def fibrosis_4(
        self,
        age_value: float,  # Numeric part of age (e.g., 17)
        age_unit: str,  # Unit of age ("years"/"months")
        alt_value: float,  # ALT value (e.g., 144.0)
        alt_unit: str,  # ALT unit (e.g., "U/L")
        ast_value: float,  # AST value (e.g., 108.0)
        ast_unit: str,  # AST unit (e.g., "U/L")
        platelet_value: float,  # Platelet count (e.g., 277000.0)
        platelet_unit: str,  # Platelet unit (e.g., "µL")
    ) -> str:
        r"""Calculate the patient's Fibrosis-4 (FIB-4) index and generate a
        detailed explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of:
                - "years" for years
                - "months" for months
            alt_value (float): The numeric value of ALT concentration.
            alt_unit (str): The unit of ALT concentration (e.g., "U/L").
            ast_value (float): The numeric value of AST concentration.
            ast_unit (str): The unit of AST concentration (e.g., "U/L").
            platelet_value (float): The numeric value of platelet count.
            platelet_unit (str): The unit of platelet count (e.g., "µL").

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process explanation",
                    "final_answer": "FIB-4 score (string format)"
                }
                If an exception occurs, returns an error message generated by
                the `handle_exception` method.

        Notes:
            - The `compute_fib4_explanation` function is used for calculation.
            - The `json.dumps` function serializes the result into JSON string.
        """
        input_variables = {
            "age": (float(age_value), str(age_unit)),
            "alt": (float(alt_value), str(alt_unit)),
            "ast": (float(ast_value), str(ast_unit)),
            "platelet_count": (float(platelet_value), str(platelet_unit)),
        }

        from medcalc.fibrosis_4 import (
            compute_fib4_explanation,
        )

        try:
            result = compute_fib4_explanation(input_variables)
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )
        except Exception as e:
            return self.handle_exception("compute_fib4_explanation", e)

    def maintenance_fluid_calc(
        self,
        weight_value: float,  # Numeric part of the weight (e.g., 12.0)
        weight_unit: str,  # Unit of the weight ("lbs", "g", or "kg")
    ) -> str:
        r"""Calculate the patient's maintenance fluid in mL/hr and generate a
        detailed explanatory text.

        Args:
            weight_value (float): The numeric value of the patient's weight.
            weight_unit (str): The unit of the patient's weight, one of:
                - "lbs" for pounds.
                - "g" for grams.
                - "kg" for kilograms.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer":
                        "Maintenance fluid in mL/hr (string format)"
                }
                If an exception occurs, returns an error message generated by
                the `handle_exception` method.

        Notes:
            - Uses `maintenance_fluid_explanation` for calculation.
            - Uses `json.dumps` to serialize result into JSON string.
            - Different formulas are used based on weight ranges:
                - <10 kg: weight * 4 mL/kg/hr
                - 10-20 kg: 40 mL/hr + 2 mL/kg/hr * (weight - 10 kg)
                - >20 kg: 60 mL/hr + 1 mL/kg/hr * (weight - 20 kg)
        """
        # Construct input variables dictionary
        input_variables = {
            "weight": (
                float(weight_value),
                str(weight_unit),
            )  # Weight: (value, unit)
        }

        from medcalc.maintenance_fluid_calc import (
            maintenance_fluid_explanation,
        )

        try:
            # Call the maintenance fluid calculation function
            result = maintenance_fluid_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string)
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("maintenance_fluid_explanation", e)

    def mme(
        self,
        tapentadol_dose_value: float,
        tapentadol_dose_unit: str,
        tapentadol_dose_per_day_value: float,
        tapentadol_dose_per_day_unit: str,
        hydrocodone_dose_value: float,
        hydrocodone_dose_unit: str,
        hydrocodone_dose_per_day_value: float,
        hydrocodone_dose_per_day_unit: str,
        fentanyl_patch_dose_value: float,
        fentanyl_patch_dose_unit: str,
        fentanyl_patch_dose_per_day_value: float,
        fentanyl_patch_dose_per_day_unit: str,
    ) -> str:
        r"""Calculate the Morphine Milligram Equivalent (MME) and generate a
        detailed explanatory text.

        Args:
            tapentadol_dose_value (float): The numeric value
                of Tapentadol dose.
            tapentadol_dose_unit (str): The unit of Tapentadol dose, one of:
                - "mg" for milligrams
                - "µg" for micrograms
            tapentadol_dose_per_day_value (float): Number
                of Tapentadol doses/day.
            tapentadol_dose_per_day_unit (str): Unit for doses/day (typically
                "per day").
            hydrocodone_dose_value (float): The numeric value
                of Hydrocodone dose.
            hydrocodone_dose_unit (str): The unit of Hydrocodone dose, one of:
                - "mg" for milligrams
                - "µg" for micrograms
            hydrocodone_dose_per_day_value (float):
                Number of Hydrocodone doses/day.
            hydrocodone_dose_per_day_unit (str): Unit for doses/day (typically
                "per day").
            fentanyl_patch_dose_value (float): The numeric value
                of Fentanyl dose.
            fentanyl_patch_dose_unit (str): The unit of Fentanyl dose, one of:
                - "mg" for milligrams
                - "µg" for micrograms
            fentanyl_patch_dose_per_day_value (float):
                Number of Fentanyl doses/day.
            fentanyl_patch_dose_per_day_unit (str):
                Unit for doses/day (typically "per day").

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process
                        and explanatory text",
                    "final_answer": "MME in milligrams (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `mme_explanation` function is used to calculate the MME.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary for mme_explanation
        input_variables = {
            "Tapentadol Dose": (
                float(tapentadol_dose_value),
                str(tapentadol_dose_unit),
            ),
            "Tapentadol Dose Per Day": (
                float(tapentadol_dose_per_day_value),
                str(tapentadol_dose_per_day_unit),
            ),
            "HYDROcodone Dose": (
                float(hydrocodone_dose_value),
                str(hydrocodone_dose_unit),
            ),
            "HYDROcodone Dose Per Day": (
                float(hydrocodone_dose_per_day_value),
                str(hydrocodone_dose_per_day_unit),
            ),
            "FentANYL patch Dose": (
                float(fentanyl_patch_dose_value),
                str(fentanyl_patch_dose_unit),
            ),
            "FentANYL patch Dose Per Day": (
                float(fentanyl_patch_dose_per_day_value),
                str(fentanyl_patch_dose_per_day_unit),
            ),
        }

        from medcalc.mme import (
            mme_explanation,
        )

        try:
            # Call the MME calculation function
            result = mme_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(result["Answer"]),  # Final answer
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("mme_explanation", e)

    def perc_rule(
        self,
        age_value: float,  # Numeric part of age (e.g., 73)
        age_unit: str,  # Unit of age (e.g., "years")
        heart_rate_value: float,  # Numeric HR value (e.g., 92.0)
        heart_rate_unit: str,  # Unit of HR (e.g., "breaths per minute")
        oxygen_sat_value: float,  # Numeric O2 sat value (e.g., 98.0)
        oxygen_sat_unit: str,  # Unit of O2 sat (e.g., "%")
        unilateral_leg_swelling: bool,  # Presence of leg swelling
        hemoptysis: bool,  # Presence of hemoptysis
        recent_surgery_or_trauma: bool,  # Recent surgery/trauma
        previous_pe: bool,  # History of pulmonary embolism
        previous_dvt: bool,  # History of deep vein thrombosis
        hormonal_use: bool,  # Current hormonal use
    ) -> str:
        r"""Calculate the patient's PERC Rule score and generate a detailed
        explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, typically "years".
            heart_rate_value (float): The numeric value of heart rate.
            heart_rate_unit (str): The unit of heart rate, typically "beats per
                minute".
            oxygen_sat_value (float): The numeric value of oxygen saturation.
            oxygen_sat_unit (str): The unit of oxygen saturation,
                typically "%".
            unilateral_leg_swelling (bool): Presence of unilateral
                leg swelling.
            hemoptysis (bool): Presence of hemoptysis.
            recent_surgery_or_trauma (bool): Recent surgery/trauma
                within 4 weeks.
            previous_pe (bool): History of pulmonary embolism.
            previous_dvt (bool): History of deep vein thrombosis.
            hormonal_use (bool): Current use of hormonal therapy.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "PERC Rule score
                        (integer in string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_perc_rule_explanation` function is used to calculate
                the PERC Rule score.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input parameters dictionary
        input_parameters = {
            "age": (float(age_value), str(age_unit)),
            "heart_rate": (float(heart_rate_value), str(heart_rate_unit)),
            "oxygen_sat": (float(oxygen_sat_value), str(oxygen_sat_unit)),
            "unilateral_leg_swelling": bool(unilateral_leg_swelling),
            "hemoptysis": bool(hemoptysis),
            "recent_surgery_or_trauma": bool(recent_surgery_or_trauma),
            "previous_pe": bool(previous_pe),
            "previous_dvt": bool(previous_dvt),
            "hormonal_use": bool(hormonal_use),
        }

        try:
            from medcalc.perc_rule import (
                compute_perc_rule_explanation,
            )

            # Call the PERC Rule calculation function
            result = compute_perc_rule_explanation(input_parameters)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_perc_rule_explanation", e)

    def sirs_criteria(
        self,
        temperature_value: float,  # Numeric part of temperature (e.g., 38.0)
        temperature_unit: str,  # Unit of temperature (e.g., "degrees celsius")
        heart_rate_value: float,  # Numeric part of heart rate (e.g., 74.0)
        heart_rate_unit: str,  # Unit of heart rate (e.g., "beats per minute")
        wbc_value: float,  # Numeric part of WBC count (e.g., 15760.0)
        wbc_unit: str,  # Unit of WBC count (e.g., "mL")
        respiratory_rate_value: Optional[float] = None,
        # Optional respiratory rate value
        respiratory_rate_unit: Optional[
            str
        ] = None,  # Optional respiratory rate unit
        paco2_value: Optional[float] = None,  # Optional PaCO₂ value
        paco2_unit: Optional[str] = None,  # Optional PaCO₂ unit
    ) -> str:
        r"""Calculate the patient's SIRS Criteria score and generate a detailed
        explanatory text.

        Args:
            temperature_value (float): Numeric value of patient's temperature.
            temperature_unit (str): Unit of temperature, one of:
                - "degrees celsius"
                - "degrees fahrenheit"
            heart_rate_value (float): Numeric value of patient's heart rate.
            heart_rate_unit (str): Unit of heart rate
                (e.g., "beats per minute").
            wbc_value (float): Numeric value of white blood cell count.
            wbc_unit (str): Unit of WBC count (e.g., "mL", "m^3").
            respiratory_rate_value (float, optional):
                Numeric value of respiratory
                rate. Defaults to None.
            respiratory_rate_unit (str, optional): Unit of respiratory rate.
                Defaults to None.
            paco2_value (float, optional):
                Numeric value of PaCO₂. Defaults to None.
            paco2_unit (str, optional): Unit of PaCO₂. Defaults to None.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process text",
                    "final_answer": "SIRS Criteria score (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.
        """
        # Construct input dictionary from parameters
        input_variables = {
            "temperature": (float(temperature_value), str(temperature_unit)),
            "heart_rate": (float(heart_rate_value), str(heart_rate_unit)),
            "wbc": (float(wbc_value), str(wbc_unit)),
        }

        # Add optional parameters if provided
        if respiratory_rate_value is not None:
            input_variables["respiratory_rate"] = (
                float(respiratory_rate_value),
                str(respiratory_rate_unit),
            )
        if paco2_value is not None:
            input_variables["paco2"] = (float(paco2_value), str(paco2_unit))

        try:
            from medcalc.sirs_criteria import (
                sirs_criteria_explanation,
            )

            # Call the SIRS criteria calculation function
            result = sirs_criteria_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("sirs_criteria_explanation", e)

    def sch(
        self,
        sodium_value: float,  # Numeric part of sodium level (e.g., 134.0)
        sodium_unit: str,  # Unit of sodium level (e.g., "mEq/L")
        glucose_value: float,  # Numeric part of glucose level (e.g., 90.0)
        glucose_unit: str,  # Unit of glucose level (e.g., "mg/dL")
    ) -> str:
        r"""Calculate the patient's corrected sodium
        concentration for hyperglycemia and generate
        a detailed explanatory text.

        Args:
            sodium_value (float): The numeric value of
                the patient's sodium level.
            sodium_unit (str): The unit of the patient's sodium level, one of:
                - "mEq/L" for milliequivalents per liter
                - Other units supported by conversion_explanation
            glucose_value (float):
                The numeric value of the patient's glucose level.
            glucose_unit (str):
                The unit of the patient's glucose level, one of:
                - "mg/dL" for milligrams per deciliter
                - Other units supported by conversion_explanation

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale":
                        "Detailed calculation process and explanatory text",
                    "final_answer": "Corrected sodium concentration in mEq/L"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `compute_sodium_correction_hyperglycemia_explanation`
            function is used for the calculation.
            - The `json.dumps` function is used to
                serialize the result into JSON.
            - Formula: Corrected Sodium =
                Measured Sodium + 0.024 * (Glucose - 100)
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "glucose": (float(glucose_value), str(glucose_unit)),
        }

        from medcalc.sch import (
            compute_sodium_correction_hyperglycemia_explanation,
        )

        try:
            # Call the sodium correction calculation function
            result = compute_sodium_correction_hyperglycemia_explanation(
                input_variables
            )

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception(
                "compute_sodium_correction_hyperglycemia_explanation", e
            )

    def apache_ii(
        self,
        sodium_value: float,
        sodium_unit: str,
        ph: float,
        heart_rate_value: float,
        heart_rate_unit: str,
        respiratory_rate_value: float,
        respiratory_rate_unit: str,
        potassium_value: float,
        potassium_unit: str,
        creatinine_value: float,
        creatinine_unit: str,
        age_value: int,
        age_unit: str,
        acute_renal_failure: bool,
        chronic_renal_failure: bool,
        hemocratit_value: float,
        hemocratit_unit: str,
        wbc_value: float,
        wbc_unit: str,
        fio2_value: float,
        fio2_unit: str,
        gcs: int,
        a_a_gradient: float,
        partial_pressure_oxygen_value: float,
        partial_pressure_oxygen_unit: str,
        temperature_value: float,
        temperature_unit: str,
        sys_bp_value: float,
        sys_bp_unit: str,
        dia_bp_value: float,
        dia_bp_unit: str,
        organ_failure_immunocompromise: bool = False,
        surgery_type: str = "Nonelective",
    ) -> str:
        r"""Calculate the patient's APACHE II Score and generate a detailed
        explanatory text.

        Args:
            sodium_value (float): Numeric value of sodium level.
            sodium_unit (str): Unit of sodium level ("mmol/L").
            ph (float): Patient's arterial pH value.
            heart_rate_value (float): Numeric heart rate value.
            heart_rate_unit (str): Unit of heart rate ("beats per minute").
            respiratory_rate_value (float): Numeric respiratory rate value.
            respiratory_rate_unit (str): Unit of respiratory rate
                ("breaths per minute").
            potassium_value (float): Numeric potassium level value.
            potassium_unit (str): Unit of potassium level ("mmol/L").
            creatinine_value (float): Numeric creatinine level value.
            creatinine_unit (str): Unit of creatinine level ("mg/dL").
            age_value (int): Numeric age value.
            age_unit (str): Unit of age ("years").
            acute_renal_failure (bool): Whether acute renal failure is present.
            chronic_renal_failure (bool): Whether chronic renal
                failure is present.
            hemocratit_value (float): Numeric hemocratit value.
            hemocratit_unit (str): Unit of hemocratit ("%").
            wbc_value (float): Numeric white blood cell count value.
            wbc_unit (str): Unit of white blood cell count ("m^3").
            fio2_value (float): Numeric FiO2 value.
            fio2_unit (str): Unit of FiO2 ("Hg").
            gcs (int): Glasgow Coma Scale score (1-15).
            a_a_gradient (float): Alveolar-arterial gradient value.
            partial_pressure_oxygen_value (float): Numeric PaO2 value.
            partial_pressure_oxygen_unit (str): Unit of PaO2 ("mm").
            temperature_value (float): Numeric temperature value.
            temperature_unit (str): Unit of temperature
                ("degrees fahrenheit" or "celsius").
            sys_bp_value (float): Numeric systolic blood pressure value.
            sys_bp_unit (str): Unit of systolic blood pressure ("mm hg").
            dia_bp_value (float): Numeric diastolic blood pressure value.
            dia_bp_unit (str): Unit of diastolic blood pressure ("mm hg").
            organ_failure_immunocompromise (bool): Whether organ failure or
                immunocompromise is present. Defaults to False.
            surgery_type (str): Type of surgery ("Nonelective", "Elective", or
                "Emergency"). Defaults to "Nonelective".

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "APACHE II score (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `apache_ii_explanation` function is used to
                calculate the score.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
        """
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "pH": float(ph),
            "heart_rate": (float(heart_rate_value), str(heart_rate_unit)),
            "respiratory_rate": (
                float(respiratory_rate_value),
                str(respiratory_rate_unit),
            ),
            "potassium": (float(potassium_value), str(potassium_unit)),
            "creatinine": (float(creatinine_value), str(creatinine_unit)),
            "age": (int(age_value), str(age_unit)),
            "acute_renal_failure": bool(acute_renal_failure),
            "chronic_renal_failure": bool(chronic_renal_failure),
            "hemocratit": (float(hemocratit_value), str(hemocratit_unit)),
            "wbc": (float(wbc_value), str(wbc_unit)),
            "fio2": (float(fio2_value), str(fio2_unit)),
            "gcs": int(gcs),
            "a_a_gradient": float(a_a_gradient),
            "partial_pressure_oxygen": (
                float(partial_pressure_oxygen_value),
                str(partial_pressure_oxygen_unit),
            ),
            "temperature": (float(temperature_value), str(temperature_unit)),
            "sys_bp": (float(sys_bp_value), str(sys_bp_unit)),
            "dia_bp": (float(dia_bp_value), str(dia_bp_unit)),
            "organ_failure_immunocompromise": bool(
                organ_failure_immunocompromise
            ),
            "surgery_type": str(surgery_type),
        }

        from medcalc.apache_ii import (
            apache_ii_explanation,
        )

        try:
            # Call the APACHE II calculation function
            result = apache_ii_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("apache_ii_explanation", e)

    def caprini_score(
        self,
        sex: str,  # Gender ("male"/"female")
        age_value: float,  # Numeric part of age
        age_unit: str,  # Unit of age ("years")
        mobility: Optional[str] = None,  # Mobility status (optional)
        surgery_type: Optional[str] = None,  # Type of surgery (optional)
        bmi_value: Optional[float] = None,  # Numeric part of BMI (optional)
        bmi_unit: Optional[str] = None,  # Unit of BMI (optional)
        major_surgery: bool = False,  # Major surgery in last month
        chf: bool = False,  # Congestive heart failure
        sepsis: bool = False,  # Sepsis in last month
        pneumonia: bool = False,  # Pneumonia in last month
        immobilizing_plaster_case: bool = False,  # Immobilizing cast
        hip_pelvis_leg_fracture: bool = False,  # Hip/pelvis/leg fracture
        stroke: bool = False,  # Stroke in last month
        multiple_trauma: bool = False,  # Multiple trauma in last month
        acute_spinal_chord_injury: bool = False,  # Spinal cord injury
        varicose_veins: bool = False,  # Varicose veins
        current_swollen_legs: bool = False,  # Current swollen legs
        current_central_venuous: bool = False,  # Central venous access
        previous_dvt: bool = False,  # Previous DVT
        previous_pe: bool = False,  # Previous pulmonary embolism
        family_history_thrombosis: bool = False,  # Family history
        positive_factor_v: bool = False,  # Factor V Leiden
        positive_prothrombin: bool = False,  # Prothrombin 20210A
        serum_homocysteine: bool = False,  # Elevated homocysteine
        positive_lupus_anticoagulant: bool = False,  # Lupus anticoagulant
        elevated_anticardiolipin_antibody: bool = False,  # Anticardiolipin
        heparin_induced_thrombocytopenia: bool = False,  # HIT
        congenital_acquired_thrombophilia: bool = False,  # Thrombophilia
        inflammatory_bowel_disease: bool = False,  # IBD history
        acute_myocardial_infarction: bool = False,  # MI
        copd: bool = False,  # COPD
        malignancy: bool = False,  # Malignancy
    ) -> str:
        r"""Calculate the patient's Caprini Score and generate a detailed
        explanatory text.

        Args:
            sex (str): The patient's gender, one of:
                - "male" for male
                - "female" for female
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age ("years").
            mobility (str, optional): Mobility status, one of:
                - "normal" for normal mobility
                - "on bed rest" for medical patient on bed rest
                - "confined to bed >72 hours" for bed confinement
            surgery_type (str, optional): Type of surgery, one of:
                - "none" for no surgery
                - "minor" for minor surgery
                - "major" for major surgery >45 min
                - "laparoscopic" for laparoscopic surgery
                - "arthroscopic" for arthroscopic surgery
                - "elective major lower extremity arthroplasty"
            bmi_value (float, optional): The numeric value of BMI.
            bmi_unit (str, optional): The unit of BMI ("kg/m^2").
            major_surgery (bool): Major surgery in last month.
            chf (bool): Congestive heart failure in last month.
            sepsis (bool): Sepsis in last month.
            pneumonia (bool): Pneumonia in last month.
            immobilizing_plaster_case (bool): Immobilizing cast in last month.
            hip_pelvis_leg_fracture (bool): Hip/pelvis/leg
                fracture in last month.
            stroke (bool): Stroke in last month.
            multiple_trauma (bool): Multiple trauma in last month.
            acute_spinal_chord_injury (bool): Spinal cord injury in last month.
            varicose_veins (bool): Varicose veins.
            current_swollen_legs (bool): Current swollen legs.
            current_central_venuous (bool): Current central venous access.
            previous_dvt (bool): Previous DVT.
            previous_pe (bool): Previous pulmonary embolism.
            family_history_thrombosis (bool): Family history of thrombosis.
            positive_factor_v (bool): Positive Factor V Leiden.
            positive_prothrombin (bool): Positive prothrombin 20210A.
            serum_homocysteine (bool): Elevated serum homocysteine.
            positive_lupus_anticoagulant (bool): Positive lupus anticoagulant.
            elevated_anticardiolipin_antibody (bool): Elevated anticardiolipin.
            heparin_induced_thrombocytopenia (bool):
                Heparin-induced thrombocytopenia.
            congenital_acquired_thrombophilia (bool): Other thrombophilia.
            inflammatory_bowel_disease (bool): History of IBD.
            acute_myocardial_infarction (bool): Acute MI.
            copd (bool): Chronic obstructive pulmonary disease.
            malignancy (bool): Present or previous malignancy.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and
                        explanatory text",
                    "final_answer": "Caprini score (string format)"
                }
                If an exception occurs, return an error message generated by
                the `handle_exception` method.

        Notes:
            - The `caprini_score_explanation` function is used
                to calculate the score.
            - The `json.dumps` function is used to serialize the
                result into JSON.
        """
        # Construct the input parameters dictionary
        bmi_data = (
            (float(bmi_value), str(bmi_unit))
            if bmi_value and bmi_unit
            else None
        )
        input_parameters = {
            "sex": str(sex).lower(),
            "age": (float(age_value), str(age_unit)),
            "mobility": str(mobility) if mobility else None,
            "surgery_type": str(surgery_type) if surgery_type else None,
            "bmi": bmi_data,
            "major_surgery": bool(major_surgery),
            "chf": bool(chf),
            "sepsis": bool(sepsis),
            "pneumonia": bool(pneumonia),
            "immobilizing_plaster_case": bool(immobilizing_plaster_case),
            "hip_pelvis_leg_fracture": bool(hip_pelvis_leg_fracture),
            "stroke": bool(stroke),
            "multiple_trauma": bool(multiple_trauma),
            "acute_spinal_chord_injury": bool(acute_spinal_chord_injury),
            "varicose_veins": bool(varicose_veins),
            "current_swollen_legs": bool(current_swollen_legs),
            "current_central_venuous": bool(current_central_venuous),
            "previous_dvt": bool(previous_dvt),
            "previous_pe": bool(previous_pe),
            "family_history_thrombosis": bool(family_history_thrombosis),
            "positive_factor_v": bool(positive_factor_v),
            "positive_prothrombin": bool(positive_prothrombin),
            "serum_homocysteine": bool(serum_homocysteine),
            "positive_lupus_anticoagulant": bool(positive_lupus_anticoagulant),
            "elevated_anticardiolipin_antibody": bool(
                elevated_anticardiolipin_antibody
            ),
            "heparin_induced_thrombocytopenia": bool(
                heparin_induced_thrombocytopenia
            ),
            "congenital_acquired_thrombophilia": bool(
                congenital_acquired_thrombophilia
            ),
            "inflammatory_bowel_disease": bool(inflammatory_bowel_disease),
            "acute_myocardial_infarction": bool(acute_myocardial_infarction),
            "copd": bool(copd),
            "malignancy": bool(malignancy),
        }

        # Remove None values
        input_parameters = {
            k: v for k, v in input_parameters.items() if v is not None
        }

        try:
            from medcalc.caprini_score import (
                caprini_score_explanation,
            )

            # Call the Caprini score calculation function
            result = caprini_score_explanation(input_parameters)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(result["Answer"]),  # Final answer
                }
            )
        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("caprini_score_explanation", e)

    def cardiac_risk_index(
        self,
        elevated_risk_surgery: bool,  # Elevated-risk surgery status
        ischemetic_heart_disease: bool,  # Ischemic heart disease history
        congestive_heart_failure: bool,  # Congestive heart failure history
        cerebrovascular_disease: bool,  # Cerebrovascular disease history
        pre_operative_insulin_treatment: bool,  # Pre-op insulin treatment
        pre_operative_creatinine_value: float,  # Creatinine value
        pre_operative_creatinine_unit: str,
        # Creatinine unit ("mg/dL", "μmol/L")
    ) -> str:
        r"""Calculate the patient's Cardiac Risk Index (CRI) and generate a
        detailed explanatory text.

        Args:
            elevated_risk_surgery (bool): Whether patient had elevated-risk
                surgery (intraperitoneal, intrathoracic, or suprainguinal
                vascular).
            ischemetic_heart_disease (bool): History of ischemic heart disease
                (myocardial infarction, positive exercise test, chest pain from
                ischemia, nitrate therapy, or ECG with pathological Q waves).
            congestive_heart_failure (bool): History of congestive
                heart failure
                (pulmonary edema, bilateral rales, S3 gallop,
                nocturnal dyspnea,
                or chest x-ray showing pulmonary vascular redistribution).
            cerebrovascular_disease (bool): History of cerebrovascular disease
                (prior transient ischemic attack or stroke).
            pre_operative_insulin_treatment (bool): Pre-operative insulin
                treatment status.
            pre_operative_creatinine_value (float): Pre-operative creatinine
                value.
            pre_operative_creatinine_unit (str): Unit for creatinine value, one
                of:
                - "mg/dL" for milligrams per deciliter
                - "μmol/L" for micromoles per liter
                - Other supported creatinine units

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "Cardiac risk index score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_cardiac_index_explanation` function is used for the
                actual calculation.
            - The `json.dumps` function serializes the result
                into a JSON string.
        """
        # Construct the input variables dictionary from parameters
        input_variables = {
            "elevated_risk_surgery": bool(elevated_risk_surgery),
            "ischemetic_heart_disease": bool(ischemetic_heart_disease),
            "congestive_heart_failure": bool(congestive_heart_failure),
            "cerebrovascular_disease": bool(cerebrovascular_disease),
            "pre_operative_insulin_treatment": bool(
                pre_operative_insulin_treatment
            ),
            "pre_operative_creatinine": (
                float(pre_operative_creatinine_value),
                str(pre_operative_creatinine_unit),
            ),
        }

        from medcalc.cardiac_risk_index import (
            compute_cardiac_index_explanation,
        )

        try:
            # Call the CRI calculation function
            result = compute_cardiac_index_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("cardiac_index", e)

    def compute_fena(
        self,
        sodium_value: float,  # Numeric part of sodium (e.g., 134.0)
        sodium_unit: str,  # Unit of sodium (e.g., "mmol/L")
        creatinine_value: float,  # Numeric part of creatinine (e.g., 3.7)
        creatinine_unit: str,  # Unit of creatinine (e.g., "mg/dL")
        urine_sodium_value: float,  # Numeric part of urine sodium (e.g., 21.0)
        urine_sodium_unit: str,  # Unit of urine sodium (e.g., "mmol/L")
        urine_creatinine_value: float,  # Numeric part of urine
        # creatinine (5.0)
        urine_creatinine_unit: str,  # Unit of urine creatinine (e.g., "mg/dL")
    ) -> str:
        r"""Calculate the patient's Fractional Excretion of Sodium (FEna) and
        generate a detailed explanatory text.

        Args:
            sodium_value (float): The numeric value of serum sodium.
            sodium_unit (str): The unit of serum sodium, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
            creatinine_value (float): The numeric value of serum creatinine.
            creatinine_unit (str): The unit of serum creatinine, one of:
                - "mg/dL" for milligrams per deciliter
                - "umol/L" for micromoles per liter
            urine_sodium_value (float): The numeric value of urine sodium.
            urine_sodium_unit (str): The unit of urine sodium, one of:
                - "mmol/L" for millimoles per liter
                - "mEq/L" for milliequivalents per liter
            urine_creatinine_value (float): The numeric
                value of urine creatinine.
            urine_creatinine_unit (str): The unit of urine creatinine, one of:
                - "mg/dL" for milligrams per deciliter
                - "umol/L" for micromoles per liter

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "FEna percentage (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_fena_explanation` function is used
                to calculate FEna.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
            - All input values are converted to standard units
                before calculation.
        """
        urine_sodium_data = (float(urine_sodium_value), str(urine_sodium_unit))
        # Construct the input variables dictionary
        input_variables = {
            "sodium": (float(sodium_value), str(sodium_unit)),
            "creatinine": (float(creatinine_value), str(creatinine_unit)),
            "urine_sodium": urine_sodium_data,
            "urine_creatinine": (
                float(urine_creatinine_value),
                str(urine_creatinine_unit),
            ),
        }

        from medcalc.compute_fena import (
            compute_fena_explanation,
        )

        try:
            # Call the FEna calculation function
            result = compute_fena_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_fena_explanation", e)

    def framingham_risk_score(
        self,
        age_value: float,  # Numeric part of age (e.g., 45)
        age_unit: str,  # Unit of age ("years")
        sex: str,  # Gender ("male"/"female")
        sys_bp_value: float,  # Systolic BP value (e.g., 120)
        sys_bp_unit: str,  # Systolic BP unit ("mm Hg")
        dia_bp_value: float,  # Diastolic BP value (e.g., 80)
        dia_bp_unit: str,  # Diastolic BP unit ("mm Hg")
        smoker: bool,  # Whether patient smokes (True/False)
        bp_medicine: bool,  # Whether on BP meds (True/False)
        total_chol_value: float,  # Total cholesterol value
        total_chol_unit: str,  # Total cholesterol unit
        hdl_chol_value: float,  # HDL cholesterol value
        hdl_chol_unit: str,  # HDL cholesterol unit
    ) -> str:
        r"""Calculate the patient's Framingham Risk Score and
        generate a detailed explanatory text for 10-year cardiovascular
        disease risk.

        Args:
            age_value (float): Numeric value of patient's age.
            age_unit (str): Unit of age, must be "years".
            sex (str): Patient's gender, one of:
                - "Male" for male
                - "Female" for female
            sys_bp_value (float): Numeric value of systolic blood pressure.
            sys_bp_unit (str): Unit of systolic BP, must be "mm Hg".
            dia_bp_value (float): Numeric value of diastolic blood pressure.
            dia_bp_unit (str): Unit of diastolic BP, must be "mm Hg".
            smoker (bool): Whether patient is a smoker.
            bp_medicine (bool): Whether patient takes BP medication.
            total_chol_value (float): Numeric value of total cholesterol.
            total_chol_unit (str): Unit of total cholesterol (e.g., "mg/dL").
            hdl_chol_value (float): Numeric value of HDL cholesterol.
            hdl_chol_unit (str): Unit of HDL cholesterol (e.g., "mg/dL").

        Returns:
            str: A JSON string containing calculation process and result:
                {
                    "rationale": "Detailed calculation explanation",
                    "final_answer": "10-year CVD risk percentage (string)"
                }
                If exception occurs, returns error message
                    from handle_exception.

        Notes:
            - Uses framingham_risk_score_explanation for core calculation.
            - Returns JSON string using json.dumps.
            - If gender not "Male" or "Female", will return error.
        """
        # Construct input parameters dictionary
        input_variables = {
            "sex": str(sex),
            "age": (float(age_value), str(age_unit)),
            "sys_bp": (float(sys_bp_value), str(sys_bp_unit)),
            "dia_bp": (float(dia_bp_value), str(dia_bp_unit)),
            "smoker": bool(smoker),
            "bp_medicine": bool(bp_medicine),
            "total_cholestrol": (
                float(total_chol_value),
                str(total_chol_unit),
            ),
            "hdl_cholestrol": (
                float(hdl_chol_value),
                str(hdl_chol_unit),
            ),
        }

        from medcalc.framingham_risk_score import (
            framingham_risk_score_explanation,
        )

        try:
            # Call the Framingham risk calculation function
            result = framingham_risk_score_explanation(input_variables)

            # Return result as JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            # Catch exceptions and return error message
            return self.handle_exception("framingham_risk_score", e)

    def glasgow_bleeding_score(
        self,
        hemoglobin_value: float,
        hemoglobin_unit: str,
        bun_value: float,
        bun_unit: str,
        sys_bp_value: float,
        sys_bp_unit: str,
        sex: str,
        heart_rate_value: float,
        heart_rate_unit: str,
        melena_present: bool = False,
        syncope: bool = False,
        hepatic_disease_history: bool = False,
        cardiac_failure: bool = False,
        platelet_count_value: Optional[float] = None,
        platelet_count_unit: Optional[str] = None,
    ) -> str:
        r"""Calculate the patient's Glasgow Bleeding Score (GBS) and generate a
        detailed explanatory text.
        Args:
            hemoglobin_value (float): Numeric value of hemoglobin level.
            hemoglobin_unit (str): Unit of hemoglobin ("g/dL" or others).
            bun_value (float): Numeric value of BUN level.
            bun_unit (str): Unit of BUN ("mg/dL" or others).
            sys_bp_value (float): Numeric value of systolic blood pressure.
            sys_bp_unit (str): Unit of blood pressure ("mm Hg" or others).
            sex (str): Patient's gender ("Male" or "Female").
            heart_rate_value (float): Numeric value of heart rate.
            heart_rate_unit (str): Unit of heart rate ("beats per minute").
            melena_present (bool): Presence of melena (default: False).
            syncope (bool): Recent syncope (default: False).
            hepatic_disease_history (bool):
                History of hepatic disease (default: False).
            cardiac_failure (bool):
                Presence of cardiac failure (default: False).
            platelet_count_value (float, optional):
                Numeric value of platelet count.
            platelet_count_unit (str, optional): Unit of platelet count.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as:
                {
                    "rationale":
                        "Detailed calculation process and explanation",
                    "final_answer": "Glasgow Bleeding Score (string format)"
                }
                If an exception occurs, returns an error message generated by
                the `handle_exception` method.

        Notes:
            - The `glasgow_bleeding_score_explanation` function is used for the
                actual calculation.
            - The `json.dumps` function
                serializes the result into a JSON string.
            - Optional parameters default to False if not provided.
        """
        input_variables = {
            "hemoglobin": (float(hemoglobin_value), str(hemoglobin_unit)),
            "bun": (float(bun_value), str(bun_unit)),
            "sys_bp": (float(sys_bp_value), str(sys_bp_unit)),
            "sex": str(sex),
            "heart_rate": (float(heart_rate_value), str(heart_rate_unit)),
            "melena_present": bool(melena_present),
            "syncope": bool(syncope),
            "hepatic_disease_history": bool(hepatic_disease_history),
            "cardiac_failure": bool(cardiac_failure),
        }

        if platelet_count_value is not None:
            input_variables["platelet_count"] = (
                float(platelet_count_value),
                str(platelet_count_unit) if platelet_count_unit else None,
            )

        try:
            from medcalc.glasgow_bleeding_score import (
                glasgow_bleeding_score_explanation,
            )

            result = glasgow_bleeding_score_explanation(input_variables)

            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            return self.handle_exception("glasgow_bleeding_score", e)

    def has_bled_score(
        self,
        age_value: float,  # Numeric part of age (e.g., 45)
        age_unit: str,  # Unit of age ("months" or "years")
        hypertension: bool,  # Hypertension status
        liver_disease: bool,  # Liver disease status
        renal_disease: bool,  # Renal disease status
        stroke: bool,  # Stroke history
        prior_bleeding: bool,  # Prior major bleeding
        labile_inr: bool,  # Labile INR status
        bleeding_meds: bool,  # Medications causing bleeding
        alcohol_drinks: int,  # Number of alcoholic drinks/week
    ) -> str:
        r"""Calculate the patient's HAS-BLED Score and generate a detailed
        explanatory text.

        Args:
            age_value (float): The numeric value of the patient's age.
            age_unit (str): The unit of the patient's age, one of:
                - "months" for months.
                - "years" for years.
            hypertension (bool): Hypertension status (>160 mmHg systolic).
            liver_disease (bool): Liver disease (Cirrhosis or bilirubin > 2x
                normal with AST/ALT/AP > 3x normal).
            renal_disease (bool): Renal disease (Dialysis, transplant,
                Cr >2.26 mg/dL or > 200 µmol/L).
            stroke (bool): Stroke history.
            prior_bleeding (bool): Prior major bleeding or predisposition.
            labile_inr (bool): Labile INR (time in therapeutic range < 60%).
            bleeding_meds (bool): Medications predisposing to bleeding.
            alcohol_drinks (int): Number of alcoholic drinks per week.

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "HAS-BLED Score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `compute_has_bled_score_explanation` function is used for the
                actual calculation.
            - The `json.dumps` function is used to serialize the result.
        """
        # Construct the input variables dictionary
        input_variables = {
            "age": (float(age_value), str(age_unit)),
            "hypertension": bool(hypertension),
            "liver_disease_has_bled": bool(liver_disease),
            "renal_disease_has_bled": bool(renal_disease),
            "stroke": bool(stroke),
            "prior_bleeding": bool(prior_bleeding),
            "labile_inr": bool(labile_inr),
            "medications_for_bleeding": bool(bleeding_meds),
            "alcoholic_drinks": int(alcohol_drinks),
        }

        try:
            from medcalc.has_bled_score import (
                compute_has_bled_score_explanation,
            )

            # Call the HAS-BLED calculation function
            result = compute_has_bled_score_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("compute_has_bled_score", e)

    def meldna(
        self,
        creatinine_value: float,  # Numeric part of creatinine (e.g., 1.0)
        creatinine_unit: str,  # Unit of creatinine (e.g., "mg/dL")
        bilirubin_value: float,  # Numeric part of bilirubin (e.g., 2.8)
        bilirubin_unit: str,  # Unit of bilirubin (e.g., "mg/dL")
        inr_value: float,  # International normalized ratio value
        sodium_value: float,  # Numeric part of sodium (e.g., 139.0)
        sodium_unit: str,  # Unit of sodium (e.g., "mEq/L")
        dialysis_twice: bool = False,  # Dialysis twice in past week
        cvvhd: bool = False,  # Continuous veno-venous hemodialysis
    ) -> str:
        r"""Calculate the patient's MELD-Na score and generate
        detailed explanation.

        Args:
            creatinine_value (float): The numeric value of creatinine.
            creatinine_unit (str): Unit of creatinine, one of:
                - "mg/dL" for milligrams per deciliter
                - "μmol/L" for micromoles per liter
            bilirubin_value (float): The numeric value of bilirubin.
            bilirubin_unit (str): Unit of bilirubin, one of:
                - "mg/dL" for milligrams per deciliter
                - "μmol/L" for micromoles per liter
            inr_value (float): The international normalized ratio value.
            sodium_value (float): The numeric value of sodium.
            sodium_unit (str): Unit of sodium, one of:
                - "mEq/L" for milliequivalents per liter
                - "mmol/L" for millimoles per liter
            dialysis_twice (bool): If patient had dialysis twice in past week.
                Defaults to False.
            cvvhd (bool): If patient had continuous veno-venous hemodialysis.
                Defaults to False.

        Returns:
            str: A JSON string containing calculation process and result,
                formatted as:
                {
                    "rationale": "Detailed calculation process explanation",
                    "final_answer": "MELD-Na score (string format)"
                }
                If exception occurs, returns error message
                    from handle_exception.

        Notes:
            - The compute_meldna_explanation function is used for calculation.
            - The json.dumps function serializes result into JSON string.
            - Sodium values <125 are set to 125, >137 are set to 137.
            - MELD-Na score is capped at 40.
        """
        input_variables = {
            "creatinine": (float(creatinine_value), str(creatinine_unit)),
            "bilirubin": (float(bilirubin_value), str(bilirubin_unit)),
            "inr": float(inr_value),
            "sodium": [float(sodium_value), str(sodium_unit)],
            "dialysis_twice": bool(dialysis_twice),
            "cvvhd": bool(cvvhd),
        }

        from medcalc.meldna import (
            compute_meldna_explanation,
        )

        try:
            result = compute_meldna_explanation(input_variables)
            return json.dumps(
                {
                    "rationale": result["Explanation"],
                    "final_answer": str(result["Answer"]),
                }
            )
        except Exception as e:
            return self.handle_exception("compute_meldna_explanation", e)

    def psi_score(
        self,
        sex: str,  # Gender ("male"/"female")
        age_value: float,  # Numeric part of age
        age_unit: str,  # Unit of age ("years")
        temperature_value: float,  # Numeric part of temperature
        temperature_unit: str,  # Unit of temperature
        heart_rate_value: float,  # Numeric part of heart rate
        heart_rate_unit: str,  # Unit of heart rate
        pH: float,  # Blood pH value
        respiratory_rate_value: float,  # Numeric part of respiratory rate
        respiratory_rate_unit: str,  # Unit of respiratory rate
        sys_bp_value: float,  # Numeric part of systolic blood pressure
        sys_bp_unit: str,  # Unit of systolic blood pressure
        bun_value: float,  # Numeric part of BUN
        bun_unit: str,  # Unit of BUN
        sodium_value: float,  # Numeric part of sodium
        sodium_unit: str,  # Unit of sodium
        glucose_value: float,  # Numeric part of glucose
        glucose_unit: str,  # Unit of glucose
        hemocratit_value: float,  # Numeric part of hemocratit
        hemocratit_unit: str,  # Unit of hemocratit
        partial_pressure_oxygen_value: float,  # Numeric part of pO2
        partial_pressure_oxygen_unit: str,  # Unit of pO2
        nursing_home_resident: bool = False,  # Is nursing home resident
        neoplastic_disease: bool = False,  # Has neoplastic disease
        liver_disease: bool = False,  # Has liver disease
        chf: bool = False,  # Has congestive heart failure
        cerebrovascular_disease: bool = False,  # Has cerebrovascular disease
        renal_disease: bool = False,  # Has renal disease
        altered_mental_status: bool = False,  # Has altered mental status
        pleural_effusion: bool = False,  # Has pleural effusion
    ) -> str:
        r"""Calculate the patient's Pneumonia Severity Index (PSI) score and
        generate a detailed explanatory text.

        Args:
            sex (str): The patient's gender, one of:
                - "male" for male
                - "female" for female
            age_value (float): The numeric value of the patient's age
            age_unit (str): The unit of the patient's age ("years")
            temperature_value (float): The numeric value of temperature
            temperature_unit (str): The unit of temperature
            heart_rate_value (float): The numeric value of heart rate
            heart_rate_unit (str): The unit of heart rate
            pH (float): The patient's blood pH value
            respiratory_rate_value (float): The numeric value of
                respiratory rate
            respiratory_rate_unit (str): The unit of respiratory rate
            sys_bp_value (float): The numeric value of systolic blood pressure
            sys_bp_unit (str): The unit of systolic blood pressure
            bun_value (float): The numeric value of BUN (blood urea nitrogen)
            bun_unit (str): The unit of BUN
            sodium_value (float): The numeric value of sodium
            sodium_unit (str): The unit of sodium
            glucose_value (float): The numeric value of glucose
            glucose_unit (str): The unit of glucose
            hemocratit_value (float): The numeric value of hemocratit
            hemocratit_unit (str): The unit of hemocratit
            partial_pressure_oxygen_value (float): The numeric value of pO2
            partial_pressure_oxygen_unit (str): The unit of pO2
            nursing_home_resident (bool): Whether patient is
                nursing home resident
            neoplastic_disease (bool): Whether patient has neoplastic disease
            liver_disease (bool): Whether patient has liver disease
            chf (bool): Whether patient has congestive heart failure
            cerebrovascular_disease (bool): Whether patient has cerebrovascular
                disease
            renal_disease (bool): Whether patient has renal disease
            altered_mental_status (bool): Whether patient has
                altered mental status
            pleural_effusion (bool): Whether patient has pleural effusion

        Returns:
            str: A JSON string containing the calculation process and result,
                formatted as follows:
                {
                    "rationale": "Detailed calculation process and explanatory
                        text",
                    "final_answer": "PSI score (string format)"
                }
                If an exception occurs, return an error message generated by
                    the `handle_exception` method.

        Notes:
            - The `psi_score_explanation` function is used to calculate the PSI
                score.
            - The `json.dumps` function is used to serialize the result into a
                JSON string.
            - If the input gender is not "male" or "female", the function will
                still calculate the score but with appropriate adjustments.
        """
        # Construct the input variables dictionary

        respiratory_rate_data = (
            float(respiratory_rate_value),
            str(respiratory_rate_unit),
        )
        partial_pressure_oxygen_data = (
            float(partial_pressure_oxygen_value),
            str(partial_pressure_oxygen_unit),
        )
        input_variables = {
            "sex": str(sex),
            "age": (float(age_value), str(age_unit)),
            "temperature": (float(temperature_value), str(temperature_unit)),
            "heart_rate": (float(heart_rate_value), str(heart_rate_unit)),
            "pH": float(pH),
            "respiratory_rate": respiratory_rate_data,
            "sys_bp": (float(sys_bp_value), str(sys_bp_unit)),
            "bun": (float(bun_value), str(bun_unit)),
            "sodium": (float(sodium_value), str(sodium_unit)),
            "glucose": (float(glucose_value), str(glucose_unit)),
            "hemocratit": (float(hemocratit_value), str(hemocratit_unit)),
            "partial_pressure_oxygen": partial_pressure_oxygen_data,
            "nursing_home_resident": bool(nursing_home_resident),
            "neoplastic_disease": bool(neoplastic_disease),
            "liver_disease": bool(liver_disease),
            "chf": bool(chf),
            "cerebrovascular_disease": bool(cerebrovascular_disease),
            "renal_disease": bool(renal_disease),
            "altered_mental_status": bool(altered_mental_status),
            "pleural_effusion": bool(pleural_effusion),
        }

        from medcalc.psi_score import (
            psi_score_explanation,
        )

        try:
            # Call the PSI score calculation function
            result = psi_score_explanation(input_variables)

            # Return the result as a JSON string
            return json.dumps(
                {
                    "rationale": result["Explanation"],  # Detailed explanation
                    "final_answer": str(
                        result["Answer"]
                    ),  # Final answer (string format)
                }
            )

        except Exception as e:
            # Catch exceptions and return an error message
            return self.handle_exception("psi_score_explanation", e)

    def handle_exception(self, func_name: str, error: Exception) -> str:
        r"""Handles exceptions by logging the error and returning
            a standardized error message.

        Args:
            func_name (str): The name of the function where
                the exception occurred.
            error (Exception): The exception object containing
                details about the error.

        Returns:
            str: A JSON string containing the following fields:
                - "status" (str): Always set to `"error"`.
                - "message" (str): A human-readable description of the error.
        """
        logger.error(f"Error in {func_name}: {error}")
        return json.dumps(
            {"status": "error", "message": f"Error in {func_name}: {error}"},
            ensure_ascii=False,
        )

    def get_tools(self) -> List[FunctionTool]:
        r"""Exposes the tool's methods to the agent framework.

        Returns:
            List[FunctionTool]: A list of `FunctionTool` objects representing
                the toolkit's methods, making them accessible to the agent.
        """
        return [
            FunctionTool(self.adjusted_body_weight),
            FunctionTool(self.anion_gap),
            FunctionTool(self.bmi_calculator),
            FunctionTool(self.bsa_calculator),
            FunctionTool(self.calcium_correction),
            FunctionTool(self.delta_gap),
            FunctionTool(self.conception_date),
            FunctionTool(self.gestational_age),
            FunctionTool(self.feverpain),
            FunctionTool(self.heart_score),
            FunctionTool(self.homa_ir),
            FunctionTool(self.ideal_body_weight),
            FunctionTool(self.mdrd_gfr),
            FunctionTool(self.mean_arterial_pressure),
            FunctionTool(self.sOsm),
            FunctionTool(self.target_weight),
            FunctionTool(self.creatinine_clearance),
            FunctionTool(self.wells_criteria_pe),
            FunctionTool(self.ldl_calculated),
            FunctionTool(self.albumin_corrected_anion),
            FunctionTool(self.albumin_corrected_delta_gap),
            FunctionTool(self.albumin_delta_ratio),
            FunctionTool(self.estimated_due_date),
            FunctionTool(self.free_water_deficit),
            FunctionTool(self.glasgow_coma_score),
            FunctionTool(self.qt_calculator_bazett),
            FunctionTool(self.qt_calculator_framingham),
            FunctionTool(self.qt_calculator_fredericia),
            FunctionTool(self.qt_calculator_hodges),
            FunctionTool(self.qt_calculator_rautaharju),
            FunctionTool(self.steroid_conversion),
            FunctionTool(self.wells_criteria_dvt),
            FunctionTool(self.cci),
            FunctionTool(self.cha2ds2_vasc_score),
            FunctionTool(self.child_pugh_score),
            FunctionTool(self.ckd_epi_2021_creatinine),
            FunctionTool(self.sofa),
            FunctionTool(self.centor_score),
            FunctionTool(self.curb_65),
            FunctionTool(self.fibrosis_4),
            FunctionTool(self.maintenance_fluid_calc),
            FunctionTool(self.mme),
            FunctionTool(self.perc_rule),
            FunctionTool(self.sirs_criteria),
            FunctionTool(self.sch),
            FunctionTool(self.apache_ii),
            FunctionTool(self.caprini_score),
            FunctionTool(self.cardiac_risk_index),
            FunctionTool(self.compute_fena),
            FunctionTool(self.framingham_risk_score),
            FunctionTool(self.glasgow_bleeding_score),
            FunctionTool(self.has_bled_score),
            FunctionTool(self.meldna),
            FunctionTool(self.psi_score),
        ]
