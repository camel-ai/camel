"""
Auto-generated ARIA snapshot injection script.
This file contains the bundled JavaScript code extracted from Playwright's _snapshotForAI implementation.

License: Apache 2.0 (same as Playwright)
"""

# The bundled JavaScript code that initializes __ariaSnapshot global
ARIA_SNAPSHOT_BUNDLE = """"use strict";\nvar __ariaSnapshotModule = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === "object" || typeof from === "function") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n  // index.ts\n  var aria_snapshot_exports = {};\n  __export(aria_snapshot_exports, {\n    clickByRef: () => clickByRef,\n    getElementByRef: () => getElementByRef,\n    snapshotForAI: () => snapshotForAI,\n    typeByRef: () => typeByRef\n  });\n\n  // ariaSnapshotTypes.ts\n  function ariaNodesEqual(a, b) {\n    if (a.role !== b.role || a.name !== b.name)\n      return false;\n    if (!ariaPropsEqual(a, b) || hasPointerCursor(a) !== hasPointerCursor(b))\n      return false;\n    const aKeys = Object.keys(a.props);\n    const bKeys = Object.keys(b.props);\n    return aKeys.length === bKeys.length && aKeys.every((k) => a.props[k] === b.props[k]);\n  }\n  function hasPointerCursor(ariaNode) {\n    return ariaNode.box.cursor === "pointer";\n  }\n  function ariaPropsEqual(a, b) {\n    return a.active === b.active && a.checked === b.checked && a.disabled === b.disabled && a.expanded === b.expanded && a.selected === b.selected && a.level === b.level && a.pressed === b.pressed;\n  }\n\n  // stringUtils.ts\n  var normalizedWhitespaceCache;\n  function normalizeWhiteSpace(text) {\n    let result = normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.get(text);\n    if (result === void 0) {\n      result = text.replace(/[\\u200b\\u00ad]/g, "").trim().replace(/\\s+/g, " ");\n      normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.set(text, result);\n    }\n    return result;\n  }\n  function escapeRegExp(s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n  }\n  function longestCommonSubstring(s1, s2) {\n    const n = s1.length;\n    const m = s2.length;\n    let maxLen = 0;\n    let endingIndex = 0;\n    const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));\n    for (let i = 1; i <= n; i++) {\n      for (let j = 1; j <= m; j++) {\n        if (s1[i - 1] === s2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n          if (dp[i][j] > maxLen) {\n            maxLen = dp[i][j];\n            endingIndex = i;\n          }\n        }\n      }\n    }\n    return s1.slice(endingIndex - maxLen, endingIndex);\n  }\n  var ansiRegex = new RegExp("([\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~])))", "g");\n\n  // yaml.ts\n  function yamlEscapeKeyIfNeeded(str) {\n    if (!yamlStringNeedsQuotes(str))\n      return str;\n    return `'` + str.replace(/'/g, `''`) + `'`;\n  }\n  function yamlEscapeValueIfNeeded(str) {\n    if (!yamlStringNeedsQuotes(str))\n      return str;\n    return '"' + str.replace(/[\\\\"\\x00-\\x1f\\x7f-\\x9f]/g, (c) => {\n      switch (c) {\n        case "\\\\":\n          return "\\\\\\\\";\n        case '"':\n          return '\\\\"';\n        case "\\b":\n          return "\\\\b";\n        case "\\f":\n          return "\\\\f";\n        case "\\n":\n          return "\\\\n";\n        case "\\r":\n          return "\\\\r";\n        case "	":\n          return "\\\\t";\n        default:\n          const code = c.charCodeAt(0);\n          return "\\\\x" + code.toString(16).padStart(2, "0");\n      }\n    }) + '"';\n  }\n  function yamlStringNeedsQuotes(str) {\n    if (str.length === 0)\n      return true;\n    if (/^\\s|\\s$/.test(str))\n      return true;\n    if (/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f-\\x9f]/.test(str))\n      return true;\n    if (/^-/.test(str))\n      return true;\n    if (/[\\n:](\\s|$)/.test(str))\n      return true;\n    if (/\\s#/.test(str))\n      return true;\n    if (/[\\n\\r]/.test(str))\n      return true;\n    if (/^[&*\\],?!>|@"'#%]/.test(str))\n      return true;\n    if (/[{}`]/.test(str))\n      return true;\n    if (/^\\[/.test(str))\n      return true;\n    if (!isNaN(Number(str)) || ["y", "n", "yes", "no", "true", "false", "on", "off", "null"].includes(str.toLowerCase()))\n      return true;\n    return false;\n  }\n\n  // domUtils.ts\n  var globalOptions = {};\n  function parentElementOrShadowHost(element) {\n    if (element.parentElement)\n      return element.parentElement;\n    if (!element.parentNode)\n      return;\n    if (element.parentNode.nodeType === 11 && element.parentNode.host)\n      return element.parentNode.host;\n  }\n  function enclosingShadowRootOrDocument(element) {\n    let node = element;\n    while (node.parentNode)\n      node = node.parentNode;\n    if (node.nodeType === 11 || node.nodeType === 9)\n      return node;\n  }\n  function enclosingShadowHost(element) {\n    while (element.parentElement)\n      element = element.parentElement;\n    return parentElementOrShadowHost(element);\n  }\n  function closestCrossShadow(element, css, scope) {\n    while (element) {\n      const closest = element.closest(css);\n      if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\n        return;\n      if (closest)\n        return closest;\n      element = enclosingShadowHost(element);\n    }\n  }\n  function getElementComputedStyle(element, pseudo) {\n    const cache = pseudo === "::before" ? cacheStyleBefore : pseudo === "::after" ? cacheStyleAfter : cacheStyle;\n    if (cache && cache.has(element))\n      return cache.get(element);\n    const style = element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n    cache == null ? void 0 : cache.set(element, style);\n    return style;\n  }\n  function isElementStyleVisibilityVisible(element, style) {\n    style = style ?? getElementComputedStyle(element);\n    if (!style)\n      return true;\n    if (Element.prototype.checkVisibility && globalOptions.browserNameForWorkarounds !== "webkit") {\n      if (!element.checkVisibility())\n        return false;\n    } else {\n      const detailsOrSummary = element.closest("details,summary");\n      if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === "DETAILS" && !detailsOrSummary.open)\n        return false;\n    }\n    if (style.visibility !== "visible")\n      return false;\n    return true;\n  }\n  function computeBox(element) {\n    const style = getElementComputedStyle(element);\n    if (!style)\n      return { visible: true, inline: false };\n    const cursor = style.cursor;\n    if (style.display === "contents") {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === 1 && isElementVisible(child))\n          return { visible: true, inline: false, cursor };\n        if (child.nodeType === 3 && isVisibleTextNode(child))\n          return { visible: true, inline: true, cursor };\n      }\n      return { visible: false, inline: false, cursor };\n    }\n    if (!isElementStyleVisibilityVisible(element, style))\n      return { cursor, visible: false, inline: false };\n    const rect = element.getBoundingClientRect();\n    return { cursor, visible: rect.width > 0 && rect.height > 0, inline: style.display === "inline" };\n  }\n  function isElementVisible(element) {\n    return computeBox(element).visible;\n  }\n  function isVisibleTextNode(node) {\n    const range = node.ownerDocument.createRange();\n    range.selectNode(node);\n    const rect = range.getBoundingClientRect();\n    return rect.width > 0 && rect.height > 0;\n  }\n  function elementSafeTagName(element) {\n    const tagName = element.tagName;\n    if (typeof tagName === "string")\n      return tagName.toUpperCase();\n    if (element instanceof HTMLFormElement)\n      return "FORM";\n    return element.tagName.toUpperCase();\n  }\n  var cacheStyle;\n  var cacheStyleBefore;\n  var cacheStyleAfter;\n  var cachesCounter = 0;\n  function beginDOMCaches() {\n    ++cachesCounter;\n    cacheStyle ??= /* @__PURE__ */ new Map();\n    cacheStyleBefore ??= /* @__PURE__ */ new Map();\n    cacheStyleAfter ??= /* @__PURE__ */ new Map();\n  }\n  function endDOMCaches() {\n    if (!--cachesCounter) {\n      cacheStyle = void 0;\n      cacheStyleBefore = void 0;\n      cacheStyleAfter = void 0;\n    }\n  }\n\n  // cssTokenizer.ts\n  var between = function(num, first, last) {\n    return num >= first && num <= last;\n  };\n  function digit(code) {\n    return between(code, 48, 57);\n  }\n  function hexdigit(code) {\n    return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n  }\n  function uppercaseletter(code) {\n    return between(code, 65, 90);\n  }\n  function lowercaseletter(code) {\n    return between(code, 97, 122);\n  }\n  function letter(code) {\n    return uppercaseletter(code) || lowercaseletter(code);\n  }\n  function nonascii(code) {\n    return code >= 128;\n  }\n  function namestartchar(code) {\n    return letter(code) || nonascii(code) || code === 95;\n  }\n  function namechar(code) {\n    return namestartchar(code) || digit(code) || code === 45;\n  }\n  function nonprintable(code) {\n    return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n  }\n  function newline(code) {\n    return code === 10;\n  }\n  function whitespace(code) {\n    return newline(code) || code === 9 || code === 32;\n  }\n  var maximumallowedcodepoint = 1114111;\n  var InvalidCharacterError = class extends Error {\n    constructor(message) {\n      super(message);\n      this.name = "InvalidCharacterError";\n    }\n  };\n  function preprocess(str) {\n    const codepoints = [];\n    for (let i = 0; i < str.length; i++) {\n      let code = str.charCodeAt(i);\n      if (code === 13 && str.charCodeAt(i + 1) === 10) {\n        code = 10;\n        i++;\n      }\n      if (code === 13 || code === 12)\n        code = 10;\n      if (code === 0)\n        code = 65533;\n      if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n        const lead = code - 55296;\n        const trail = str.charCodeAt(i + 1) - 56320;\n        code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n        i++;\n      }\n      codepoints.push(code);\n    }\n    return codepoints;\n  }\n  function stringFromCode(code) {\n    if (code <= 65535)\n      return String.fromCharCode(code);\n    code -= Math.pow(2, 16);\n    const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n    const trail = code % Math.pow(2, 10) + 56320;\n    return String.fromCharCode(lead) + String.fromCharCode(trail);\n  }\n  function tokenize(str1) {\n    const str = preprocess(str1);\n    let i = -1;\n    const tokens = [];\n    let code;\n    let line = 0;\n    let column = 0;\n    let lastLineLength = 0;\n    const incrLineno = function() {\n      line += 1;\n      lastLineLength = column;\n      column = 0;\n    };\n    const locStart = { line, column };\n    const codepoint = function(i2) {\n      if (i2 >= str.length)\n        return -1;\n      return str[i2];\n    };\n    const next = function(num) {\n      if (num === void 0)\n        num = 1;\n      if (num > 3)\n        throw "Spec Error: no more than three codepoints of lookahead.";\n      return codepoint(i + num);\n    };\n    const consume = function(num) {\n      if (num === void 0)\n        num = 1;\n      i += num;\n      code = codepoint(i);\n      if (newline(code))\n        incrLineno();\n      else\n        column += num;\n      return true;\n    };\n    const reconsume = function() {\n      i -= 1;\n      if (newline(code)) {\n        line -= 1;\n        column = lastLineLength;\n      } else {\n        column -= 1;\n      }\n      locStart.line = line;\n      locStart.column = column;\n      return true;\n    };\n    const eof = function(codepoint2) {\n      if (codepoint2 === void 0)\n        codepoint2 = code;\n      return codepoint2 === -1;\n    };\n    const donothing = function() {\n    };\n    const parseerror = function() {\n    };\n    const consumeAToken = function() {\n      consumeComments();\n      consume();\n      if (whitespace(code)) {\n        while (whitespace(next()))\n          consume();\n        return new WhitespaceToken();\n      } else if (code === 34) {\n        return consumeAStringToken();\n      } else if (code === 35) {\n        if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n          const token = new HashToken("");\n          if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n            token.type = "id";\n          token.value = consumeAName();\n          return token;\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 36) {\n        if (next() === 61) {\n          consume();\n          return new SuffixMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 39) {\n        return consumeAStringToken();\n      } else if (code === 40) {\n        return new OpenParenToken();\n      } else if (code === 41) {\n        return new CloseParenToken();\n      } else if (code === 42) {\n        if (next() === 61) {\n          consume();\n          return new SubstringMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 43) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 44) {\n        return new CommaToken();\n      } else if (code === 45) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else if (next(1) === 45 && next(2) === 62) {\n          consume(2);\n          return new CDCToken();\n        } else if (startsWithAnIdentifier()) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 46) {\n        if (startsWithANumber()) {\n          reconsume();\n          return consumeANumericToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 58) {\n        return new ColonToken();\n      } else if (code === 59) {\n        return new SemicolonToken();\n      } else if (code === 60) {\n        if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\n          consume(3);\n          return new CDOToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 64) {\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          return new AtKeywordToken(consumeAName());\n        else\n          return new DelimToken(code);\n      } else if (code === 91) {\n        return new OpenSquareToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else {\n          parseerror();\n          return new DelimToken(code);\n        }\n      } else if (code === 93) {\n        return new CloseSquareToken();\n      } else if (code === 94) {\n        if (next() === 61) {\n          consume();\n          return new PrefixMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 123) {\n        return new OpenCurlyToken();\n      } else if (code === 124) {\n        if (next() === 61) {\n          consume();\n          return new DashMatchToken();\n        } else if (next() === 124) {\n          consume();\n          return new ColumnToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (code === 125) {\n        return new CloseCurlyToken();\n      } else if (code === 126) {\n        if (next() === 61) {\n          consume();\n          return new IncludeMatchToken();\n        } else {\n          return new DelimToken(code);\n        }\n      } else if (digit(code)) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (namestartchar(code)) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else if (eof()) {\n        return new EOFToken();\n      } else {\n        return new DelimToken(code);\n      }\n    };\n    const consumeComments = function() {\n      while (next(1) === 47 && next(2) === 42) {\n        consume(2);\n        while (true) {\n          consume();\n          if (code === 42 && next() === 47) {\n            consume();\n            break;\n          } else if (eof()) {\n            parseerror();\n            return;\n          }\n        }\n      }\n    };\n    const consumeANumericToken = function() {\n      const num = consumeANumber();\n      if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n        const token = new DimensionToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        token.type = num.type;\n        token.unit = consumeAName();\n        return token;\n      } else if (next() === 37) {\n        consume();\n        const token = new PercentageToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        return token;\n      } else {\n        const token = new NumberToken();\n        token.value = num.value;\n        token.repr = num.repr;\n        token.type = num.type;\n        return token;\n      }\n    };\n    const consumeAnIdentlikeToken = function() {\n      const str2 = consumeAName();\n      if (str2.toLowerCase() === "url" && next() === 40) {\n        consume();\n        while (whitespace(next(1)) && whitespace(next(2)))\n          consume();\n        if (next() === 34 || next() === 39)\n          return new FunctionToken(str2);\n        else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n          return new FunctionToken(str2);\n        else\n          return consumeAURLToken();\n      } else if (next() === 40) {\n        consume();\n        return new FunctionToken(str2);\n      } else {\n        return new IdentToken(str2);\n      }\n    };\n    const consumeAStringToken = function(endingCodePoint) {\n      if (endingCodePoint === void 0)\n        endingCodePoint = code;\n      let string = "";\n      while (consume()) {\n        if (code === endingCodePoint || eof()) {\n          return new StringToken(string);\n        } else if (newline(code)) {\n          parseerror();\n          reconsume();\n          return new BadStringToken();\n        } else if (code === 92) {\n          if (eof(next()))\n            donothing();\n          else if (newline(next()))\n            consume();\n          else\n            string += stringFromCode(consumeEscape());\n        } else {\n          string += stringFromCode(code);\n        }\n      }\n      throw new Error("Internal error");\n    };\n    const consumeAURLToken = function() {\n      const token = new URLToken("");\n      while (whitespace(next()))\n        consume();\n      if (eof(next()))\n        return token;\n      while (consume()) {\n        if (code === 41 || eof()) {\n          return token;\n        } else if (whitespace(code)) {\n          while (whitespace(next()))\n            consume();\n          if (next() === 41 || eof(next())) {\n            consume();\n            return token;\n          } else {\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken();\n          }\n        } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        } else if (code === 92) {\n          if (startsWithAValidEscape()) {\n            token.value += stringFromCode(consumeEscape());\n          } else {\n            parseerror();\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken();\n          }\n        } else {\n          token.value += stringFromCode(code);\n        }\n      }\n      throw new Error("Internal error");\n    };\n    const consumeEscape = function() {\n      consume();\n      if (hexdigit(code)) {\n        const digits = [code];\n        for (let total = 0; total < 5; total++) {\n          if (hexdigit(next())) {\n            consume();\n            digits.push(code);\n          } else {\n            break;\n          }\n        }\n        if (whitespace(next()))\n          consume();\n        let value = parseInt(digits.map(function(x) {\n          return String.fromCharCode(x);\n        }).join(""), 16);\n        if (value > maximumallowedcodepoint)\n          value = 65533;\n        return value;\n      } else if (eof()) {\n        return 65533;\n      } else {\n        return code;\n      }\n    };\n    const areAValidEscape = function(c1, c2) {\n      if (c1 !== 92)\n        return false;\n      if (newline(c2))\n        return false;\n      return true;\n    };\n    const startsWithAValidEscape = function() {\n      return areAValidEscape(code, next());\n    };\n    const wouldStartAnIdentifier = function(c1, c2, c3) {\n      if (c1 === 45)\n        return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n      else if (namestartchar(c1))\n        return true;\n      else if (c1 === 92)\n        return areAValidEscape(c1, c2);\n      else\n        return false;\n    };\n    const startsWithAnIdentifier = function() {\n      return wouldStartAnIdentifier(code, next(1), next(2));\n    };\n    const wouldStartANumber = function(c1, c2, c3) {\n      if (c1 === 43 || c1 === 45) {\n        if (digit(c2))\n          return true;\n        if (c2 === 46 && digit(c3))\n          return true;\n        return false;\n      } else if (c1 === 46) {\n        if (digit(c2))\n          return true;\n        return false;\n      } else if (digit(c1)) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const startsWithANumber = function() {\n      return wouldStartANumber(code, next(1), next(2));\n    };\n    const consumeAName = function() {\n      let result = "";\n      while (consume()) {\n        if (namechar(code)) {\n          result += stringFromCode(code);\n        } else if (startsWithAValidEscape()) {\n          result += stringFromCode(consumeEscape());\n        } else {\n          reconsume();\n          return result;\n        }\n      }\n      throw new Error("Internal parse error");\n    };\n    const consumeANumber = function() {\n      let repr = "";\n      let type = "integer";\n      if (next() === 43 || next() === 45) {\n        consume();\n        repr += stringFromCode(code);\n      }\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n      if (next(1) === 46 && digit(next(2))) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = "number";\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      }\n      const c1 = next(1), c2 = next(2), c3 = next(3);\n      if ((c1 === 69 || c1 === 101) && digit(c2)) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = "number";\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        consume();\n        repr += stringFromCode(code);\n        type = "number";\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n      }\n      const value = convertAStringToANumber(repr);\n      return { type, value, repr };\n    };\n    const convertAStringToANumber = function(string) {\n      return +string;\n    };\n    const consumeTheRemnantsOfABadURL = function() {\n      while (consume()) {\n        if (code === 41 || eof()) {\n          return;\n        } else if (startsWithAValidEscape()) {\n          consumeEscape();\n          donothing();\n        } else {\n          donothing();\n        }\n      }\n    };\n    let iterationCount = 0;\n    while (!eof(next())) {\n      tokens.push(consumeAToken());\n      iterationCount++;\n      if (iterationCount > str.length * 2)\n        throw new Error("I'm infinite-looping!");\n    }\n    return tokens;\n  }\n  var CSSParserToken = class {\n    constructor() {\n      this.tokenType = "";\n    }\n    toJSON() {\n      return { token: this.tokenType };\n    }\n    toString() {\n      return this.tokenType;\n    }\n    toSource() {\n      return "" + this;\n    }\n  };\n  var BadStringToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "BADSTRING";\n    }\n  };\n  var BadURLToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "BADURL";\n    }\n  };\n  var WhitespaceToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "WHITESPACE";\n    }\n    toString() {\n      return "WS";\n    }\n    toSource() {\n      return " ";\n    }\n  };\n  var CDOToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "CDO";\n    }\n    toSource() {\n      return "<!--";\n    }\n  };\n  var CDCToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "CDC";\n    }\n    toSource() {\n      return "-->";\n    }\n  };\n  var ColonToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = ":";\n    }\n  };\n  var SemicolonToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = ";";\n    }\n  };\n  var CommaToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = ",";\n    }\n  };\n  var GroupingToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.value = "";\n      this.mirror = "";\n    }\n  };\n  var OpenCurlyToken = class extends GroupingToken {\n    constructor() {\n      super();\n      this.tokenType = "{";\n      this.value = "{";\n      this.mirror = "}";\n    }\n  };\n  var CloseCurlyToken = class extends GroupingToken {\n    constructor() {\n      super();\n      this.tokenType = "}";\n      this.value = "}";\n      this.mirror = "{";\n    }\n  };\n  var OpenSquareToken = class extends GroupingToken {\n    constructor() {\n      super();\n      this.tokenType = "[";\n      this.value = "[";\n      this.mirror = "]";\n    }\n  };\n  var CloseSquareToken = class extends GroupingToken {\n    constructor() {\n      super();\n      this.tokenType = "]";\n      this.value = "]";\n      this.mirror = "[";\n    }\n  };\n  var OpenParenToken = class extends GroupingToken {\n    constructor() {\n      super();\n      this.tokenType = "(";\n      this.value = "(";\n      this.mirror = ")";\n    }\n  };\n  var CloseParenToken = class extends GroupingToken {\n    constructor() {\n      super();\n      this.tokenType = ")";\n      this.value = ")";\n      this.mirror = "(";\n    }\n  };\n  var IncludeMatchToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "~=";\n    }\n  };\n  var DashMatchToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "|=";\n    }\n  };\n  var PrefixMatchToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "^=";\n    }\n  };\n  var SuffixMatchToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "$=";\n    }\n  };\n  var SubstringMatchToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "*=";\n    }\n  };\n  var ColumnToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "||";\n    }\n  };\n  var EOFToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.tokenType = "EOF";\n    }\n    toSource() {\n      return "";\n    }\n  };\n  var DelimToken = class extends CSSParserToken {\n    constructor(code) {\n      super();\n      this.tokenType = "DELIM";\n      this.value = "";\n      this.value = stringFromCode(code);\n    }\n    toString() {\n      return "DELIM(" + this.value + ")";\n    }\n    toJSON() {\n      const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      return json;\n    }\n    toSource() {\n      if (this.value === "\\\\")\n        return "\\\\\\n";\n      else\n        return this.value;\n    }\n  };\n  var StringValuedToken = class extends CSSParserToken {\n    constructor() {\n      super(...arguments);\n      this.value = "";\n    }\n    ASCIIMatch(str) {\n      return this.value.toLowerCase() === str.toLowerCase();\n    }\n    toJSON() {\n      const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      return json;\n    }\n  };\n  var IdentToken = class extends StringValuedToken {\n    constructor(val) {\n      super();\n      this.tokenType = "IDENT";\n      this.value = val;\n    }\n    toString() {\n      return "IDENT(" + this.value + ")";\n    }\n    toSource() {\n      return escapeIdent(this.value);\n    }\n  };\n  var FunctionToken = class extends StringValuedToken {\n    constructor(val) {\n      super();\n      this.tokenType = "FUNCTION";\n      this.value = val;\n      this.mirror = ")";\n    }\n    toString() {\n      return "FUNCTION(" + this.value + ")";\n    }\n    toSource() {\n      return escapeIdent(this.value) + "(";\n    }\n  };\n  var AtKeywordToken = class extends StringValuedToken {\n    constructor(val) {\n      super();\n      this.tokenType = "AT-KEYWORD";\n      this.value = val;\n    }\n    toString() {\n      return "AT(" + this.value + ")";\n    }\n    toSource() {\n      return "@" + escapeIdent(this.value);\n    }\n  };\n  var HashToken = class extends StringValuedToken {\n    constructor(val) {\n      super();\n      this.tokenType = "HASH";\n      this.value = val;\n      this.type = "unrestricted";\n    }\n    toString() {\n      return "HASH(" + this.value + ")";\n    }\n    toJSON() {\n      const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.type = this.type;\n      return json;\n    }\n    toSource() {\n      if (this.type === "id")\n        return "#" + escapeIdent(this.value);\n      else\n        return "#" + escapeHash(this.value);\n    }\n  };\n  var StringToken = class extends StringValuedToken {\n    constructor(val) {\n      super();\n      this.tokenType = "STRING";\n      this.value = val;\n    }\n    toString() {\n      return '"' + escapeString(this.value) + '"';\n    }\n  };\n  var URLToken = class extends StringValuedToken {\n    constructor(val) {\n      super();\n      this.tokenType = "URL";\n      this.value = val;\n    }\n    toString() {\n      return "URL(" + this.value + ")";\n    }\n    toSource() {\n      return 'url("' + escapeString(this.value) + '")';\n    }\n  };\n  var NumberToken = class extends CSSParserToken {\n    constructor() {\n      super();\n      this.tokenType = "NUMBER";\n      this.type = "integer";\n      this.repr = "";\n    }\n    toString() {\n      if (this.type === "integer")\n        return "INT(" + this.value + ")";\n      return "NUMBER(" + this.value + ")";\n    }\n    toJSON() {\n      const json = super.toJSON();\n      json.value = this.value;\n      json.type = this.type;\n      json.repr = this.repr;\n      return json;\n    }\n    toSource() {\n      return this.repr;\n    }\n  };\n  var PercentageToken = class extends CSSParserToken {\n    constructor() {\n      super();\n      this.tokenType = "PERCENTAGE";\n      this.repr = "";\n    }\n    toString() {\n      return "PERCENTAGE(" + this.value + ")";\n    }\n    toJSON() {\n      const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.repr = this.repr;\n      return json;\n    }\n    toSource() {\n      return this.repr + "%";\n    }\n  };\n  var DimensionToken = class extends CSSParserToken {\n    constructor() {\n      super();\n      this.tokenType = "DIMENSION";\n      this.type = "integer";\n      this.repr = "";\n      this.unit = "";\n    }\n    toString() {\n      return "DIM(" + this.value + "," + this.unit + ")";\n    }\n    toJSON() {\n      const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.type = this.type;\n      json.repr = this.repr;\n      json.unit = this.unit;\n      return json;\n    }\n    toSource() {\n      const source = this.repr;\n      let unit = escapeIdent(this.unit);\n      if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {\n        unit = "\\\\65 " + unit.slice(1, unit.length);\n      }\n      return source + unit;\n    }\n  };\n  function escapeIdent(string) {\n    string = "" + string;\n    let result = "";\n    const firstcode = string.charCodeAt(0);\n    for (let i = 0; i < string.length; i++) {\n      const code = string.charCodeAt(i);\n      if (code === 0)\n        throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n      if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\n        result += "\\\\" + code.toString(16) + " ";\n      else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n        result += string[i];\n      else\n        result += "\\\\" + string[i];\n    }\n    return result;\n  }\n  function escapeHash(string) {\n    string = "" + string;\n    let result = "";\n    for (let i = 0; i < string.length; i++) {\n      const code = string.charCodeAt(i);\n      if (code === 0)\n        throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n      if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n        result += string[i];\n      else\n        result += "\\\\" + code.toString(16) + " ";\n    }\n    return result;\n  }\n  function escapeString(string) {\n    string = "" + string;\n    let result = "";\n    for (let i = 0; i < string.length; i++) {\n      const code = string.charCodeAt(i);\n      if (code === 0)\n        throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n      if (between(code, 1, 31) || code === 127)\n        result += "\\\\" + code.toString(16) + " ";\n      else if (code === 34 || code === 92)\n        result += "\\\\" + string[i];\n      else\n        result += string[i];\n    }\n    return result;\n  }\n\n  // roleUtils.ts\n  function hasExplicitAccessibleName(e) {\n    return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");\n  }\n  var kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";\n  var kGlobalAriaAttributes = [\n    ["aria-atomic", void 0],\n    ["aria-busy", void 0],\n    ["aria-controls", void 0],\n    ["aria-current", void 0],\n    ["aria-describedby", void 0],\n    ["aria-details", void 0],\n    // Global use deprecated in ARIA 1.2\n    // ['aria-disabled', undefined],\n    ["aria-dropeffect", void 0],\n    // Global use deprecated in ARIA 1.2\n    // ['aria-errormessage', undefined],\n    ["aria-flowto", void 0],\n    ["aria-grabbed", void 0],\n    // Global use deprecated in ARIA 1.2\n    // ['aria-haspopup', undefined],\n    ["aria-hidden", void 0],\n    // Global use deprecated in ARIA 1.2\n    // ['aria-invalid', undefined],\n    ["aria-keyshortcuts", void 0],\n    ["aria-label", ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]],\n    ["aria-labelledby", ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]],\n    ["aria-live", void 0],\n    ["aria-owns", void 0],\n    ["aria-relevant", void 0],\n    ["aria-roledescription", ["generic"]]\n  ];\n  function hasGlobalAriaAttribute(element, forRole) {\n    return kGlobalAriaAttributes.some(([attr, prohibited]) => {\n      return !(prohibited == null ? void 0 : prohibited.includes(forRole || "")) && element.hasAttribute(attr);\n    });\n  }\n  function hasTabIndex(element) {\n    return !Number.isNaN(Number(String(element.getAttribute("tabindex"))));\n  }\n  function isFocusable(element) {\n    return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));\n  }\n  function isNativelyFocusable(element) {\n    const tagName = elementSafeTagName(element);\n    if (["BUTTON", "DETAILS", "SELECT", "TEXTAREA"].includes(tagName))\n      return true;\n    if (tagName === "A" || tagName === "AREA")\n      return element.hasAttribute("href");\n    if (tagName === "INPUT")\n      return !element.hidden;\n    return false;\n  }\n  var kImplicitRoleByTagName = {\n    "A": (e) => {\n      return e.hasAttribute("href") ? "link" : null;\n    },\n    "AREA": (e) => {\n      return e.hasAttribute("href") ? "link" : null;\n    },\n    "ARTICLE": () => "article",\n    "ASIDE": () => "complementary",\n    "BLOCKQUOTE": () => "blockquote",\n    "BUTTON": () => "button",\n    "CAPTION": () => "caption",\n    "CODE": () => "code",\n    "DATALIST": () => "listbox",\n    "DD": () => "definition",\n    "DEL": () => "deletion",\n    "DETAILS": () => "group",\n    "DFN": () => "term",\n    "DIALOG": () => "dialog",\n    "DT": () => "term",\n    "EM": () => "emphasis",\n    "FIELDSET": () => "group",\n    "FIGURE": () => "figure",\n    "FOOTER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",\n    "FORM": (e) => hasExplicitAccessibleName(e) ? "form" : null,\n    "H1": () => "heading",\n    "H2": () => "heading",\n    "H3": () => "heading",\n    "H4": () => "heading",\n    "H5": () => "heading",\n    "H6": () => "heading",\n    "HEADER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",\n    "HR": () => "separator",\n    "HTML": () => "document",\n    "IMG": (e) => e.getAttribute("alt") === "" && !e.getAttribute("title") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? "presentation" : "img",\n    "INPUT": (e) => {\n      const type = e.type.toLowerCase();\n      if (type === "search")\n        return e.hasAttribute("list") ? "combobox" : "searchbox";\n      if (["email", "tel", "text", "url", ""].includes(type)) {\n        const list = getIdRefs(e, e.getAttribute("list"))[0];\n        return list && elementSafeTagName(list) === "DATALIST" ? "combobox" : "textbox";\n      }\n      if (type === "hidden")\n        return null;\n      if (type === "file")\n        return "button";\n      return inputTypeToRole[type] || "textbox";\n    },\n    "INS": () => "insertion",\n    "LI": () => "listitem",\n    "MAIN": () => "main",\n    "MARK": () => "mark",\n    "MATH": () => "math",\n    "MENU": () => "list",\n    "METER": () => "meter",\n    "NAV": () => "navigation",\n    "OL": () => "list",\n    "OPTGROUP": () => "group",\n    "OPTION": () => "option",\n    "OUTPUT": () => "status",\n    "P": () => "paragraph",\n    "PROGRESS": () => "progressbar",\n    "SEARCH": () => "search",\n    "SECTION": (e) => hasExplicitAccessibleName(e) ? "region" : null,\n    "SELECT": (e) => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",\n    "STRONG": () => "strong",\n    "SUB": () => "subscript",\n    "SUP": () => "superscript",\n    // For <svg> we default to Chrome behavior:\n    // - Chrome reports 'img'.\n    // - Firefox reports 'diagram' that is not in official ARIA spec yet.\n    // - Safari reports 'no role', but still computes accessible name.\n    "SVG": () => "img",\n    "TABLE": () => "table",\n    "TBODY": () => "rowgroup",\n    "TD": (e) => {\n      const table = closestCrossShadow(e, "table");\n      const role = table ? getExplicitAriaRole(table) : "";\n      return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n    },\n    "TEXTAREA": () => "textbox",\n    "TFOOT": () => "rowgroup",\n    "TH": (e) => {\n      const scope = e.getAttribute("scope");\n      if (scope === "col" || scope === "colgroup")\n        return "columnheader";\n      if (scope === "row" || scope === "rowgroup")\n        return "rowheader";\n      const nextSibling = e.nextElementSibling;\n      const prevSibling = e.previousElementSibling;\n      const row = !!e.parentElement && elementSafeTagName(e.parentElement) === "TR" ? e.parentElement : void 0;\n      if (!nextSibling && !prevSibling) {\n        if (row) {\n          const table = closestCrossShadow(row, "table");\n          if (table && table.rows.length <= 1)\n            return null;\n        }\n        return "columnheader";\n      }\n      if (isHeaderCell(nextSibling) && isHeaderCell(prevSibling))\n        return "columnheader";\n      if (isNonEmptyDataCell(nextSibling) || isNonEmptyDataCell(prevSibling))\n        return "rowheader";\n      return "columnheader";\n    },\n    "THEAD": () => "rowgroup",\n    "TIME": () => "time",\n    "TR": () => "row",\n    "UL": () => "list"\n  };\n  function isHeaderCell(element) {\n    return !!element && elementSafeTagName(element) === "TH";\n  }\n  function isNonEmptyDataCell(element) {\n    var _a;\n    if (!element || elementSafeTagName(element) !== "TD")\n      return false;\n    return !!(((_a = element.textContent) == null ? void 0 : _a.trim()) || element.children.length > 0);\n  }\n  var kPresentationInheritanceParents = {\n    "DD": ["DL", "DIV"],\n    "DIV": ["DL"],\n    "DT": ["DL", "DIV"],\n    "LI": ["OL", "UL"],\n    "TBODY": ["TABLE"],\n    "TD": ["TR"],\n    "TFOOT": ["TABLE"],\n    "TH": ["TR"],\n    "THEAD": ["TABLE"],\n    "TR": ["THEAD", "TBODY", "TFOOT", "TABLE"]\n  };\n  function getImplicitAriaRole(element) {\n    var _a;\n    const implicitRole = ((_a = kImplicitRoleByTagName[elementSafeTagName(element)]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || "";\n    if (!implicitRole)\n      return null;\n    let ancestor = element;\n    while (ancestor) {\n      const parent = parentElementOrShadowHost(ancestor);\n      const parents = kPresentationInheritanceParents[elementSafeTagName(ancestor)];\n      if (!parents || !parent || !parents.includes(elementSafeTagName(parent)))\n        break;\n      const parentExplicitRole = getExplicitAriaRole(parent);\n      if ((parentExplicitRole === "none" || parentExplicitRole === "presentation") && !hasPresentationConflictResolution(parent, parentExplicitRole))\n        return parentExplicitRole;\n      ancestor = parent;\n    }\n    return implicitRole;\n  }\n  var validRoles = [\n    "alert",\n    "alertdialog",\n    "application",\n    "article",\n    "banner",\n    "blockquote",\n    "button",\n    "caption",\n    "cell",\n    "checkbox",\n    "code",\n    "columnheader",\n    "combobox",\n    "complementary",\n    "contentinfo",\n    "definition",\n    "deletion",\n    "dialog",\n    "directory",\n    "document",\n    "emphasis",\n    "feed",\n    "figure",\n    "form",\n    "generic",\n    "grid",\n    "gridcell",\n    "group",\n    "heading",\n    "img",\n    "insertion",\n    "link",\n    "list",\n    "listbox",\n    "listitem",\n    "log",\n    "main",\n    "mark",\n    "marquee",\n    "math",\n    "meter",\n    "menu",\n    "menubar",\n    "menuitem",\n    "menuitemcheckbox",\n    "menuitemradio",\n    "navigation",\n    "none",\n    "note",\n    "option",\n    "paragraph",\n    "presentation",\n    "progressbar",\n    "radio",\n    "radiogroup",\n    "region",\n    "row",\n    "rowgroup",\n    "rowheader",\n    "scrollbar",\n    "search",\n    "searchbox",\n    "separator",\n    "slider",\n    "spinbutton",\n    "status",\n    "strong",\n    "subscript",\n    "superscript",\n    "switch",\n    "tab",\n    "table",\n    "tablist",\n    "tabpanel",\n    "term",\n    "textbox",\n    "time",\n    "timer",\n    "toolbar",\n    "tooltip",\n    "tree",\n    "treegrid",\n    "treeitem"\n  ];\n  function getExplicitAriaRole(element) {\n    const roles = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());\n    return roles.find((role) => validRoles.includes(role)) || null;\n  }\n  function hasPresentationConflictResolution(element, role) {\n    return hasGlobalAriaAttribute(element, role) || isFocusable(element);\n  }\n  function getAriaRole(element) {\n    const explicitRole = getExplicitAriaRole(element);\n    if (!explicitRole)\n      return getImplicitAriaRole(element);\n    if (explicitRole === "none" || explicitRole === "presentation") {\n      const implicitRole = getImplicitAriaRole(element);\n      if (hasPresentationConflictResolution(element, implicitRole))\n        return implicitRole;\n    }\n    return explicitRole;\n  }\n  function getAriaBoolean(attr) {\n    return attr === null ? void 0 : attr.toLowerCase() === "true";\n  }\n  function isElementIgnoredForAria(element) {\n    return ["STYLE", "SCRIPT", "NOSCRIPT", "TEMPLATE"].includes(elementSafeTagName(element));\n  }\n  function isElementHiddenForAria(element) {\n    if (isElementIgnoredForAria(element))\n      return true;\n    const style = getElementComputedStyle(element);\n    const isSlot = element.nodeName === "SLOT";\n    if ((style == null ? void 0 : style.display) === "contents" && !isSlot) {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === 1 && !isElementHiddenForAria(child))\n          return false;\n        if (child.nodeType === 3 && isVisibleTextNode(child))\n          return false;\n      }\n      return true;\n    }\n    const isOptionInsideSelect = element.nodeName === "OPTION" && !!element.closest("select");\n    if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n      return true;\n    return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\n  }\n  function belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\n    let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\n    if (hidden === void 0) {\n      hidden = false;\n      if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n        hidden = true;\n      if (!hidden) {\n        const style = getElementComputedStyle(element);\n        hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true;\n      }\n      if (!hidden) {\n        const parent = parentElementOrShadowHost(element);\n        if (parent)\n          hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\n      }\n      cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\n    }\n    return hidden;\n  }\n  function getIdRefs(element, ref) {\n    if (!ref)\n      return [];\n    const root = enclosingShadowRootOrDocument(element);\n    if (!root)\n      return [];\n    try {\n      const ids = ref.split(" ").filter((id) => !!id);\n      const result = [];\n      for (const id of ids) {\n        const firstElement = root.querySelector("#" + CSS.escape(id));\n        if (firstElement && !result.includes(firstElement))\n          result.push(firstElement);\n      }\n      return result;\n    } catch (e) {\n      return [];\n    }\n  }\n  function trimFlatString(s) {\n    return s.trim();\n  }\n  function asFlatString(s) {\n    return s.split("\\xA0").map((chunk) => chunk.replace(/\\r\\n/g, "\\n").replace(/[\\u200b\\u00ad]/g, "").replace(/\\s\\s*/g, " ")).join("\\xA0").trim();\n  }\n  function queryInAriaOwned(element, selector) {\n    const result = [...element.querySelectorAll(selector)];\n    for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) {\n      if (owned.matches(selector))\n        result.push(owned);\n      result.push(...owned.querySelectorAll(selector));\n    }\n    return result;\n  }\n  function getCSSContent(element, pseudo) {\n    const cache = pseudo === "::before" ? cachePseudoContentBefore : pseudo === "::after" ? cachePseudoContentAfter : cachePseudoContent;\n    if (cache == null ? void 0 : cache.has(element))\n      return cache == null ? void 0 : cache.get(element);\n    const style = getElementComputedStyle(element, pseudo);\n    let content;\n    if (style) {\n      const contentValue = style.content;\n      if (contentValue && contentValue !== "none" && contentValue !== "normal") {\n        if (style.display !== "none" && style.visibility !== "hidden") {\n          content = parseCSSContentPropertyAsString(element, contentValue, !!pseudo);\n        }\n      }\n    }\n    if (pseudo && content !== void 0) {\n      const display = (style == null ? void 0 : style.display) || "inline";\n      if (display !== "inline")\n        content = " " + content + " ";\n    }\n    if (cache)\n      cache.set(element, content);\n    return content;\n  }\n  function parseCSSContentPropertyAsString(element, content, isPseudo) {\n    if (!content || content === "none" || content === "normal") {\n      return;\n    }\n    try {\n      let tokens = tokenize(content).filter((token) => !(token instanceof WhitespaceToken));\n      const delimIndex = tokens.findIndex((token) => token instanceof DelimToken && token.value === "/");\n      if (delimIndex !== -1) {\n        tokens = tokens.slice(delimIndex + 1);\n      } else if (!isPseudo) {\n        return;\n      }\n      const accumulated = [];\n      let index = 0;\n      while (index < tokens.length) {\n        if (tokens[index] instanceof StringToken) {\n          accumulated.push(tokens[index].value);\n          index++;\n        } else if (index + 2 < tokens.length && tokens[index] instanceof FunctionToken && tokens[index].value === "attr" && tokens[index + 1] instanceof IdentToken && tokens[index + 2] instanceof CloseParenToken) {\n          const attrName = tokens[index + 1].value;\n          accumulated.push(element.getAttribute(attrName) || "");\n          index += 3;\n        } else {\n          return;\n        }\n      }\n      return accumulated.join("");\n    } catch {\n    }\n  }\n  function getAriaLabelledByElements(element) {\n    const ref = element.getAttribute("aria-labelledby");\n    if (ref === null)\n      return null;\n    const refs = getIdRefs(element, ref);\n    return refs.length ? refs : null;\n  }\n  function allowsNameFromContent(role, targetDescendant) {\n    const alwaysAllowsNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"].includes(role);\n    const descendantAllowsNameFromContent = targetDescendant && ["", "caption", "code", "contentinfo", "definition", "deletion", "emphasis", "insertion", "list", "listitem", "mark", "none", "paragraph", "presentation", "region", "row", "rowgroup", "section", "strong", "subscript", "superscript", "table", "term", "time"].includes(role);\n    return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n  }\n  function getElementAccessibleName(element, includeHidden) {\n    const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n    let accessibleName = cache == null ? void 0 : cache.get(element);\n    if (accessibleName === void 0) {\n      accessibleName = "";\n      const elementProhibitsNaming = ["caption", "code", "definition", "deletion", "emphasis", "generic", "insertion", "mark", "paragraph", "presentation", "strong", "subscript", "suggestion", "superscript", "term", "time"].includes(getAriaRole(element) || "");\n      if (!elementProhibitsNaming) {\n        accessibleName = asFlatString(getTextAlternativeInternal(element, {\n          includeHidden,\n          visitedElements: /* @__PURE__ */ new Set(),\n          embeddedInTargetElement: "self"\n        }));\n      }\n      cache == null ? void 0 : cache.set(element, accessibleName);\n    }\n    return accessibleName;\n  }\n  function getTextAlternativeInternal(element, options) {\n    var _a, _b, _c, _d;\n    if (options.visitedElements.has(element))\n      return "";\n    const childOptions = {\n      ...options,\n      embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement\n    };\n    if (!options.includeHidden) {\n      const isEmbeddedInHiddenReferenceTraversal = !!((_a = options.embeddedInLabelledBy) == null ? void 0 : _a.hidden) || !!((_b = options.embeddedInDescribedBy) == null ? void 0 : _b.hidden) || !!((_c = options.embeddedInNativeTextAlternative) == null ? void 0 : _c.hidden) || !!((_d = options.embeddedInLabel) == null ? void 0 : _d.hidden);\n      if (isElementIgnoredForAria(element) || !isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element)) {\n        options.visitedElements.add(element);\n        return "";\n      }\n    }\n    const labelledBy = getAriaLabelledByElements(element);\n    if (!options.embeddedInLabelledBy) {\n      const accessibleName = (labelledBy || []).map((ref) => getTextAlternativeInternal(ref, {\n        ...options,\n        embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) },\n        embeddedInDescribedBy: void 0,\n        embeddedInTargetElement: void 0,\n        embeddedInLabel: void 0,\n        embeddedInNativeTextAlternative: void 0\n      })).join(" ");\n      if (accessibleName)\n        return accessibleName;\n    }\n    const role = getAriaRole(element) || "";\n    const tagName = elementSafeTagName(element);\n    if (!!options.embeddedInLabel || !!options.embeddedInLabelledBy || options.embeddedInTargetElement === "descendant") {\n      const isOwnLabel = [...element.labels || []].includes(element);\n      const isOwnLabelledBy = (labelledBy || []).includes(element);\n      if (!isOwnLabel && !isOwnLabelledBy) {\n        if (role === "textbox") {\n          options.visitedElements.add(element);\n          if (tagName === "INPUT" || tagName === "TEXTAREA")\n            return element.value;\n          return element.textContent || "";\n        }\n        if (["combobox", "listbox"].includes(role)) {\n          options.visitedElements.add(element);\n          let selectedOptions;\n          if (tagName === "SELECT") {\n            selectedOptions = [...element.selectedOptions];\n            if (!selectedOptions.length && element.options.length)\n              selectedOptions.push(element.options[0]);\n          } else {\n            const listbox = role === "combobox" ? queryInAriaOwned(element, "*").find((e) => getAriaRole(e) === "listbox") : element;\n            selectedOptions = listbox ? queryInAriaOwned(listbox, '[aria-selected="true"]').filter((e) => getAriaRole(e) === "option") : [];\n          }\n          if (!selectedOptions.length && tagName === "INPUT") {\n            return element.value;\n          }\n          return selectedOptions.map((option) => getTextAlternativeInternal(option, childOptions)).join(" ");\n        }\n        if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {\n          options.visitedElements.add(element);\n          if (element.hasAttribute("aria-valuetext"))\n            return element.getAttribute("aria-valuetext") || "";\n          if (element.hasAttribute("aria-valuenow"))\n            return element.getAttribute("aria-valuenow") || "";\n          return element.getAttribute("value") || "";\n        }\n        if (["menu"].includes(role)) {\n          options.visitedElements.add(element);\n          return "";\n        }\n      }\n    }\n    const ariaLabel = element.getAttribute("aria-label") || "";\n    if (trimFlatString(ariaLabel)) {\n      options.visitedElements.add(element);\n      return ariaLabel;\n    }\n    if (!["presentation", "none"].includes(role)) {\n      if (tagName === "INPUT" && ["button", "submit", "reset"].includes(element.type)) {\n        options.visitedElements.add(element);\n        const value = element.value || "";\n        if (trimFlatString(value))\n          return value;\n        if (element.type === "submit")\n          return "Submit";\n        if (element.type === "reset")\n          return "Reset";\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (tagName === "INPUT" && element.type === "file") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length && !options.embeddedInLabelledBy)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        return "Choose File";\n      }\n      if (tagName === "INPUT" && element.type === "image") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length && !options.embeddedInLabelledBy)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        const alt = element.getAttribute("alt") || "";\n        if (trimFlatString(alt))\n          return alt;\n        const title = element.getAttribute("title") || "";\n        if (trimFlatString(title))\n          return title;\n        return "Submit";\n      }\n      if (!labelledBy && tagName === "BUTTON") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n      }\n      if (!labelledBy && tagName === "OUTPUT") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        return element.getAttribute("title") || "";\n      }\n      if (!labelledBy && (tagName === "TEXTAREA" || tagName === "SELECT" || tagName === "INPUT")) {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        const usePlaceholder = tagName === "INPUT" && ["text", "password", "search", "tel", "email", "url"].includes(element.type) || tagName === "TEXTAREA";\n        const placeholder = element.getAttribute("placeholder") || "";\n        const title = element.getAttribute("title") || "";\n        if (!usePlaceholder || title)\n          return title;\n        return placeholder;\n      }\n      if (!labelledBy && tagName === "FIELDSET") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === "LEGEND") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (!labelledBy && tagName === "FIGURE") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === "FIGCAPTION") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (tagName === "IMG") {\n        options.visitedElements.add(element);\n        const alt = element.getAttribute("alt") || "";\n        if (trimFlatString(alt))\n          return alt;\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (tagName === "TABLE") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === "CAPTION") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n        const summary = element.getAttribute("summary") || "";\n        if (summary)\n          return summary;\n      }\n      if (tagName === "AREA") {\n        options.visitedElements.add(element);\n        const alt = element.getAttribute("alt") || "";\n        if (trimFlatString(alt))\n          return alt;\n        const title = element.getAttribute("title") || "";\n        return title;\n      }\n      if (tagName === "SVG" || element.ownerSVGElement) {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === "TITLE" && child.ownerSVGElement) {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInLabelledBy: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n      }\n      if (element.ownerSVGElement && tagName === "A") {\n        const title = element.getAttribute("xlink:title") || "";\n        if (trimFlatString(title)) {\n          options.visitedElements.add(element);\n          return title;\n        }\n      }\n    }\n    const shouldNameFromContentForSummary = tagName === "SUMMARY" && !["presentation", "none"].includes(role);\n    if (allowsNameFromContent(role, options.embeddedInTargetElement === "descendant") || shouldNameFromContentForSummary || !!options.embeddedInLabelledBy || !!options.embeddedInDescribedBy || !!options.embeddedInLabel || !!options.embeddedInNativeTextAlternative) {\n      options.visitedElements.add(element);\n      const accessibleName = innerAccumulatedElementText(element, childOptions);\n      const maybeTrimmedAccessibleName = options.embeddedInTargetElement === "self" ? trimFlatString(accessibleName) : accessibleName;\n      if (maybeTrimmedAccessibleName)\n        return accessibleName;\n    }\n    if (!["presentation", "none"].includes(role) || tagName === "IFRAME") {\n      options.visitedElements.add(element);\n      const title = element.getAttribute("title") || "";\n      if (trimFlatString(title))\n        return title;\n    }\n    options.visitedElements.add(element);\n    return "";\n  }\n  function innerAccumulatedElementText(element, options) {\n    const tokens = [];\n    const visit = (node, skipSlotted) => {\n      var _a;\n      if (skipSlotted && node.assignedSlot)\n        return;\n      if (node.nodeType === 1) {\n        const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || "inline";\n        let token = getTextAlternativeInternal(node, options);\n        if (display !== "inline" || node.nodeName === "BR")\n          token = " " + token + " ";\n        tokens.push(token);\n      } else if (node.nodeType === 3) {\n        tokens.push(node.textContent || "");\n      }\n    };\n    tokens.push(getCSSContent(element, "::before") || "");\n    const content = getCSSContent(element);\n    if (content !== void 0) {\n      tokens.push(content);\n    } else {\n      const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n      if (assignedNodes.length) {\n        for (const child of assignedNodes)\n          visit(child, false);\n      } else {\n        for (let child = element.firstChild; child; child = child.nextSibling)\n          visit(child, true);\n        if (element.shadowRoot) {\n          for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n            visit(child, true);\n        }\n        for (const owned of getIdRefs(element, element.getAttribute("aria-owns")))\n          visit(owned, true);\n      }\n    }\n    tokens.push(getCSSContent(element, "::after") || "");\n    return tokens.join("");\n  }\n  var kAriaSelectedRoles = ["gridcell", "option", "row", "tab", "rowheader", "columnheader", "treeitem"];\n  function getAriaSelected(element) {\n    if (elementSafeTagName(element) === "OPTION")\n      return element.selected;\n    if (kAriaSelectedRoles.includes(getAriaRole(element) || ""))\n      return getAriaBoolean(element.getAttribute("aria-selected")) === true;\n    return false;\n  }\n  var kAriaCheckedRoles = ["checkbox", "menuitemcheckbox", "option", "radio", "switch", "menuitemradio", "treeitem"];\n  function getAriaChecked(element) {\n    const result = getChecked(element, true);\n    return result === "error" ? false : result;\n  }\n  function getChecked(element, allowMixed) {\n    const tagName = elementSafeTagName(element);\n    if (allowMixed && tagName === "INPUT" && element.indeterminate)\n      return "mixed";\n    if (tagName === "INPUT" && ["checkbox", "radio"].includes(element.type))\n      return element.checked;\n    if (kAriaCheckedRoles.includes(getAriaRole(element) || "")) {\n      const checked = element.getAttribute("aria-checked");\n      if (checked === "true")\n        return true;\n      if (allowMixed && checked === "mixed")\n        return "mixed";\n      return false;\n    }\n    return "error";\n  }\n  var kAriaPressedRoles = ["button"];\n  function getAriaPressed(element) {\n    if (kAriaPressedRoles.includes(getAriaRole(element) || "")) {\n      const pressed = element.getAttribute("aria-pressed");\n      if (pressed === "true")\n        return true;\n      if (pressed === "mixed")\n        return "mixed";\n    }\n    return false;\n  }\n  var kAriaExpandedRoles = ["application", "button", "checkbox", "combobox", "gridcell", "link", "listbox", "menuitem", "row", "rowheader", "tab", "treeitem", "columnheader", "menuitemcheckbox", "menuitemradio", "rowheader", "switch"];\n  function getAriaExpanded(element) {\n    if (elementSafeTagName(element) === "DETAILS")\n      return element.open;\n    if (kAriaExpandedRoles.includes(getAriaRole(element) || "")) {\n      const expanded = element.getAttribute("aria-expanded");\n      if (expanded === null)\n        return void 0;\n      if (expanded === "true")\n        return true;\n      return false;\n    }\n    return void 0;\n  }\n  var kAriaLevelRoles = ["heading", "listitem", "row", "treeitem"];\n  function getAriaLevel(element) {\n    const native = { "H1": 1, "H2": 2, "H3": 3, "H4": 4, "H5": 5, "H6": 6 }[elementSafeTagName(element)];\n    if (native)\n      return native;\n    if (kAriaLevelRoles.includes(getAriaRole(element) || "")) {\n      const attr = element.getAttribute("aria-level");\n      const value = attr === null ? Number.NaN : Number(attr);\n      if (Number.isInteger(value) && value >= 1)\n        return value;\n    }\n    return 0;\n  }\n  var kAriaDisabledRoles = ["application", "button", "composite", "gridcell", "group", "input", "link", "menuitem", "scrollbar", "separator", "tab", "checkbox", "columnheader", "combobox", "grid", "listbox", "menu", "menubar", "menuitemcheckbox", "menuitemradio", "option", "radio", "radiogroup", "row", "rowheader", "searchbox", "select", "slider", "spinbutton", "switch", "tablist", "textbox", "toolbar", "tree", "treegrid", "treeitem"];\n  function getAriaDisabled(element) {\n    return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);\n  }\n  function isNativelyDisabled(element) {\n    const isNativeFormControl = ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "OPTION", "OPTGROUP"].includes(elementSafeTagName(element));\n    return isNativeFormControl && (element.hasAttribute("disabled") || belongsToDisabledOptGroup(element) || belongsToDisabledFieldSet(element));\n  }\n  function belongsToDisabledOptGroup(element) {\n    return elementSafeTagName(element) === "OPTION" && !!element.closest("OPTGROUP[DISABLED]");\n  }\n  function belongsToDisabledFieldSet(element) {\n    const fieldSetElement = element == null ? void 0 : element.closest("FIELDSET[DISABLED]");\n    if (!fieldSetElement)\n      return false;\n    const legendElement = fieldSetElement.querySelector(":scope > LEGEND");\n    return !legendElement || !legendElement.contains(element);\n  }\n  function hasExplicitAriaDisabled(element, isAncestor = false) {\n    if (!element)\n      return false;\n    if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || "")) {\n      const attribute = (element.getAttribute("aria-disabled") || "").toLowerCase();\n      if (attribute === "true")\n        return true;\n      if (attribute === "false")\n        return false;\n      return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);\n    }\n    return false;\n  }\n  function getAccessibleNameFromAssociatedLabels(labels, options) {\n    return [...labels].map((label) => getTextAlternativeInternal(label, {\n      ...options,\n      embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) },\n      embeddedInNativeTextAlternative: void 0,\n      embeddedInLabelledBy: void 0,\n      embeddedInDescribedBy: void 0,\n      embeddedInTargetElement: void 0\n    })).filter((accessibleName) => !!accessibleName).join(" ");\n  }\n  function receivesPointerEvents(element) {\n    const cache = cachePointerEvents;\n    let e = element;\n    let result;\n    const parents = [];\n    for (; e; e = parentElementOrShadowHost(e)) {\n      const cached = cache.get(e);\n      if (cached !== void 0) {\n        result = cached;\n        break;\n      }\n      parents.push(e);\n      const style = getElementComputedStyle(e);\n      if (!style) {\n        result = true;\n        break;\n      }\n      const value = style.pointerEvents;\n      if (value) {\n        result = value !== "none";\n        break;\n      }\n    }\n    if (result === void 0)\n      result = true;\n    for (const parent of parents)\n      cache.set(parent, result);\n    return result;\n  }\n  var cacheAccessibleName;\n  var cacheAccessibleNameHidden;\n  var cacheAccessibleDescription;\n  var cacheAccessibleDescriptionHidden;\n  var cacheAccessibleErrorMessage;\n  var cacheIsHidden;\n  var cachePseudoContent;\n  var cachePseudoContentBefore;\n  var cachePseudoContentAfter;\n  var cachePointerEvents;\n  var cachesCounter2 = 0;\n  function beginAriaCaches() {\n    beginDOMCaches();\n    ++cachesCounter2;\n    cacheAccessibleName ??= /* @__PURE__ */ new Map();\n    cacheAccessibleNameHidden ??= /* @__PURE__ */ new Map();\n    cacheAccessibleDescription ??= /* @__PURE__ */ new Map();\n    cacheAccessibleDescriptionHidden ??= /* @__PURE__ */ new Map();\n    cacheAccessibleErrorMessage ??= /* @__PURE__ */ new Map();\n    cacheIsHidden ??= /* @__PURE__ */ new Map();\n    cachePseudoContent ??= /* @__PURE__ */ new Map();\n    cachePseudoContentBefore ??= /* @__PURE__ */ new Map();\n    cachePseudoContentAfter ??= /* @__PURE__ */ new Map();\n    cachePointerEvents ??= /* @__PURE__ */ new Map();\n  }\n  function endAriaCaches() {\n    if (!--cachesCounter2) {\n      cacheAccessibleName = void 0;\n      cacheAccessibleNameHidden = void 0;\n      cacheAccessibleDescription = void 0;\n      cacheAccessibleDescriptionHidden = void 0;\n      cacheAccessibleErrorMessage = void 0;\n      cacheIsHidden = void 0;\n      cachePseudoContent = void 0;\n      cachePseudoContentBefore = void 0;\n      cachePseudoContentAfter = void 0;\n      cachePointerEvents = void 0;\n    }\n    endDOMCaches();\n  }\n  var inputTypeToRole = {\n    "button": "button",\n    "checkbox": "checkbox",\n    "image": "button",\n    "number": "spinbutton",\n    "radio": "radio",\n    "range": "slider",\n    "reset": "button",\n    "submit": "button"\n  };\n\n  // ariaSnapshot.ts\n  var lastRef = 0;\n  function toInternalOptions(options) {\n    if (options.mode === "ai") {\n      return {\n        visibility: "ariaOrVisible",\n        refs: "interactable",\n        refPrefix: options.refPrefix,\n        includeGenericRole: true,\n        renderActive: !options.doNotRenderActive,\n        renderCursorPointer: true\n      };\n    }\n    if (options.mode === "autoexpect") {\n      return { visibility: "ariaAndVisible", refs: "none" };\n    }\n    if (options.mode === "codegen") {\n      return { visibility: "aria", refs: "none", renderStringsAsRegex: true };\n    }\n    return { visibility: "aria", refs: "none" };\n  }\n  function generateAriaTree(rootElement, publicOptions) {\n    const options = toInternalOptions(publicOptions);\n    const visited = /* @__PURE__ */ new Set();\n    const snapshot = {\n      root: { role: "fragment", name: "", children: [], props: {}, box: computeBox(rootElement), receivesPointerEvents: true },\n      elements: /* @__PURE__ */ new Map(),\n      refs: /* @__PURE__ */ new Map(),\n      iframeRefs: []\n    };\n    setAriaNodeElement(snapshot.root, rootElement);\n    const visit = (ariaNode, node, parentElementVisible) => {\n      if (visited.has(node))\n        return;\n      visited.add(node);\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\n        if (!parentElementVisible)\n          return;\n        const text = node.nodeValue;\n        if (ariaNode.role !== "textbox" && text)\n          ariaNode.children.push(node.nodeValue || "");\n        return;\n      }\n      if (node.nodeType !== Node.ELEMENT_NODE)\n        return;\n      const element = node;\n      const isElementVisibleForAria = !isElementHiddenForAria(element);\n      let visible = isElementVisibleForAria;\n      if (options.visibility === "ariaOrVisible")\n        visible = isElementVisibleForAria || isElementVisible(element);\n      if (options.visibility === "ariaAndVisible")\n        visible = isElementVisibleForAria && isElementVisible(element);\n      if (options.visibility === "aria" && !visible)\n        return;\n      const ariaChildren = [];\n      if (element.hasAttribute("aria-owns")) {\n        const ids = element.getAttribute("aria-owns").split(/\\s+/);\n        for (const id of ids) {\n          const ownedElement = rootElement.ownerDocument.getElementById(id);\n          if (ownedElement)\n            ariaChildren.push(ownedElement);\n        }\n      }\n      const childAriaNode = visible ? toAriaNode(element, options) : null;\n      if (childAriaNode) {\n        if (childAriaNode.ref) {\n          snapshot.elements.set(childAriaNode.ref, element);\n          snapshot.refs.set(element, childAriaNode.ref);\n          if (childAriaNode.role === "iframe")\n            snapshot.iframeRefs.push(childAriaNode.ref);\n        }\n        ariaNode.children.push(childAriaNode);\n      }\n      processElement(childAriaNode || ariaNode, element, ariaChildren, visible);\n    };\n    function processElement(ariaNode, element, ariaChildren, parentElementVisible) {\n      var _a;\n      const display = ((_a = getElementComputedStyle(element)) == null ? void 0 : _a.display) || "inline";\n      const treatAsBlock = display !== "inline" || element.nodeName === "BR" ? " " : "";\n      if (treatAsBlock)\n        ariaNode.children.push(treatAsBlock);\n      ariaNode.children.push(getCSSContent(element, "::before") || "");\n      const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n      if (assignedNodes.length) {\n        for (const child of assignedNodes)\n          visit(ariaNode, child, parentElementVisible);\n      } else {\n        for (let child = element.firstChild; child; child = child.nextSibling) {\n          if (!child.assignedSlot)\n            visit(ariaNode, child, parentElementVisible);\n        }\n        if (element.shadowRoot) {\n          for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n            visit(ariaNode, child, parentElementVisible);\n        }\n      }\n      for (const child of ariaChildren)\n        visit(ariaNode, child, parentElementVisible);\n      ariaNode.children.push(getCSSContent(element, "::after") || "");\n      if (treatAsBlock)\n        ariaNode.children.push(treatAsBlock);\n      if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0])\n        ariaNode.children = [];\n      if (ariaNode.role === "link" && element.hasAttribute("href")) {\n        const href = element.getAttribute("href");\n        ariaNode.props["url"] = href;\n      }\n      if (ariaNode.role === "textbox" && element.hasAttribute("placeholder") && element.getAttribute("placeholder") !== ariaNode.name) {\n        const placeholder = element.getAttribute("placeholder");\n        ariaNode.props["placeholder"] = placeholder;\n      }\n    }\n    beginAriaCaches();\n    try {\n      visit(snapshot.root, rootElement, true);\n    } finally {\n      endAriaCaches();\n    }\n    normalizeStringChildren(snapshot.root);\n    normalizeGenericRoles(snapshot.root);\n    return snapshot;\n  }\n  function computeAriaRef(ariaNode, options) {\n    if (options.refs === "none")\n      return;\n    if (options.refs === "interactable" && (!ariaNode.box.visible || !ariaNode.receivesPointerEvents))\n      return;\n    const element = ariaNodeElement(ariaNode);\n    let ariaRef = element._ariaRef;\n    if (!ariaRef || ariaRef.role !== ariaNode.role || ariaRef.name !== ariaNode.name) {\n      ariaRef = { role: ariaNode.role, name: ariaNode.name, ref: (options.refPrefix ?? "") + "e" + ++lastRef };\n      element._ariaRef = ariaRef;\n    }\n    ariaNode.ref = ariaRef.ref;\n  }\n  function toAriaNode(element, options) {\n    const active = element.ownerDocument.activeElement === element;\n    if (element.nodeName === "IFRAME") {\n      const ariaNode = {\n        role: "iframe",\n        name: "",\n        children: [],\n        props: {},\n        box: computeBox(element),\n        receivesPointerEvents: true,\n        active\n      };\n      setAriaNodeElement(ariaNode, element);\n      computeAriaRef(ariaNode, options);\n      return ariaNode;\n    }\n    const defaultRole = options.includeGenericRole ? "generic" : null;\n    const role = getAriaRole(element) ?? defaultRole;\n    if (!role || role === "presentation" || role === "none")\n      return null;\n    const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || "");\n    const receivesPointerEvents2 = receivesPointerEvents(element);\n    const box = computeBox(element);\n    if (role === "generic" && box.inline && element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE)\n      return null;\n    const result = {\n      role,\n      name,\n      children: [],\n      props: {},\n      box,\n      receivesPointerEvents: receivesPointerEvents2,\n      active\n    };\n    setAriaNodeElement(result, element);\n    computeAriaRef(result, options);\n    if (kAriaCheckedRoles.includes(role))\n      result.checked = getAriaChecked(element);\n    if (kAriaDisabledRoles.includes(role))\n      result.disabled = getAriaDisabled(element);\n    if (kAriaExpandedRoles.includes(role))\n      result.expanded = getAriaExpanded(element);\n    if (kAriaLevelRoles.includes(role))\n      result.level = getAriaLevel(element);\n    if (kAriaPressedRoles.includes(role))\n      result.pressed = getAriaPressed(element);\n    if (kAriaSelectedRoles.includes(role))\n      result.selected = getAriaSelected(element);\n    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n      if (element.type !== "checkbox" && element.type !== "radio" && element.type !== "file")\n        result.children = [element.value];\n    }\n    return result;\n  }\n  function normalizeGenericRoles(node) {\n    const normalizeChildren = (node2) => {\n      const result = [];\n      for (const child of node2.children || []) {\n        if (typeof child === "string") {\n          result.push(child);\n          continue;\n        }\n        const normalized = normalizeChildren(child);\n        result.push(...normalized);\n      }\n      const removeSelf = node2.role === "generic" && !node2.name && result.length <= 1 && result.every((c) => typeof c !== "string" && !!c.ref);\n      if (removeSelf)\n        return result;\n      node2.children = result;\n      return [node2];\n    };\n    normalizeChildren(node);\n  }\n  function normalizeStringChildren(rootA11yNode) {\n    const flushChildren = (buffer, normalizedChildren) => {\n      if (!buffer.length)\n        return;\n      const text = normalizeWhiteSpace(buffer.join(""));\n      if (text)\n        normalizedChildren.push(text);\n      buffer.length = 0;\n    };\n    const visit = (ariaNode) => {\n      const normalizedChildren = [];\n      const buffer = [];\n      for (const child of ariaNode.children || []) {\n        if (typeof child === "string") {\n          buffer.push(child);\n        } else {\n          flushChildren(buffer, normalizedChildren);\n          visit(child);\n          normalizedChildren.push(child);\n        }\n      }\n      flushChildren(buffer, normalizedChildren);\n      ariaNode.children = normalizedChildren.length ? normalizedChildren : [];\n      if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name)\n        ariaNode.children = [];\n    };\n    visit(rootA11yNode);\n  }\n  var cachedRegexSymbol = Symbol("cachedRegex");\n  function buildByRefMap(root, map = /* @__PURE__ */ new Map()) {\n    if (root == null ? void 0 : root.ref)\n      map.set(root.ref, root);\n    for (const child of (root == null ? void 0 : root.children) || []) {\n      if (typeof child !== "string")\n        buildByRefMap(child, map);\n    }\n    return map;\n  }\n  function compareSnapshots(ariaSnapshot, previousSnapshot) {\n    var _a;\n    const previousByRef = buildByRefMap(previousSnapshot == null ? void 0 : previousSnapshot.root);\n    const result = /* @__PURE__ */ new Map();\n    const visit = (ariaNode, previousNode) => {\n      let same = ariaNode.children.length === (previousNode == null ? void 0 : previousNode.children.length) && ariaNodesEqual(ariaNode, previousNode);\n      let canBeSkipped = same;\n      for (let childIndex = 0; childIndex < ariaNode.children.length; childIndex++) {\n        const child = ariaNode.children[childIndex];\n        const previousChild = previousNode == null ? void 0 : previousNode.children[childIndex];\n        if (typeof child === "string") {\n          same &&= child === previousChild;\n          canBeSkipped &&= child === previousChild;\n        } else {\n          let previous = typeof previousChild !== "string" ? previousChild : void 0;\n          if (child.ref)\n            previous = previousByRef.get(child.ref);\n          const sameChild = visit(child, previous);\n          if (!previous || !sameChild && !child.ref || previous !== previousChild)\n            canBeSkipped = false;\n          same &&= sameChild && previous === previousChild;\n        }\n      }\n      result.set(ariaNode, same ? "same" : canBeSkipped ? "skip" : "changed");\n      return same;\n    };\n    visit(ariaSnapshot.root, previousByRef.get((_a = previousSnapshot == null ? void 0 : previousSnapshot.root) == null ? void 0 : _a.ref));\n    return result;\n  }\n  function filterSnapshotDiff(nodes, statusMap) {\n    const result = [];\n    const visit = (ariaNode) => {\n      const status = statusMap.get(ariaNode);\n      if (status === "same") {\n      } else if (status === "skip") {\n        for (const child of ariaNode.children) {\n          if (typeof child !== "string")\n            visit(child);\n        }\n      } else {\n        result.push(ariaNode);\n      }\n    };\n    for (const node of nodes) {\n      if (typeof node === "string")\n        result.push(node);\n      else\n        visit(node);\n    }\n    return result;\n  }\n  function renderAriaTree(ariaSnapshot, publicOptions, previousSnapshot) {\n    const options = toInternalOptions(publicOptions);\n    const lines = [];\n    const includeText = options.renderStringsAsRegex ? textContributesInfo : () => true;\n    const renderString = options.renderStringsAsRegex ? convertToBestGuessRegex : (str) => str;\n    let nodesToRender = ariaSnapshot.root.role === "fragment" ? ariaSnapshot.root.children : [ariaSnapshot.root];\n    const statusMap = compareSnapshots(ariaSnapshot, previousSnapshot);\n    if (previousSnapshot)\n      nodesToRender = filterSnapshotDiff(nodesToRender, statusMap);\n    const visitText = (text, indent) => {\n      const escaped = yamlEscapeValueIfNeeded(renderString(text));\n      if (escaped)\n        lines.push(indent + "- text: " + escaped);\n    };\n    const createKey = (ariaNode, renderCursorPointer) => {\n      let key = ariaNode.role;\n      if (ariaNode.name && ariaNode.name.length <= 900) {\n        const name = renderString(ariaNode.name);\n        if (name) {\n          const stringifiedName = name.startsWith("/") && name.endsWith("/") ? name : JSON.stringify(name);\n          key += " " + stringifiedName;\n        }\n      }\n      if (ariaNode.checked === "mixed")\n        key += ` [checked=mixed]`;\n      if (ariaNode.checked === true)\n        key += ` [checked]`;\n      if (ariaNode.disabled)\n        key += ` [disabled]`;\n      if (ariaNode.expanded)\n        key += ` [expanded]`;\n      if (ariaNode.active && options.renderActive)\n        key += ` [active]`;\n      if (ariaNode.level)\n        key += ` [level=${ariaNode.level}]`;\n      if (ariaNode.pressed === "mixed")\n        key += ` [pressed=mixed]`;\n      if (ariaNode.pressed === true)\n        key += ` [pressed]`;\n      if (ariaNode.selected === true)\n        key += ` [selected]`;\n      if (ariaNode.ref) {\n        key += ` [ref=${ariaNode.ref}]`;\n        if (renderCursorPointer && hasPointerCursor(ariaNode))\n          key += " [cursor=pointer]";\n      }\n      return key;\n    };\n    const getSingleInlinedTextChild = (ariaNode) => {\n      return (ariaNode == null ? void 0 : ariaNode.children.length) === 1 && typeof ariaNode.children[0] === "string" && !Object.keys(ariaNode.props).length ? ariaNode.children[0] : void 0;\n    };\n    const visit = (ariaNode, indent, renderCursorPointer) => {\n      if (statusMap.get(ariaNode) === "same" && ariaNode.ref) {\n        lines.push(indent + `- ref=${ariaNode.ref} [unchanged]`);\n        return;\n      }\n      const isDiffRoot = !!previousSnapshot && !indent;\n      const escapedKey = indent + "- " + (isDiffRoot ? "<changed> " : "") + yamlEscapeKeyIfNeeded(createKey(ariaNode, renderCursorPointer));\n      const singleInlinedTextChild = getSingleInlinedTextChild(ariaNode);\n      if (!ariaNode.children.length && !Object.keys(ariaNode.props).length) {\n        lines.push(escapedKey);\n      } else if (singleInlinedTextChild !== void 0) {\n        const shouldInclude = includeText(ariaNode, singleInlinedTextChild);\n        if (shouldInclude)\n          lines.push(escapedKey + ": " + yamlEscapeValueIfNeeded(renderString(singleInlinedTextChild)));\n        else\n          lines.push(escapedKey);\n      } else {\n        lines.push(escapedKey + ":");\n        for (const [name, value] of Object.entries(ariaNode.props))\n          lines.push(indent + "  - /" + name + ": " + yamlEscapeValueIfNeeded(value));\n        const childIndent = indent + "  ";\n        const inCursorPointer = !!ariaNode.ref && renderCursorPointer && hasPointerCursor(ariaNode);\n        for (const child of ariaNode.children) {\n          if (typeof child === "string")\n            visitText(includeText(ariaNode, child) ? child : "", childIndent);\n          else\n            visit(child, childIndent, renderCursorPointer && !inCursorPointer);\n        }\n      }\n    };\n    for (const nodeToRender of nodesToRender) {\n      if (typeof nodeToRender === "string")\n        visitText(nodeToRender, "");\n      else\n        visit(nodeToRender, "", !!options.renderCursorPointer);\n    }\n    return lines.join("\\n");\n  }\n  function convertToBestGuessRegex(text) {\n    const dynamicContent = [\n      // 2mb\n      { regex: /\\b[\\d,.]+[bkmBKM]+\\b/, replacement: "[\\\\d,.]+[bkmBKM]+" },\n      // 2ms, 20s\n      { regex: /\\b\\d+[hmsp]+\\b/, replacement: "\\\\d+[hmsp]+" },\n      { regex: /\\b[\\d,.]+[hmsp]+\\b/, replacement: "[\\\\d,.]+[hmsp]+" },\n      // Do not replace single digits with regex by default.\n      // 2+ digits: [Issue 22, 22.3, 2.33, 2,333]\n      { regex: /\\b\\d+,\\d+\\b/, replacement: "\\\\d+,\\\\d+" },\n      { regex: /\\b\\d+\\.\\d{2,}\\b/, replacement: "\\\\d+\\\\.\\\\d+" },\n      { regex: /\\b\\d{2,}\\.\\d+\\b/, replacement: "\\\\d+\\\\.\\\\d+" },\n      { regex: /\\b\\d{2,}\\b/, replacement: "\\\\d+" }\n    ];\n    let pattern = "";\n    let lastIndex = 0;\n    const combinedRegex = new RegExp(dynamicContent.map((r) => "(" + r.regex.source + ")").join("|"), "g");\n    text.replace(combinedRegex, (match, ...args) => {\n      const offset = args[args.length - 2];\n      const groups = args.slice(0, -2);\n      pattern += escapeRegExp(text.slice(lastIndex, offset));\n      for (let i = 0; i < groups.length; i++) {\n        if (groups[i]) {\n          const { replacement } = dynamicContent[i];\n          pattern += replacement;\n          break;\n        }\n      }\n      lastIndex = offset + match.length;\n      return match;\n    });\n    if (!pattern)\n      return text;\n    pattern += escapeRegExp(text.slice(lastIndex));\n    return String(new RegExp(pattern));\n  }\n  function textContributesInfo(node, text) {\n    if (!text.length)\n      return false;\n    if (!node.name)\n      return true;\n    if (node.name.length > text.length)\n      return false;\n    const substr = text.length <= 200 && node.name.length <= 200 ? longestCommonSubstring(text, node.name) : "";\n    let filtered = text;\n    while (substr && filtered.includes(substr))\n      filtered = filtered.replace(substr, "");\n    return filtered.trim().length / text.length > 0.1;\n  }\n  var elementSymbol = Symbol("element");\n  function ariaNodeElement(ariaNode) {\n    return ariaNode[elementSymbol];\n  }\n  function setAriaNodeElement(ariaNode, element) {\n    ariaNode[elementSymbol] = element;\n  }\n\n  // index.ts\n  function snapshotForAI(rootElement = document.body, options = {}) {\n    const treeOptions = {\n      mode: "ai",\n      refPrefix: options.refPrefix || "",\n      doNotRenderActive: options.doNotRenderActive\n    };\n    const ariaSnapshot = generateAriaTree(rootElement, treeOptions);\n    const snapshot = renderAriaTree(ariaSnapshot, treeOptions);\n    return {\n      snapshot,\n      elements: ariaSnapshot.elements,\n      refs: ariaSnapshot.refs\n    };\n  }\n  function getElementByRef(ref, rootElement = document.body) {\n    const result = snapshotForAI(rootElement);\n    return result.elements.get(ref) || null;\n  }\n  function clickByRef(ref, rootElement = document.body) {\n    const element = getElementByRef(ref, rootElement);\n    if (element && element instanceof HTMLElement) {\n      element.click();\n      return true;\n    }\n    return false;\n  }\n  function typeByRef(ref, text, rootElement = document.body) {\n    const element = getElementByRef(ref, rootElement);\n    if (element && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {\n      element.focus();\n      element.value = text;\n      element.dispatchEvent(new Event("input", { bubbles: true }));\n      element.dispatchEvent(new Event("change", { bubbles: true }));\n      return true;\n    }\n    return false;\n  }\n  globalThis.__ariaSnapshot = {\n    snapshotForAI,\n    getElementByRef,\n    clickByRef,\n    typeByRef\n  };\n  return __toCommonJS(aria_snapshot_exports);\n})();\n"""


def get_init_script():
    """Get the JavaScript code to initialize the ARIA snapshot module.
    This should be called once after page load to inject the module.
    """
    return ARIA_SNAPSHOT_BUNDLE


def get_snapshot_script():
    """Get the JavaScript code for generating ARIA snapshots.
    Call get_init_script() first if not already initialized.
    """
    return """
(function() {
    if (typeof __ariaSnapshot === 'undefined') {
        return JSON.stringify({error: 'ARIA snapshot module not initialized'});
    }
    const result = __ariaSnapshot.snapshotForAI(document.body);
    return JSON.stringify({
        snapshot: result.snapshot,
        elementCount: result.elements.size
    });
})();
"""


def get_snapshot_only_script():
    """Get just the snapshot text without JSON wrapper."""
    return """
(function() {
    if (typeof __ariaSnapshot === 'undefined') {
        return 'Error: ARIA snapshot module not initialized';
    }
    return __ariaSnapshot.snapshotForAI(document.body).snapshot;
})();
"""


def get_click_by_ref_script(ref: str):
    """Get the JavaScript code for clicking an element by ref."""
    return f"""
(function() {{
    if (typeof __ariaSnapshot === 'undefined') {{
        return JSON.stringify({{success: false, error: 'ARIA snapshot module not initialized'}});
    }}
    const result = __ariaSnapshot.clickByRef('{ref}', document.body);
    return JSON.stringify({{success: result}});
}})();
"""


def get_type_by_ref_script(ref: str, text: str):
    """Get the JavaScript code for typing into an element by ref."""
    # Escape special characters
    escaped_text = (
        text.replace('\\', '\\\\').replace("'", "\\'").replace('\n', '\\n')
    )
    return f"""
(function() {{
    if (typeof __ariaSnapshot === 'undefined') {{
        return JSON.stringify({{success: false, error: 'ARIA snapshot module not initialized'}});
    }}
    const result = __ariaSnapshot.typeByRef('{ref}', '{escaped_text}', document.body);
    return JSON.stringify({{success: result}});
}})();
"""


def get_full_init_and_snapshot_script():
    """Get a combined script that initializes and returns snapshot in one call.
    Useful for first-time snapshot when module is not yet initialized.
    """
    return (
        ARIA_SNAPSHOT_BUNDLE
        + """

(function() {
    const result = __ariaSnapshot.snapshotForAI(document.body);
    return result.snapshot;
})();
"""
    )
