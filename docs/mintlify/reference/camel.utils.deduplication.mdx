<a id="camel.utils.deduplication"></a>

<a id="camel.utils.deduplication.DeduplicationResult"></a>

## DeduplicationResult Objects

```python
class DeduplicationResult(BaseModel)
```

The result of deduplication.

**Attributes**:

- `original_texts` _List[str]_ - The original texts.
- `unique_ids` _List[int]_ - A list of ids that are unique (not duplicates).
- `unique_embeddings_dict` _Dict[int, List[float]]_ - A mapping from the
  index of each unique text to its embedding.
- `duplicate_to_target_map` _Dict[int, int]_ - A mapping from the index of
  the duplicate text to the index of the text it is considered a
  duplicate of.

<a id="camel.utils.deduplication.deduplicate_internally"></a>

#### deduplicate\_internally

```python
def deduplicate_internally(texts: List[str],
                           threshold: float = 0.65,
                           embedding_instance: Optional[
                               BaseEmbedding[str]] = None,
                           embeddings: Optional[List[List[float]]] = None,
                           strategy: Literal["top1", "llm-supervise"] = "top1",
                           batch_size: int = 1000) -> DeduplicationResult
```

Deduplicate a list of strings based on their cosine similarity.

You can either:
1) Provide a CAMEL `BaseEmbedding` instance via `embedding_instance` to let
this function handle the embedding internally, OR
2) Directly pass a list of pre-computed embeddings to `embeddings`.

If both `embedding_instance` and `embeddings` are provided, the function
will raise a ValueError to avoid ambiguous usage.

strategy is used to specify different strategies, where 'top1' selects the
one with highest similarity, and 'llm-supervise' uses LLM to determine if
texts are duplicates (not yet implemented).

**Arguments**:

- `texts` _List[str]_ - The list of texts to be deduplicated.
- `threshold` _float, optional_ - The similarity threshold for considering
  two texts as duplicates. (default: :obj:`0.65`)
  embedding_instance (Optional[BaseEmbedding[str]], optional):
  A CAMEL embedding instance for automatic embedding. (default:
  :obj:`None`)
  embeddings (Optional[List[List[float]]], optional):
  Pre-computed embeddings of `texts`. Each element in the list
  corresponds to the embedding of the text in the same index of
  `texts`. (default: :obj:`None`)
  strategy (Literal["top1", "llm-supervise"], optional):
  The strategy to use for deduplication. (default: :obj:`"top1"`)
- `batch_size` _int, optional_ - The size of the batch to use for
  calculating cosine similarities. (default: :obj:`1000`)
  

**Returns**:

- `DeduplicationResult` - An object that contains:
  - `original_texts`: The original texts.
  - `unique_ids`: The unique ids after deduplication.
  - `unique_embeddings_dict`: A dict mapping from (unique) text id
  to its embedding.
  - `duplicate_to_target_map`: A dict mapping from the id of a
  duplicate text to the id of the text it is considered a duplicate
  of.
  

**Raises**:

- `NotImplementedError` - If the strategy is not "top1".
- `ValueError` - If neither embeddings nor embedding_instance is provided,
  or if both are provided at the same time.
- `ValueError` - If the length of `embeddings` does not match the length of
  `texts`.
  

**Example**:

  >>> from camel.embeddings.openai_embedding import OpenAIEmbedding
  >>> # Suppose we have 5 texts, some of which may be duplicates
  >>> texts = [
  ...     "What is AI?",
  ...     "Artificial Intelligence is about machines",
  ...     "What is AI?",
  ...     "Deep Learning is a subset of AI",
  ...     "What is artificial intelligence?"
  ... ]
  >>> # or any other BaseEmbedding instance
  >>> embedding_model = OpenAIEmbedding()
  >>> result = deduplicate_internally(
  ...     texts=texts,
  ...     threshold=0.7,
  ...     embedding_instance=embedding_model
  ... )
  >>> print("Unique ids:")
  >>> for uid in result.unique_ids:
  ...     print(texts[uid])
  Unique ids:
  What is AI?
  Artificial Intelligence is about machines
  Deep Learning is a subset of AI
  What is artificial intelligence?
  
  >>> print("Duplicate map:")
  >>> print(result.duplicate_to_target_map)
- `{2` - 0}
  # This indicates the text at index 2 is considered
  # a duplicate of index 0.

