<a id="camel.datasets.base_generator"></a>

<a id="camel.datasets.base_generator.BaseGenerator"></a>

## BaseGenerator Objects

```python
class BaseGenerator(abc.ABC, IterableDataset)
```

Abstract base class for data generators.

This class defines the interface for generating synthetic datapoints.
Concrete implementations should provide specific generation strategies.

<a id="camel.datasets.base_generator.BaseGenerator.__init__"></a>

#### \_\_init\_\_

```python
def __init__(seed: int = 42,
             buffer: int = 20,
             cache: Union[str, Path, None] = None,
             data_path: Union[str, Path, None] = None,
             **kwargs)
```

Initialize the base generator.

**Arguments**:

- `seed` _int_ - Random seed for reproducibility. (default: :obj:`42`)
- `buffer` _int_ - Amount of DataPoints to be generated when the
  iterator runs out of DataPoints in data. (default:  :obj:`20`)
- `cache` _Union[str, Path, None]_ - Optional path to save generated
  datapoints during iteration. If None is provided, datapoints
  will be discarded every 100 generations.
- `data_path` _Union[str, Path, None]_ - Optional path to a JSONL file
  to initialize the dataset from.
- `**kwargs` - Additional generator parameters.

<a id="camel.datasets.base_generator.BaseGenerator.generate_new"></a>

#### generate\_new

```python
@abc.abstractmethod
async def generate_new(n: int, **kwargs) -> None
```

Generate n new datapoints and append them to self._data.

Subclass implementations must generate the specified number of
datapoints and append them directly to the `self._data` list.
This method should not return the datapoints; the iterator
relies on `self._data` being populated.

**Arguments**:

- `n` _int_ - Number of datapoints to generate and append.
- `**kwargs` - Additional generation parameters.
  

**Returns**:

- `None` - This method should not return anything.
  

**Example**:

    ```python
    async def generate_new(self, n: int, **kwargs) -> None:
        new_points = [DataPoint(...) for _ in range(n)]
        self._data.extend(new_points)
    ```

<a id="camel.datasets.base_generator.BaseGenerator.__aiter__"></a>

#### \_\_aiter\_\_

```python
def __aiter__()
```

Async iterator that yields datapoints dynamically.

If a `data_path` was provided during initialization, those datapoints
are yielded first. When self._data is empty, 20 new datapoints
are generated. Every 100 yields, the batch is appended to the
JSONL file or discarded if `cache` is None.

**Yields**:

- `DataPoint` - A single datapoint.

<a id="camel.datasets.base_generator.BaseGenerator.__iter__"></a>

#### \_\_iter\_\_

```python
def __iter__()
```

Synchronous iterator for PyTorch IterableDataset compatibility.

If a `data_path` was provided during initialization, those datapoints
are yielded first. When self._data is empty, 20 new datapoints
are generated. Every 100 yields, the batch is appended to the
JSONL file or discarded if `cache` is None.

**Yields**:

- `DataPoint` - A single datapoint.

<a id="camel.datasets.base_generator.BaseGenerator.sample"></a>

#### sample

```python
def sample() -> DataPoint
```

Returns the next datapoint from the current dataset
synchronously.

**Raises**:

- `RuntimeError` - If called in an async context.
  

**Returns**:

- `DataPoint` - The next DataPoint.
  

**Notes**:

  This method is intended for synchronous contexts.
  Use 'async_sample' in asynchronous contexts to
  avoid blocking or runtime errors.

<a id="camel.datasets.base_generator.BaseGenerator.async_sample"></a>

#### async\_sample

```python
async def async_sample() -> DataPoint
```

Returns the next datapoint from the current dataset asynchronously.

**Returns**:

- `DataPoint` - The next datapoint.
  

**Notes**:

  This method is intended for asynchronous contexts. Use 'sample'
  in synchronous contexts.

<a id="camel.datasets.base_generator.BaseGenerator.save_to_jsonl"></a>

#### save\_to\_jsonl

```python
def save_to_jsonl(file_path: Union[str, Path]) -> None
```

Saves the generated datapoints to a JSONL (JSON Lines) file.

Each datapoint is stored as a separate JSON object on a new line.

**Arguments**:

- `file_path` _Union[str, Path]_ - Path to save the JSONL file.
  

**Raises**:

- `ValueError` - If no datapoints have been generated.
- `IOError` - If there is an issue writing to the file.
  

**Notes**:

  - Uses `self._data`, which contains the generated datapoints.
  - Appends to the file if it already exists.
  - Ensures compatibility with large datasets by using JSONL format.

<a id="camel.datasets.base_generator.BaseGenerator.flush"></a>

#### flush

```python
def flush(file_path: Union[str, Path]) -> None
```

Flush the current data to a JSONL file and clear the data.

**Arguments**:

- `file_path` _Union[str, Path]_ - Path to save the JSONL file.
  

**Notes**:

  - Uses `save_to_jsonl` to save `self._data`.

