---
title: "Workforce"
icon: "users"
---

<Card title="Concept" icon="users">
Workforce is CAMEL-AIâ€™s powerful multi-agent collaboration engine. It enables you to assemble, manage, and scale teams of AI agents to tackle complex tasks that are beyond the capabilities of a single agent. By creating a "workforce" of specialized agents, you can automate intricate workflows, foster parallel execution, and achieve more robust and intelligent solutions.
</Card>

## Core Components Deep Dive

<Card title="The Workforce Class" icon="layer-group">
The `Workforce` class is the central orchestrator. It manages the entire lifecycle of a multi-agent task.

```python title="Workforce Initialization"
class Workforce(BaseNode):
    def __init__(
        self,
        description: str,
        children: Optional[List[BaseNode]] = None,
        coordinator_agent: Optional[ChatAgent] = None,
        task_agent: Optional[ChatAgent] = None,
        new_worker_agent: Optional[ChatAgent] = None,
        graceful_shutdown_timeout: float = 15.0,
        share_memory: bool = False,
        use_structured_output_handler: bool = True,
    ) -> None:
    # ...
```

**Key Parameters:**

-   `description`: A high-level description of the workforce's purpose.
-   `children`: A list of initial worker nodes.
-   `coordinator_agent`: A `ChatAgent` for assigning tasks.
-   `task_agent`: A `ChatAgent` for decomposing tasks.
-   `new_worker_agent`: A template `ChatAgent` for creating new workers.
-   `share_memory`: If `True`, `SingleAgentWorker` instances will share memory.
-   `use_structured_output_handler`: Defaults to `True`. Enables structured output handling so models without native JSON + tool-calling can still interop reliably.
</Card>

<Card title="Worker Types" icon="users-gear">
The Workforce can be composed of different types of workers, each suited for different kinds of tasks.
<CardGroup cols={2}>
    <Card title="SingleAgentWorker" icon="user">
        The most common type of worker. It consists of a single `ChatAgent` configured with specific tools and a system prompt. For efficiency, it uses an `AgentPool` to reuse agent instances.
    </Card>
    <Card title="RolePlayingWorker" icon="users">
        This worker uses a `RolePlaying` session between two agents (an assistant and a user) to accomplish a task. It's useful for brainstorming, debate, or exploring a topic from multiple perspectives.
    </Card>
</CardGroup>
</Card>

## Creating and Adding Workers

<Card title="SingleAgentWorker Examples" icon="user">
Here are detailed examples of how to create and add `SingleAgentWorker` instances to your workforce.
<Tabs>
<Tab title="Simple Worker">
```python
from camel.societies.workforce import Workforce
from camel.agents import ChatAgent

workforce = Workforce("My Research Team")

# Create a general-purpose agent
general_agent = ChatAgent(system_message="You are a helpful research assistant.")

# Add the worker
workforce.add_single_agent_worker(
    description="A worker for general research tasks",
    worker=general_agent,
)
```
</Tab>
<Tab title="Worker with Tools">
```python
from camel.societies.workforce import Workforce
from camel.agents import ChatAgent
from camel.toolkits import SearchToolkit

workforce = Workforce("Web Research Team")

# Create a search agent with a web search tool
search_agent = ChatAgent(
    system_message="A research assistant that can search the web.",
    tools=[SearchToolkit().search_duckduckgo]
)

# Add the worker
workforce.add_single_agent_worker(
    description="A worker that can perform web searches",
    worker=search_agent,
)
```
</Tab>
<Tab title="Worker with a Specific Model">
```python
from camel.societies.workforce import Workforce
from camel.agents import ChatAgent
from camel.models import ModelFactory
from camel.types import ModelType

workforce = Workforce("Creative Writing Team")

# Create an agent with a specific model for creative tasks
creative_model = ModelFactory.create(model_type=ModelType.GPT_5_MINI)
creative_agent = ChatAgent(
    system_message="A creative writer for generating stories.",
    model=creative_model
)

# Add the worker
workforce.add_single_agent_worker(
    description="A worker for creative writing",
    worker=creative_agent,
)
```
</Tab>
</Tabs>
</Card>

<Card title="RolePlayingWorker Example" icon="users">
This example sets up a role-playing session between a "solution architect" and a "software developer" to design a system.

```python title="role_playing_example.py"
from camel.societies.workforce import Workforce

workforce = Workforce("System Design Team")

workforce.add_role_playing_worker(
    description="A role-playing session for system design.",
    assistant_role_name="Software Developer",
    user_role_name="Solution Architect",
    assistant_agent_kwargs=dict(
        system_message="You are a software developer responsible for implementing the system."
    ),
    user_agent_kwargs=dict(
        system_message="You are a solution architect responsible for the high-level design."
    ),
    chat_turn_limit=5,
)

# ... process a task with this workforce ...
```
</Card>

<Card title="Task Lifecycle and Management" icon="diagram-project">
The `Workforce` manages a sophisticated task lifecycle.

```mermaid
graph TD
    A[Start: High-Level Task] --> B{Decompose Task}
    B --> C[Subtask 1]
    B --> D[Subtask 2]
    B --> E[...]
    C --> F{Assign Tasks}
    D --> F
    E --> F
    F --> G[Execute Tasks in Parallel by Workers]
    G --> H{Task Completed?}
    H -->|Yes| I[Store Result as Dependency]
    H -->|No| J{Failure Recovery}
    J -->|Retry| G
    J -->|Replan| G
    J -->|Decompose| B
    I --> K[Next Ready Tasks]
    K --> G
    G --> L[All Tasks Done]
    L --> M[Final Result]
```

1.  **Decomposition**: The `task_agent` breaks the main task into smaller, self-contained subtasks.
2.  **Assignment**: The `coordinator_agent` assigns each subtask to the most suitable worker.
3.  **Execution**: Workers execute their assigned tasks, often in parallel.
4.  **Completion**: A task's result is stored and can be used as a dependency for other tasks.
5.  **Failure Handling**: If a task fails, the `Workforce` initiates its recovery protocols.
</Card>

<Card title="Advanced Usage: Human-in-the-Loop (HITL)" icon="hand">
The `Workforce` offers powerful features for human intervention, perfect for debugging or workflows requiring human oversight. To use HITL, run `process_task` in a separate thread to keep the main thread free for user input.

```python title="hitl_example.py" expandable
import threading
import time
from camel.societies.workforce import Workforce
from camel.agents import ChatAgent
from camel.tasks import Task

# Setup workforce
workforce = Workforce("Interactive Workforce")
worker = ChatAgent(system_message="A simple worker")
workforce.add_single_agent_worker(description="Worker", worker=worker)
task = Task(content="This is a test task.")

# Function to run the workforce
def run_workforce():
    print("Workforce started in background thread.")
    workforce.process_task(task)
    print("Workforce finished.")

# Run the workforce in a background thread
workforce_thread = threading.Thread(target=run_workforce)
workforce_thread.start()

# Give the workforce time to start
time.sleep(1)

# Main thread for user interaction
print("Press 'p' to pause, 'r' to resume, 's' to stop.")
while workforce_thread.is_alive():
    try:
        user_input = input()
        if user_input == 'p':
            workforce.pause()
            print("Workforce paused.")
            pending_tasks = workforce.get_pending_tasks()
            print(f"Pending tasks ({len(pending_tasks)}):")
            for t in pending_tasks:
                print(f"- {t.id}: {t.content}")
        elif user_input == 'r':
            workforce.resume()
            print("Workforce resumed.")
        elif user_input == 's':
            workforce.stop_gracefully()
            print("Workforce stopping.")
            break
    except (KeyboardInterrupt, EOFError):
        workforce.stop_gracefully()
        break

workforce_thread.join()
print("HITL example finished.")
```
<Note>
The `process_task` method is a synchronous wrapper that manages the asyncio event loop internally. For more direct control in async applications, use `process_task_async`.
</Note>
</Card>

<Card title="Key Data Structures" icon="database">
The `workforce` module uses several Pydantic models to ensure structured data exchange.

-   **`WorkerConf`**: Defines the configuration for a new worker.
-   **`TaskResult`**: Represents the output of a completed task.
-   **`TaskAssignment`**: A single task-to-worker assignment, including dependencies.
-   **`TaskAssignResult`**: A list of `TaskAssignment` objects.
-   **`RecoveryDecision`**: The output of the failure analysis process, dictating the recovery strategy.

Understanding these models is key to interpreting the workforce's internal state and logs.
</Card>

<CardGroup cols={2}>
  <Card
    title="Cookbook: Hackathon Judge Committee"
    icon="bookmark"
    href="https://colab.research.google.com/drive/18ajYUMfwDx3WyrjHow3EvUMpKQDcrLtr?usp=sharing"
  >
    See a real-world multi-agent workflow with Workforce.
  </Card>
  <Card
    title="API Reference"
    icon="book"
    href="/reference/#societies.workforce"
  >
    Full documentation for advanced usage and configuration.
  </Card>
</CardGroup>